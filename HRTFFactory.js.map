{"version":3,"file":"HRTFFactory.js","sources":["HRTFFactory.cpp","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/emscripten/bind.h","./3DTI_Toolkit_Core/Common/Debugger.h","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/vector","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/ostream","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/string","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/memory","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__functional_base","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/type_traits","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__mutex_base","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/fstream","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/ios","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/iosfwd","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/streambuf","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__locale","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/algorithm","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/iterator","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/locale","3DTI_Toolkit_Core/BinauralSpatializer/HRTF.h","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/unordered_map","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__hash_table","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/utility","3DTI_Toolkit_Core/Common/Buffer.h","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/new","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__split_buffer","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/emscripten/wire.h","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/emscripten/val.h","3DTI_Toolkit_Core/BinauralSpatializer/Listener.h","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/typeinfo","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/cmath","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/functional","3DTI_Toolkit_Core/BinauralSpatializer/SingleSourceDSP.h","3DTI_Toolkit_Core/Common/Fconvolver.h","3DTI_Toolkit_Core/Common/DistanceAttenuator.h","3DTI_Toolkit_Core/BinauralSpatializer/Convolver.h","3DTI_Toolkit_Core/BinauralSpatializer/ILD.h","3DTI_Toolkit_Core/Common/FiltersChain.h","3DTI_Toolkit_Core/BinauralSpatializer/Core.h","3DTI_Toolkit_Core/Common/BiquadFilter.cpp","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libc/math.h","3DTI_Toolkit_Core/Common/Debugger.cpp","3DTI_Toolkit_Core/Common/Debugger.h","3DTI_Toolkit_Core/Common/DistanceAttenuator.cpp","3DTI_Toolkit_Core/Common/Fconvolver.cpp","3DTI_Toolkit_Core/Common/FiltersChain.cpp","3DTI_Toolkit_Core/Common/Magnitudes.cpp","3DTI_Toolkit_Core/Common/Quaternion.cpp","3DTI_Toolkit_Core/Common/Transform.cpp","3DTI_Toolkit_Core/Common/Vector3.cpp","3DTI_Toolkit_Core/Common/fftsg.cpp","3DTI_Toolkit_Core/BinauralSpatializer/Convolver.cpp","3DTI_Toolkit_Core/BinauralSpatializer/Core.cpp","3DTI_Toolkit_Core/BinauralSpatializer/HRTF.cpp","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/include/libcxx/list","3DTI_Toolkit_Core/BinauralSpatializer/ILD.cpp","3DTI_Toolkit_Core/BinauralSpatializer/Listener.cpp","3DTI_Toolkit_Core/BinauralSpatializer/SingleSourceDSP.cpp","/Users/alexanderwallin/Downloads/emsdk_portable/emscripten/1.35.0/system/lib/embind/bind.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AA;AAAA;AAAA;AAAA;AAAA;AwCvXA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AxCoXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AwCpXA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AxCssCA;AAAA;AAAA;AwCtsCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AxCssCA;AAAA;AAAA;AwCtsCA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AxC+yCA;AAAA;AAAA;AAAA;AAtuCA;AAAA;AAAA;AG89DA;AAAA;AHxvBA;AAAA;;AAEA;AACA;AAAA;AA/uCA;AAAA;AAAA;AGu+DA;AAAA;AHvvBA;AAAA;AAAA;AG3jBA;AH4jBA;AAAA;AKNA;ALIA;AAAA;AAAA;AG/JA;AAAA;AAAA;AAAA;AEmKA;AFpKA;AAAA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AE6CA;AF7CA;AAAA;AAAA;AAyEA;AAAA;AAAA;AE5BA;AF4BA;AAAA;AH7BA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AKXA;;ALWA;;;;;;;;;;AwCrzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AxCksCA;AAAA;AAAA;AwClsCA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AxC2yCA;AAAA;AAAA;AAAA;AAtuCA;AAAA;AAAA;AG89DA;AAAA;AHxvBA;AAAA;;AAEA;AACA;AAAA;AA/uCA;AAAA;AAAA;AGu+DA;AAAA;AHvvBA;AAAA;AAAA;AG3jBA;AH4jBA;AAAA;AKNA;ALIA;AAAA;AAAA;AG/JA;AAAA;AAAA;AAAA;AEmKA;AFpKA;AAAA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AE6CA;AF7CA;AAAA;AAAA;AAyEA;AAAA;AAAA;AE5BA;AF4BA;AAAA;AH7BA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AKXA;;ALWA;;;;;;;;;;;AwC7zCA;AAAA;AAAA;;AAYA;AAAA;AnCsyCA;AmCtyCA;AAAA;AAAA;AxCmgCA;AAAA;AAAA;;AwCjgCA;AAAA;;;;;AAAA;AAAA;A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AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhGA;AAAA;AAAA;;AAkGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAiUA;AAAA;;AACA;AAAA;AACA;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;AAAA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;;AA3BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AA2PA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AALA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxvDA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhKA;AAAA;AAAA;;AAkKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA/NA;AAAA;AAAA;;AA6UA;;;AA1GA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhFA;AAAA;AAAA;;AAkFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvGA;AAAA;AAAA;;AA0GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAg7CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAttCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAs2CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AA90CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AA64CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApsCA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhGA;AAAA;AAAA;;AAkGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAl7BA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhKA;AAAA;AAAA;;AAkKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAnOA;AAAA;AAAA;;AAqVA;;;AA9GA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhFA;AAAA;AAAA;;AAkFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3GA;AAAA;AAAA;;AA8GA;;;;;;;;;;;;;;;;;;;AAmEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AA+BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAg4CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxwBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApDA;AAAA;AAAA;;AAsDA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AA1MA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AAAA;;AAtBA;AAAA;AAAA;AAAA;AAsBA;AAAA;;;AAlBA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAUA;AAAA;;;AANA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuLA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjEA;AAAA;AAAA;;AAmEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8LA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AA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AAAA;AAIA;;;;AgC4bA;AAAA;AjCZA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6CwiBA;AAAA;AAAA;;;AAEA;AAAA;;AACA;AAAA;AAAA;AjCfA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C2iBA;AAAA;;AAAA;;;;;;AACA;AAAA;AjChBA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C4iBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AjCjBA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C6iBA;AAAA;;AAAA;;;;;;AACA;AAAA;AjClBA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C8iBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AAIA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AjDu1BA;AAAA;AAAA;AiDv1BA;AAAA;AAAA;AjCzBA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6CqjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDu1BA;AAAA;AAAA;AiDv1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDu1BA;AAAA;AAAA;AiDv1BA;AACA;AAAA;AAAA;AAAA;AAAA;AjDs1BA;AAAA;AAAA;AiDt1BA;AAAA;AAAA;AjC1BA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6CsjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDs1BA;AAAA;AAAA;AiDt1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDs1BA;AAAA;AAAA;AiDt1BA;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0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C4nBA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AjCjGA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C6nBA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AjClGA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C8nBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AjCnGA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C+nBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;A5C43BA;;A4C53BA;;;;;;;AAAA;AAAA;AAAA;A/BrYA;AAAA;AbiwCA;AajwCA;AACA;AAAA;AAAA;AbgwCA;AahwCA;AAAA;AAAA;AAAA;AAAA;A+BqYA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;A/CgmBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+C1vCA;AAAA;AAAA;A/CgmBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+C1vCA;;;;;;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;A/C4lBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CtvCA;AAAA;AAAA;A/C4lBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CtvCA;;;;;;;AAAA;AAAA;;AAGA;;AAIA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;A5Cu2BA;;A4Cv2BA;;;;;;;AACA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;A/C2kBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CruCA;AAAA;AAAA;A/C2kBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CruCA;;;;;;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;A/CukBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CjuCA;AAAA;AAAA;A/CukBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CjuCA;;;;;;;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAAA;;;;;;;AAAA;A5C61BA;;A4C71BA;;;;;;;AAAA;AAAA;AAAA;A/BpaA;AAAA;AbiwCA;AajwCA;AACA;AAAA;AAAA;AbgwCA;AahwCA;AAAA;AAAA;AAAA;AAAA;A+BoaA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;A/CikBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+C3tCA;AAAA;AAAA;A/CikBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+C3tCA;;;;;;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;A/C6jBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CvtCA;AAAA;AAAA;A/C6jBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CvtCA;;;;;;;AAAA;AAAA;;AAGA;;AA7DA;AAAA;AAAA;AAAA;;AAgEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AjC0MA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAhWA;AAgWA;AiC1MA;AACA;AAAA;AAAA;AjCkGA;ACuqBA;AAAA;AAAA;AA9zCA;AAAA;AA8zCA;ADvqBA;AAAA;AAAA;AAAA;AAzPA;AAyPA;AiClGA;AAAA;AAAA;AjCjIA;AAAA;AAAA;AAAA;ACjcA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAIA;;AgCokBA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AjCpJA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6CgrBA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;A/CgjBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+C1sCA;AAAA;AAAA;A/CgjBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+C1sCA;;;;;;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;A/C4iBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CtsCA;AAAA;AAAA;A/C4iBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CtsCA;;;;;;;AAAA;AAAA;;AAIA;AACA;AAAA;AjC/JA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C2rBA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AjChKA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C4rBA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AjCjKA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C6rBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AjClKA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C8rBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;A5C6zBA;;A4C7zBA;;;;;;;AAAA;AAAA;AAAA;A/BpcA;AAAA;AbiwCA;AajwCA;AACA;AAAA;AAAA;AbgwCA;AahwCA;AAAA;AAAA;AAAA;AAAA;A+BocA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;A/CiiBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+C3rCA;AAAA;AAAA;A/CiiBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+C3rCA;;;;;;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;A/C6hBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CvrCA;AAAA;AAAA;A/C6hBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CvrCA;;;;;;;AAAA;AAAA;;AAGA;;AAGA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;A5C0yBA;;A4C1yBA;;;;;;;AACA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;A/C8gBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;A+CxqCA;AAAA;AAAA;A/C8gBA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;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A;AjCnCA;ACuqBA;AAAA;AAAA;AA9zCA;AAAA;AA8zCA;ADvqBA;AAAA;AAAA;AAAA;AAzPA;AAyPA;AiCmCA;AAAA;AAAA;AjCtQA;AAAA;AAAA;AAAA;ACjcA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAIA;;AgCusBA;AAAA;AAAA;AjCnCA;ACuqBA;AAAA;AAAA;AA9zCA;AAAA;AA8zCA;ADvqBA;AAAA;AAAA;AAAA;AAzPA;AAyPA;AiCmCA;AAAA;AAAA;AjCtQA;AAAA;AAAA;AAAA;ACjcA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAIA;;AgC0sBA;AAAA;AjC1RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6CszBA;;AAAA;;;;;;;AAGA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AjC9RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C0zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDklBA;AAAA;AAAA;AiDllBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC9RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C0zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDklBA;AAAA;AAAA;AiDllBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC9RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C0zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDklBA;AAAA;AAAA;AiDllBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDklBA;AAAA;AAAA;AiDllBA;AACA;AAAA;AAAA;AjC/RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C2zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDilBA;AAAA;AAAA;AiDjlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC/RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C2zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDilBA;AAAA;AAAA;AiDjlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC/RA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C2zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDilBA;AAAA;AAAA;AiDjlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDilBA;AAAA;AAAA;AiDjlBA;AAFA;AAAA;AAAA;;AAMA;AAAA;AjCnSA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C+zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCnSA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C+zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCnSA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6C+zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AjCpSA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6Cg0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCpSA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6Cg0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCpSA;AAAA;AC7cA;AAAA;AAAA;AdivBA;AAAA;ACh0BA;AY4hBA;AboSA;AAAA;ACh0BA;A6Cg0BA;A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A;;AAEA;AAAA;AAAA;AjChiBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CynCA;AAAA;;AAAA;;;;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AjCliBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C2nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD0RA;AAAA;AAAA;AiD1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCliBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C2nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD0RA;AAAA;AAAA;AiD1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCliBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C2nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD0RA;AAAA;AAAA;AiD1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDiRA;AAAA;AAAA;AiDjRA;AADA;AAAA;AAAA;;AAIA;AAAA;AjCriBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C8nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCriBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C8nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCriBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C8nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AvBgUA;AAAA;AuBhUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;AAEA;AAAA;AAAA;AjC3iBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CooCA;AAAA;;AAAA;;;;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AjC7iBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CsoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD+QA;AAAA;AAAA;AiD/QA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC7iBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CsoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD+QA;AAAA;AAAA;AiD/QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC7iBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CsoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD+QA;AAAA;AAAA;AiD/QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDsQA;AAAA;AAAA;AiDtQA;AADA;AAAA;AAAA;;AAIA;AAAA;AjChjBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjChjBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjChjBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AvBqTA;AAAA;AuBrTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;;;;;;;AAAA;AAAA;AAAA;A/CoFA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;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;AAAA;AiDpNA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCxmBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CisCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDoNA;AAAA;AAAA;AiDpNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCxmBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CisCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDoNA;AAAA;AAAA;AiDpNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD2MA;AAAA;AAAA;AiD3MA;AADA;AAAA;AAAA;;AAIA;AAAA;AjC3mBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CosCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC3mBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CosCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC3mBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CosCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AvB0PA;AAAA;AuB1PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;AAEA;AAAA;AAAA;AjCjnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C0sCA;AAAA;;AAAA;;;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AjCnnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C4sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDyMA;AAAA;AAAA;AiDzMA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCnnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C4sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDyMA;AAAA;AAAA;AiDzMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCnnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C4sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDyMA;AAAA;AAAA;AiDzMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDgMA;AAAA;AAAA;AiDhMA;AADA;AAAA;AAAA;;AAIA;AAAA;AjCtnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C+sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCtnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C+sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCtnBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C+sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AvB+OA;AAAA;AuB/OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;;;;;;AAAA;AAAA;AAAA;A/CcA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;AAAA;;;;;;A+CxqBA;AAAA;AAAA;A/CcA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+CxqBA;;;;;;AA+DA;AAAA;AA/DA;;;AAAA;AAAA;;;;;;;;AA+DA;AAAA;;AA/DA;AA+DA;AAAA;AAAA;;;;;;AAzDA;;;;;;AAAA;AAAA;AAAA;A/CQA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;AAAA;;;;;;A+ClqBA;AAAA;AAAA;A/CQA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+ClqBA;;;;;;AAyDA;AAAA;AAzDA;;;AAAA;AAAA;;;;;;;;AAyDA;AAAA;;AAzDA;AAyDA;AAAA;AAAA;;;;AAlDA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AjCxWA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AA1SA;AA0SA;AiCwWA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AjCzWA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AA1SA;AA0SA;AiCyWA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AjC1WA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AA1SA;AA0SA;AiC0WA;AAEA;AAAA;AAAA;AjCjdA;AC2rBA;AAAA;AAAA;AAnsCA;AAAA;AAmsCA;AD3rBA;AAAA;AAAA;AAAA;AArMA;AAqMA;AiCidA;AAAA;AAAA;AjC3nBA;AAAA;AAAA;AAAA;AC3WA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAIA;;;AgCs+BA;AAAA;AAAA;AjCjdA;AC2rBA;AAAA;AAAA;AAnsCA;AAAA;AAmsCA;AD3rBA;AAAA;AAAA;AAAA;AArMA;AAqMA;AiCidA;AAAA;AAAA;AjC3nBA;AAAA;AAAA;AAAA;AC3WA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AgCs+BA;AAAA;AAAA;AjCjdA;AC2rBA;AAAA;AAAA;AAnsCA;AAAA;AAmsCA;AD3rBA;AAAA;AAAA;AAAA;AArMA;AAqMA;AiCidA;AAAA;AAAA;AjC3nBA;AAAA;AAAA;AAAA;AC3WA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AgCw+BA;AAAA;;AAEA;AAAA;AAAA;AjChpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyuCA;AAAA;;AAAA;;;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AjClpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C2uCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD0KA;AAAA;AAAA;AiD1KA;AAAA;AAAA;AAAA;AAAA;AAAA;AjClpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C2uCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD0KA;AAAA;AAAA;AiD1KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjClpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C2uCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD0KA;AAAA;AAAA;AiD1KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDiKA;AAAA;AAAA;AiDjKA;AADA;AAAA;AAAA;;AAIA;AAAA;AjCrpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C8uCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCrpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C8uCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjCrpBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6C8uCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AvBgNA;AAAA;AuBhNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;AAEA;AAAA;AAAA;AjC3pBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CovCA;AAAA;;AAAA;;;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AjC7pBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CsvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD+JA;AAAA;AAAA;AiD/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC7pBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CsvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD+JA;AAAA;AAAA;AiD/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjC7pBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CsvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AjD+JA;AAAA;AAAA;AiD/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjDsJA;AAAA;AAAA;AiDtJA;AADA;AAAA;AAAA;;AAIA;AAAA;AjChqBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjChqBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AjChqBA;AAAA;ACvXA;AAAA;AAAA;Ad8lBA;AAAA;ACh0BA;AYylBA;AbuOA;AAAA;ACh0BA;A6CyvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AvBqMA;AAAA;AuBrMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;;;;;;AAAA;AAAA;AAAA;A/C5BA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;AAAA;;;;;;A+C9nBA;AAAA;AAAA;A/C5BA;AAAA;ACo9BA;AAAA;AAnLA;ADvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;A+C9nBA;;;;;;AAqBA;AAAA;AArBA;;;AAAA;AAA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CA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;AhCgBA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AgCmBA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;AAAA;;;;;AhCxCA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA;;;;;AhCLA;AAAA;;;;;AAjBA;;;;;AgCsBA","sourcesContent":["\n#include <stdio.h>\n#include <vector>\n#include <assert.h>\n#include <emscripten/bind.h>\n#include \"3DTI_Toolkit_Core/Common/Buffer.h\"\n#include \"3DTI_Toolkit_Core/Common/Debugger.h\"\n#include \"3DTI_Toolkit_Core/Common/Quaternion.h\"\n#include \"3DTI_Toolkit_Core/Common/Transform.h\"\n#include \"3DTI_Toolkit_Core/BinauralSpatializer/HRTF.h\"\n#include \"3DTI_Toolkit_Core/BinauralSpatializer/Listener.h\"\n#include \"3DTI_Toolkit_Core/BinauralSpatializer/SingleSourceDSP.h\"\n\nusing namespace emscripten;\n\nclass FloatArray {\npublic:\n\n  FloatArray(std::vector<float> data) {\n    _data = data;\n  }\n\n  float get(int index) {\n    return _data[index];\n  }\n\n  int size() {\n    return _data.size();\n  }\n\nprivate:\n  std::vector<float> _data;\n};\n\nclass HRIR {\npublic:\n  HRIR( std::vector<float> data, int azimuth, int elevation )\n    : azimuth( azimuth ), elevation( elevation )\n  {\n    // printf(\"size %i\\n\", data.size() );\n    // printf(\"azimuth %i\\n\", azimuth);\n    // printf(\"elevation %i\\n\", elevation);\n    // assert(data.size() == 512);\n    for ( int i = 0; i < data.size(); i++ ) {\n      buffer[i] = data[i];\n      // printf(\"i = %f\\n\", buffer[i]);\n    }\n\n  }\n  ~HRIR() {};\n\n  float buffer[1024];\n  int azimuth, elevation;\n};\n\n\nclass HRTFFactory\n{\npublic:\n  static CHRTF create( std::vector<HRIR> hrirs ) {\n\n    const int length = 512;\n\n    CHRTF hrtf;\n    hrtf.BeginSetup(hrirs.size(), length, 44100);\n\n    for ( int i = 0; i < hrirs.size(); ++i )\n    {\n      HRIR &h = hrirs[i];\n\n      // Create a HRIR struct\n      HRIR_struct hrir_value;\n      hrir_value.leftHRIR.resize(length);\n      hrir_value.rightHRIR.resize(length);\n\n      // For wav files the delay is incorporated in the HRIR, so the variable delay is zero\n      hrir_value.leftDelay  = 0;\n      hrir_value.rightDelay = 0;\n\n      for ( int j = 0; j < length; j++ )\n      {\n        hrir_value.leftHRIR[j]  = h.buffer[j];\n        hrir_value.rightHRIR[j] = h.buffer[j + length];\n      }\n\n      hrtf.AddHRIR( h.azimuth, h.elevation, std::move(hrir_value) );\n    }\n\n    hrtf.EndSetup();\n\n    return hrtf;\n  }\n\n  static void PrintBuffer(CMonoBuffer<float> & buffer) {\n    printf(\"PrintBuffer()\\n\");\n    for (int i = 0; i < buffer.size(); i++) {\n      printf(\"%i = %f\\n\", i, buffer[i]);\n    }\n  }\n\n  static CMonoBuffer<float> CreateMonoBuffer(std::vector<float> data) {\n    CMonoBuffer<float> buf(data.size());\n    for (int i; i < data.size(); i++) {\n      buf[i] = data[i];\n    }\n    return buf;\n  }\n\n  static FloatArray GetSpatializedAudio(Binaural::CSingleSourceDSP & source, Binaural::CListener & listener, CMonoBuffer<float> & inBuffer) {\n    std::vector<float> outputData;\n    CStereoBuffer<float> outBuffer;\n\n    source.ProcessAnechoic(listener, inBuffer, outBuffer);\n\n    for (int i = 0; i < outBuffer.size(); i++) {\n      outputData.push_back(outBuffer[i]);\n    }\n\n    FloatArray output(outputData);\n    return output;\n  }\n};\n\nclass Logger\n{\npublic:\n  static void LogShit() {\n    cout << GET_FIRST_ERROR_STRUCT() << std::endl;\n    cout << GET_LAST_RESULT_STRUCT() << std::endl;\n  }\n\n  static std::string GetLastLogMessage() {\n    TDebuggerResultStruct lastLogEntry = GET_LAST_RESULT_STRUCT();\n    return lastLogEntry.description + \" | \" + lastLogEntry.suggestion + \" | \" + lastLogEntry.filename + \" | line number: \" + std::to_string(lastLogEntry.linenumber);\n  }\n\n  static void SetErrorLogFile(std::string filename) {\n    CDebugger::Instance().SetErrorLogFile(filename, true);\n  }\n};\n\n\n// Binding code\nEMSCRIPTEN_BINDINGS(HRTFModule) {\n  CDebugger::Instance().SetVerbosityMode(VERBOSITY_MODE_ALL);\n  CDebugger::Instance().SetAssertMode(ASSERT_MODE_PARANOID);\n\n  register_vector<float>(\"VectorFloat\");\n  register_vector<HRIR>(\"VectorHRIR\");\n\n  class_<FloatArray>(\"FloatArray\")\n    .constructor<std::vector<float>>()\n    .function(\"get\", &FloatArray::get)\n    .function(\"size\", &FloatArray::size)\n    ;\n\n  // value_object<TDebuggerResultStruct>(\"TDebuggerResultStruct\")\n  //   .field(\"id\", &TDebuggerResultStruct::id)\n  //   .field(\"description\", &TDebuggerResultStruct::description)\n  //   .field(\"suggestion\", &TDebuggerResultStruct::suggestion)\n  //   .field(\"filename\", &TDebuggerResultStruct::filename)\n  //   .field(\"linenumber\", &TDebuggerResultStruct::linenumber);\n\n  class_<Logger>(\"Logger\")\n    .class_function(\"LogShit\", &Logger::LogShit)\n    .class_function(\"GetLastLogMessage\", &Logger::GetLastLogMessage)\n    .class_function(\"SetErrorLogFile\", &Logger::SetErrorLogFile);\n\n  class_<HRIR>(\"HRIR\")\n    .constructor<std::vector<float>, int, int>()\n    ;\n\n  class_<HRTFFactory>(\"HRTFFactory\")\n    .class_function(\"create\", &HRTFFactory::create)\n    // .class_function(\"CreateFrom3dti\", &HRTF::CreateFrom3dti)\n    // .class_function(\"CreateFrom3dtiStream\", &HRTF::CreateFrom3dtiStream)\n    .class_function(\"PrintBuffer\", &HRTFFactory::PrintBuffer)\n    .class_function(\"CreateMonoBuffer\", &HRTFFactory::CreateMonoBuffer)\n    .class_function(\"GetSpatializedAudio\", &HRTFFactory::GetSpatializedAudio)\n    ;\n\n  // emscripten::function(\"CreateFrom3dti\", &HRTF::CreateFrom3dti);\n\n  // Buffers\n  class_<CBuffer<1, float>>(\"CMonoBuffer\")\n    .constructor<int>()\n    .property(\"size\", &CBuffer<1, float>::size)\n    ;\n\n  class_<CBuffer<2, float>>(\"CStereoBuffer\")\n    .constructor<int>()\n    .property(\"size\", &CBuffer<2, float>::size)\n    ;\n\n  // CHRTF\n  class_<CHRTF>(\"CHRTF\")\n    .function(\"GetHRIR_left_frequency\", &CHRTF::GetHRIR_left_frequency)\n    .function(\"GetHRIR_right_frequency\", &CHRTF::GetHRIR_right_frequency)\n    ;\n\n  // value_object<HRIR_struct>(\"HRIR_struct\")\n  //   .field(\"leftDelay\", &HRIR_struct::leftDelay)\n  //   .field(\"leftHRIR\", &HRIR_struct::leftHRIR)\n  //   .field(\"rightDelay\", &HRIR_struct::rightDelay)\n  //   .field(\"rightHRIR\", &HRIR_struct::rightHRIR)\n  //   ;\n\n  value_object<oneEarHRIR_struct>(\"oneEarHRIR_struct\")\n    .field(\"delay\", &oneEarHRIR_struct::delay)\n    .field(\"HRIR\", &oneEarHRIR_struct::HRIR)\n    ;\n\n  // value_object<orientation>(\"orientation\")\n  //   .field(\"azimuth\", &orientation::azimuth)\n  //   .field(\"elevation\", &orientation::elevation)\n  //   ;\n\n  // enum_<T_ear>(\"T_ear\")\n  //   .value(\"LEFT\", LEFT)\n  //   .value(\"RIGHT\", RIGHT)\n  //   ;\n\n  // CVector3\n  class_<CVector3>(\"CVector3\")\n    .constructor<float, float, float>()\n    .property(\"x\", &CVector3::x)\n    .property(\"y\", &CVector3::y)\n    .property(\"z\", &CVector3::z)\n    ;\n\n  // CQuaternion\n  class_<CQuaternion>(\"CQuaternion\")\n    .class_function(\"FromAxisAngle\", &CQuaternion::FromAxisAngle)\n    .constructor<float, float, float, float>()\n    // ToAxisAngle takes a float reference argument, which is a bit tricky.\n    // One solution is to wrap it in a proxy function.\n    // @link https://github.com/kripken/emscripten/issues/611\n    // .function(\"toAxisAngle\", &CQuaternion::ToAxisAngle)\n    ;\n\n  // CTransform\n  class_<CTransform>(\"CTransform\")\n    .constructor<>()\n    .function(\"GetPosition\", &CTransform::GetPosition)\n    .function(\"SetPosition\", &CTransform::SetPosition)\n    .function(\"GetOrientation\", &CTransform::GetOrientation)\n    .function(\"SetOrientation\", &CTransform::SetOrientation)\n    ;\n\n  // CListener\n  class_<Binaural::CListener>(\"CListener\")\n    .constructor<Binaural::CCore*, float>()\n    .smart_ptr<std::shared_ptr<Binaural::CListener>>(\"CListenerPtr\")\n    .function(\"GetHRTF\", &Binaural::CListener::GetHRTF)\n    .function(\"LoadHRTF\", &Binaural::CListener::LoadHRTF)\n    .function(\"GetListenerTransform\", &Binaural::CListener::GetListenerTransform)\n    .function(\"SetListenerTransform\", &Binaural::CListener::SetListenerTransform)\n    ;\n\n  // CSingleSourceDSP\n  class_<Binaural::CSingleSourceDSP>(\"CSingleSourceDSP\")\n    .smart_ptr<std::shared_ptr<Binaural::CSingleSourceDSP>>(\"CSingleSourceDSPPtr\")\n    .function(\"SetInterpolation\", &Binaural::CSingleSourceDSP::SetInterpolation)\n    .function(\"SetFrequencyConvolution\", &Binaural::CSingleSourceDSP::SetFrequencyConvolution)\n    .function(\"GetSourceTransform\", &Binaural::CSingleSourceDSP::GetSourceTransform)\n    .function(\"SetSourceTransform\", &Binaural::CSingleSourceDSP::SetSourceTransform)\n    .function(\"ProcessAnechoic\", select_overload<void(const Binaural::CListener &, const CMonoBuffer<float> &, CStereoBuffer<float> &)>(&Binaural::CSingleSourceDSP::ProcessAnechoic))\n    ;\n\n  // CCore\n  class_<Binaural::CCore>(\"CCore\")\n    .constructor<>()\n    .function(\"CreateListener\", &Binaural::CCore::CreateListener)\n    .function(\"RemoveListener\", &Binaural::CCore::RemoveListener)\n    .function(\"CreateSingleSourceDSP\", &Binaural::CCore::CreateSingleSourceDSP)\n    .function(\"RemoveSingleSourceDSP\", &Binaural::CCore::RemoveSingleSourceDSP)\n    ;\n}\n\n","#pragma once\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void (*GenericFunction)();\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n    \n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static GenericFunction getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static GenericFunction getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<internal::GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n","/**\n* \\class CDebugger\n*\n* \\brief Declaration of CDebugger interface.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n\n#ifndef _DEBUGGER_H_\n#define _DEBUGGER_H_\n\n#include <string>\n#include <mutex>\n#include <fstream>\n\n/*! \\file */\n\nusing namespace std;\n\n/** \\brief If SWITCH_ON_3DTI_DEBUGGER is undefined, the debugger is completely disabled, causing 0 overhead\n*/\n\n//#define SWITCH_ON_3DTI_DEBUGGER // Make sure you know what you are doing if you define this as it will create a lot of overhead even in Release mode.\n\n//#define _3DTI_ANDROID_DEBUGGER\n#ifdef _3DTI_ANDROID_DEBUGGER\n\n#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, \"3DTI_CORE\", __VA_ARGS__))\n#define LOGV(...) ((void)__android_log_print(ANDROID_LOG_VERBOSE, \"3DTI_CORE\", __VA_ARGS__))\n#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, \"3DTI_CORE\", __VA_ARGS__))\n\n#define SET_RESULT(errorID, suggestion) CDebugger::Instance().AndroidSetResult(errorID, suggestion, __FILE__, __LINE__)\n\n#define ASSERT(condition, errorID, suggestionError, suggestionOK) CDebugger::Instance().AndroidAssertTest(condition, errorID, suggestionError, suggestionOK, __FILE__, __LINE__)\n\n#define WATCH(whichVar, varValue, className) ((void)0)\n\n#define GET_LAST_RESULT() ((void)0)\n\n#define GET_LAST_RESULT_STRUCT() ((void)0)\n\n#define GET_FIRST_ERROR_STRUCT() ((void)0)\n\n#endif\n\n#if !defined (SWITCH_ON_3DTI_DEBUGGER) && !defined(_3DTI_ANDROID_DEBUGGER)\n\n///////////////////////////////////////////////////\n/// Dummy Macro definitions \n\n#define SET_RESULT(errorID, suggestion) ((void)0)\n\n#define ASSERT(condition, errorID, suggestionError, suggestionOK) ((void)0)\n\n#define WATCH(whichVar, varValue, className) ((void)0)\n\n#define GET_LAST_RESULT() ((void)0)\n\n#define GET_LAST_RESULT_STRUCT() ((void)0)\n\n#define GET_FIRST_ERROR_STRUCT() ((void)0)\n\n#endif\n\n#if defined(SWITCH_ON_3DTI_DEBUGGER)\n\n///////////////////////////////////////////////////\n/// Macro definitions for asserts, setting results and watching variables\n\n/** \\brief Macro used by internal classes for reporting results to debugger\n*/\n#define SET_RESULT(errorID, suggestion) CDebugger::Instance().SetResult(errorID, suggestion, __FILE__, __LINE__)\n\n/** \\brief Macro used by internal classes for throwing asserts to debugger\n*/\n#define ASSERT(condition, errorID, suggestionError, suggestionOK) CDebugger::Instance().AssertTest(condition, errorID, suggestionError, suggestionOK, __FILE__, __LINE__)\n\n/** \\brief Macro used by internal classes to allow watch of internal variables in debugger\n*/\n#define WATCH(whichVar, varValue, className) CDebugger::Instance().Watch<className>(whichVar, varValue)\n\n/** \\brief Macro for getting (only the ID of) the last result reported to the debugger\n*\t\\details Please, check in the documentation which methods report errors/warnings to debugger\n*\t\\retval result ID of last result/error/warning\n*/\n#define GET_LAST_RESULT() CDebugger::Instance().GetLastResult()\n\n/** \\brief Macro for getting (the full structure of) the last result reported to the debugger\n*\t\\details Please, check in the documentation which methods report errors/warnings to debugger\n*\t\\retval resultStruct full structure with information on the last result/error/warning (See \\link TDebuggerResultStruct \\endlink)\n*/\n#define GET_LAST_RESULT_STRUCT() CDebugger::Instance().GetLastResultStruct()\n\n/** \\brief Macro for getting (the full structure of) the first error reported to the debugger in a block of code\n*\t\\details Please, check in the documentation which methods report errors/warnings to debugger\n*\t\\pre The starting point of the block of code is marked using \\link ResetErrors \\endlink\n*\t\\retval errorStruct full structure with information on the first result/error/warning (See \\link TDebuggerResultStruct \\endlink)\n*/\n#define GET_FIRST_ERROR_STRUCT() CDebugger::Instance().GetFirstErrorStruct()\n\n#endif\n\n#if defined(SWITCH_ON_3DTI_DEBUGGER) || defined(_3DTI_ANDROID_DEBUGGER)\n\n//\n// Result/Error data structures\n//\n\n/** \\brief ID of result reported to debugger\n*/\nenum TDebuggerResultID\n{ \n\t// No error\n\tRESULT_OK,\t\t\t\t\t\t///< No error. Everything went ok\n\n\t// General errors\n\tRESULT_ERROR_UNKNOWN,\t\t\t///< Unknown error (use only for weird situations, when you don't have any clue of the error source)\n\tRESULT_ERROR_NOTSET,\t\t\t///< The value of some parameter was not set\n\tRESULT_ERROR_BADALLOC,\t\t\t///< Memory allocation failure\n\tRESULT_ERROR_NULLPOINTER,\t\t///< Trying to use a pointer which is null\n\tRESULT_ERROR_DIVBYZERO,\t\t\t///< Division by zero\n\tRESULT_ERROR_CASENOTDEFINED,\t///< Some case in a switch was not defined (typically, use this for the \"default\" case of a switch)\t\n\tRESULT_ERROR_PHYSICS,\t\t\t///< Trying to do something which is not physically correct\n\tRESULT_ERROR_INVALID_PARAM,     ///< Param value is not valid\n\tRESULT_ERROR_OUTOFRANGE,\t\t///< Trying to access an array or vector position outside its size\n\tRESULT_ERROR_BADSIZE,\t\t\t///< Trying to fill a data structure with a bad data size\n\tRESULT_ERROR_NOTINITIALIZED,\t///< Using or returning a value which is not initialized\n\tRESULT_ERROR_SYSTEMCALL,\t\t///< A system call returned an error\n\tRESULT_ERROR_NOTALLOWED,\t\t///< Trying to do something which is not allowed in the current context\n\tRESULT_ERROR_NOTIMPLEMENTED,\t///< A method was defined in the interface for future versions, but it is not implemented yet\n\n\t// More errors...\n\n\t// Warnings\n\tRESULT_WARNING\t\t\t\t\t///< Description to be specified in suggestion\t\n};\n\n/** Struct with full information about one error/result/warning\n*/\nstruct TDebuggerResultStruct\n{\n\tTDebuggerResultID id;\t///< ID of result\n\tstring description;\t\t///< Description of result\n\tstring suggestion;\t\t///< Suggestion for fixing error or further information about result\n\tstring filename;\t\t///< File from which result was reported\n\tint linenumber;\t\t\t///< Line numer at which result was reported (within filename file)\n};\n\n/** \\brief Stream output of \\link TDebuggerResultStruct \\endlink\n*/\ninline std::ostream & operator<<(std::ostream & out, const TDebuggerResultStruct & r)\n{\n\tout << \"RESULT #\" << r.id << \" in File \" << r.filename << \"(\" << r.linenumber << \"): \" << r.description << \" - \" << r.suggestion;\n\treturn out;\n}\n\n//\n// Verbosity modes data structures and presets\n//\n\n/*********************************************/\n\n/** \\brief Preset verbosity modes\n*/\n#define VERBOSITY_MODE_SILENT\t\t\t0\t///< Nothing to show\n#define VERBOSITYMODE_ERRORSANDWARNINGS\t1\t///< Show errors and warnings, but not OK results\n#define VERBOSITY_MODE_ONLYERRORS\t\t2\t///< Show only errors, not OK nor warnings\n#define VERBOSITY_MODE_ALL\t\t\t\t3\t///< Show every type of result: error, warning and OK. Use this with caution, may report a huge amount of information...\n\n/*********************************************/\n\n/** \\brief Type definition for verbosity modes\n*/\nstruct TDebuggerVerbosityMode\n{\n\tbool showErrors;\t\t///< Do show error results\n\tbool showWarnings;\t\t///< Do show warning results\n\tbool showOk;\t\t\t///< Do show OK results\n\n\tbool showID;\t\t\t///< Do show ID of result\n\tbool showDescription;\t///< Do show description of result\n\tbool showSuggestion;\t///< Do show suggestion of result\n\tbool showFilename;\t\t///< Do show filename of result\n\tbool showLinenumber;\t///< Do show linenumber of result\n};\n\n//\n// Assert modes \n//\n\n/** \\brief Type definition of assert modes\n*/\nenum TAssertMode\t{ASSERT_MODE_EMPTY,\t\t///< Do nothing. Ignore even result reporting. The debugger becomes useless with this setting. For maximum performance, undefine \\link SWITCH_ON_3DTI_DEBUGGER \\endlink\n\t\t\t\t\tASSERT_MODE_CONTINUE,\t///< Allow reporting of results, but do nothing with them. Will never terminate program execution\n\t\t\t\t\tASSERT_MODE_ABORT,\t\t///< Abort execution when an ASSERT is evaluated as false. The error will be reported/logged before terminating\n\t\t\t\t\tASSERT_MODE_PARANOID\t///< Abort execution if any error is reported to the debugger, even if it was reported using SET_RESULT rather than ASSERT. The error will be reported/logged before terminating\n\t\t\t\t\t};\n\n\n//\n// Definitions of variables for variable watcher\n//\n\n/** \\brief Definition of variables reported to the variable watcher\n*\t\\details This is just an example, you can add here any variables you may need\n*/\nenum TWatcherVariable\t{WV_ANECHOIC_AZIMUTH_LEFT,\t///< Azimuth of audio source for listener left ear\n\t\t\t\t\t\tWV_ANECHOIC_AZIMUTH_RIGHT,\t///< Azimuth of audio source for listener right ear\n\t\t\t\t\t\tWV_END};\n\n/*********************************************/\n\n/** \\details Debugger class for error reporting and watching variables \n*\t\\details Follows Meyers Singleton design pattern\n*/\nclass CDebugger \n{\npublic:\n// PUBLIC METHODS:\n\n\t/** \\brief Access to singleton instance with lazy initialization\n\t*\t\\details Use CDebugger::Instance().Method to call any debugger method, or use the defined MACROS instead\n\t*\t\\sa SET_RESULT, ASSERT, GET_RESULT, GET_RESULT_STRUCT, GET_FIRST_ERROR_STRUCT, WATCH\n\t*/\n\tstatic CDebugger& Instance()\n\t{\n\t\tstatic CDebugger singletonInstance;\n\t\treturn singletonInstance;\n\t}\n\n//\n// Result reporting\n//\n\n\t/** \\brief Get a struct with the info of the last reported result \n\t*\t\\retval resultStruct info of last reported result\n\t*/\n\tTDebuggerResultStruct GetLastResultStruct();\t\t\n\n\t/** \\brief Get the ID of the last reported result\n\t*\t\\retval result ID of last reported result\n\t*/\n\tTDebuggerResultID GetLastResult();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set result of last operation\n\t*\t\\note Instead of calling this method, using the macros \\link SET_RESULT \\endlink or \\link ASSERT \\endlink is recommended\n\t*\t\\param [in] resultID ID of result\n\t*\t\\param [in] suggestion suggestion or further information about result\n\t*\t\\param [in] filename file from which result is being reported\n\t*\t\\param [in] linenumber line number at which result is being reported (whithin filename file)\n\t*/\n\tvoid SetResult(TDebuggerResultID resultID, string suggestion, string filename, int linenumber);\t\t\t\t\t\n\n#if defined (_3DTI_ANDROID_DEBUGGER)\n\tvoid AndroidSetResult(TDebuggerResultID resultID, string suggestion, string filename, int linenumber)\n\t{\n\t\tstring newdescription;\n\t\tstring newsuggestion;\n\t\tGetDescriptionAndSuggestion(resultID, newdescription, newsuggestion);\n\n\t\tif (suggestion != \"\")\n\t\t\tnewsuggestion = suggestion;\n\n\t\tif (resultID == RESULT_OK)\n\t\t\tLOGV(\"OK: %s in file %s (%d)\", newsuggestion.c_str(), filename.c_str(), linenumber);\n\t\telse\n\t\t{\n\t\t\tif (resultID == RESULT_WARNING)\n\t\t\t\tLOGW(\"WARNING: %s in file %s (%d)\", newsuggestion.c_str(), filename.c_str(), linenumber);\n\t\t\telse\n\t\t\t\tLOGE(\"ERROR (%s): %s in file %s (%d)\", newdescription.c_str(), newsuggestion.c_str(), filename.c_str(), linenumber);\n\t\t}\n\t}\n#endif\n\n//\n// First error (error reporting in blocks of code)\n//\n\n\t/** \\brief Inits the first error report, so that the next error will be stored as the first error\n\t*\t\\details Used to mark the starting point of the code block\n\t*/\n\tvoid ResetErrors();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get a struct with the info of the first reported error in code block\n\t*\t\\retval resultStruct info of first reported error in code block\n\t*/\n\tTDebuggerResultStruct GetFirstErrorStruct();\t\t\t\t\t\t\n\n\t/** \\brief Get the ID of the first reported error in code block\n\t*\t\\retval result ID of first reported error in code block\n\t*/\n\tTDebuggerResultID GetFirstError();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n//\n// Verbosity modes\n//\n\n\t/** \\brief Set verbosity mode from one of the presets\n\t*\t\\sa VERBOSITY_MODE_SILENT, VERBOSITYMODE_ERRORSANDWARNINGS, VERBOSITY_MODE_ONLYERRORS, VERBOSITY_MODE_ALL\n\t*/\n\tvoid SetVerbosityMode(int presetMode);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set custom verbosity mode\n\t*\t\\param [in] _verbosityMode definition of custom verbosity mode\n\t*/\n\tvoid SetVerbosityMode(TDebuggerVerbosityMode _verbosityMode);\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n//\n// Logging to file\n//\n\n\t/** \\brief Enable/disable log of reported results to file, using current verbosity mode \n\t*\t\\param [in] filename name of log file\n\t*\t\\param [in] logOn switch on/off logging to file (default, true)\n\t*/\n\tvoid SetErrorLogFile(string filename, bool logOn=true);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n//\n// Assert modes\n//\n\n\t/** \\brief Set an assert mode \n\t*\t\\details Defines what to do when an error is reported\n\t*\t\\param [in] _assertMode one of the preset assert modes\n\t*\t\\sa ASSERT_MODE_EMPTY, ASSERT_MODE_CONTINUE, ASSERT_MODE_ABORT, ASSERT_MODE_PARANOID\t\n\t*/\n\tvoid SetAssertMode(TAssertMode _assertMode);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Test a condition and report error if false, doing the action specified by the assert mode\n\t*\t\\details Internally used by the \\link ASSERT \\endlink macro. Using the macro instead of this method is recommended\n\t*\t\\param [in] condition condition to evaluate\n\t*\t\\param [in] errorID ID of error to report if condition is evaluated false\n\t*\t\\param [in] suggestionError suggestion for reported result struct if condition is evaluated false (result error)\n\t*\t\\param [in] suggestionOK suggestion for reported result struct if condition is evaluated true (result OK)\n\t*\t\\param [in] filename filename for reported result struct \n\t*\t\\param [in] linenumber linenumber for reported result struct\n\t*/\n\tvoid AssertTest(bool condition, TDebuggerResultID errorID, string suggestionError, string suggestionOK, string filename, int linenumber);\t\n\n#if defined (_3DTI_ANDROID_DEBUGGER)\n\tvoid AndroidAssertTest(bool condition, TDebuggerResultID errorID, string suggestionError, string suggestionOK, string filename, int linenumber)\n\t{\n\t\tif (condition)\n\t\t{\n\t\t\tif (suggestionOK != \"\")\n\t\t\t\tAndroidSetResult(RESULT_OK, suggestionOK, filename, linenumber);\n\t\t}\n\t\telse\n\t\t\tAndroidSetResult(errorID, suggestionError, filename, linenumber);\n\t}\n#endif\n\n//\n// Variable watcher\n//\n\n\t/** \\brief Add a variable to the list of variables to watch\n\t*\t\\param [in] whichVar variable to watch, which has to be added first to the \\link TWatcherVariable \\endlink enum\n\t*/\n\tvoid AddVariableWatch(TWatcherVariable whichVar);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Remove a variable from the list of variables to watch\n\t*\t\\param [in] whichVar which variable to stop watching\n\t*\t\\pre Variable was added to watch first\n\t*/\n\tvoid RemoveVariableWatch(TWatcherVariable whichVar);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Enable/disable log to file of a specific watched variable\n\t*\t\\param [in] whichVar which variable to log to file\n\t*\t\\param [in] filename name of file with the log\n\t*\t\\param [in] logOn switch on/off file logging for this war (default, true)\n\t*\t\\pre Variable was added to watch first\n\t*/\n\tvoid SetWatcherLogFile(TWatcherVariable whichVar, string filename, bool logOn = true);\t\t\t\t\t\t\t\n\n\t/** \\brief Sends the value of a variable to the watcher \n\t*\t\\details The value will be recorded ONLY if the variable is on the list of watched variables. No overhead if the variable is not in the list\n\t*\t\\param [in] whichVar from which variable are we reporting value\n\t*\t\\param [in] varValue the value we are reporting\n\t*/\n\ttemplate <class T>\n\tvoid Watch(TWatcherVariable whichVar, const T& varValue)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\t// Check first if this variable is being watched\n\t\tif (!watcherVariables[whichVar])\n\t\t\treturn;\n\n\t\t// Log to file\n\t\tif (watcherLogFiles[whichVar].is_open())\n\t\t{\n\t\t\twatcherLogFiles[whichVar] << varValue << std::endl;\n\t\t}\n\t}\n\n// HIDDEN METHODS\nprotected:\n\n\t/** \\brief Default constructor\n\t*\t\\details Resets all result and error reporting, sets verbosity mode to \\link VERBOSITY_MODE_ONLYERRORS \\endlink and assert mode to \\link ASSERT_MODE_ABORT \\endlink\n\t*/\n\tCDebugger()\n\t{\n\t\tlastResult.id = RESULT_OK;\n\t\tlastResult.filename = \"Nobody\";\n\t\tlastResult.linenumber = -1;\n\t\tlastResult.suggestion = \"Nothing has been reported to the debugger yet\";\n\n\t\tResetErrors();\n\t\tSetVerbosityMode(VERBOSITY_MODE_ONLYERRORS);\n\t\tSetAssertMode(ASSERT_MODE_ABORT);\n\t\tResetWatcher();\n\t}\n\t\t\n\t/** \\brief Destructor\n\t*\t\\details Closes all open files (error log and watcher)\n\t*/\n\t~CDebugger() \n\t{\n\t\tif (errorLogFile.is_open())\n\t\t\terrorLogFile.close();\n\t\tfor (int i = 0; i < WV_END; i++)\n\t\t{\n\t\t\tif (watcherLogFiles[i].is_open())\n\t\t\t\twatcherLogFiles[i].close();\n\t\t}\n\t}\n\n\t// Generic method for obtaining description and suggestions of a result ID\n\tvoid GetDescriptionAndSuggestion(TDebuggerResultID result, string& description, string& suggestion);\n\n\t// Log to file\n\tvoid LogErrorToFile(TDebuggerResultStruct result);\n\n\t// Reset all watches\n\tvoid ResetWatcher();\n\nprivate:\n// ATTRIBUTES:\n\n\tmutex debugMutex;\n\n\t// Last Result handling\n\tTDebuggerResultStruct lastResult;\t\n\n\t// First error (error reporting in blocks of code)\n\tTDebuggerResultStruct firstError;\t\n\n\t// Verbosity modes\n\t// TO DO: we can think in having different modes for different things: log to file, stream output...\n\tTDebuggerVerbosityMode verbosityMode;\n\n\t// Logging to file\n\tstd::ofstream errorLogFile;\n\n\t// Assert modes\n\tTAssertMode assertMode;\n\n\t// Variable watcher\n\tbool watcherVariables[TWatcherVariable::WV_END];\n\tstd::ofstream watcherLogFiles [TWatcherVariable::WV_END];\n\t//std::ostream watcherStream;\t\n};\n\n#endif\n\n#endif \n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n    void __annotate_contiguous_container\n    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const\n    {\n#ifndef _LIBCPP_HAS_NO_ASAN\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n#endif\n    }\n\n    void __annotate_new(size_type __current_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n    void __annotate_delete() const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __n(__n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__v.size() + __n);\n      }\n      bool __commit;\n      size_type __n;\n      const vector &__v;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}\n      inline void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        __annotator.__done();\n        ++this->__end_;\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _VSTD::distance(__first, __last);\n    if (static_cast<size_type>(__new_size) <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (static_cast<size_type>(__new_size) > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last);\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__new_size)));\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                _VSTD::advance(__m, this->__end_ - __p);\n                __construct_at_end(__m, __last);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __base::__swap_alloc(this->__alloc(), __x.__alloc());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__storage_type>\n#else\n                rebind_alloc<__storage_type>::other\n#endif\n                                                     __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __storage_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_alloc(this->__alloc(), __x.__alloc());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\n\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p + __ip);\n#else\n    return iterator(__p + __ip);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(long);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\nnamespace __libcpp_is_member_function_pointer_imp {\n    template <typename _Tp>\n    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);\n\n    template <typename>\n    std::__two __test(...);\n};\n    \ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_final\n\n#if _LIBCPP_STD_VER > 11 && __has_feature(is_final)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY \nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote\n{\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n    static const bool __does_not_throw = _NOEXCEPT_OR_FALSE(static_cast<type>(declval<_A1>()));\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\n//\tif it's a reference, return true\n//\tif it's a function, return false\n//\tif it's   void,     return false\n//\tif it's an array of unknown bound, return false\n//\tOtherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n\ttemplate <typename _Tp1>\n\tstatic char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n\ttemplate <typename _Tp1>\n\tstatic __two __test (...);\n\t\n\tstatic const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___MUTEX_BASE\n#define _LIBCPP___MUTEX_BASE\n\n#include <__config>\n#include <chrono>\n#include <system_error>\n#include <pthread.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_THREADS\n\nclass _LIBCPP_TYPE_VIS mutex\n{\n    pthread_mutex_t __m_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_CONSTEXPR\n     constexpr mutex() _NOEXCEPT : __m_(PTHREAD_MUTEX_INITIALIZER) {}\n#else\n     mutex() _NOEXCEPT {__m_ = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;}\n#endif\n     ~mutex();\n\nprivate:\n    mutex(const mutex&);// = delete;\n    mutex& operator=(const mutex&);// = delete;\n\npublic:\n    void lock();\n    bool try_lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\n    typedef pthread_mutex_t* native_handle_type;\n    _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {return &__m_;}\n};\n\nstruct _LIBCPP_TYPE_VIS defer_lock_t {};\nstruct _LIBCPP_TYPE_VIS try_to_lock_t {};\nstruct _LIBCPP_TYPE_VIS adopt_lock_t {};\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MUTEX)\n\nextern const defer_lock_t  defer_lock;\nextern const try_to_lock_t try_to_lock;\nextern const adopt_lock_t  adopt_lock;\n\n#else\n\nconstexpr defer_lock_t  defer_lock  = defer_lock_t();\nconstexpr try_to_lock_t try_to_lock = try_to_lock_t();\nconstexpr adopt_lock_t  adopt_lock  = adopt_lock_t();\n\n#endif\n\ntemplate <class _Mutex>\nclass _LIBCPP_TYPE_VIS_ONLY lock_guard\n{\npublic:\n    typedef _Mutex mutex_type;\n\nprivate:\n    mutex_type& __m_;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit lock_guard(mutex_type& __m)\n        : __m_(__m) {__m_.lock();}\n    _LIBCPP_INLINE_VISIBILITY\n    lock_guard(mutex_type& __m, adopt_lock_t)\n        : __m_(__m) {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~lock_guard() {__m_.unlock();}\n\nprivate:\n    lock_guard(lock_guard const&);// = delete;\n    lock_guard& operator=(lock_guard const&);// = delete;\n};\n\ntemplate <class _Mutex>\nclass _LIBCPP_TYPE_VIS_ONLY unique_lock\n{\npublic:\n    typedef _Mutex mutex_type;\n\nprivate:\n    mutex_type* __m_;\n    bool __owns_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock() _NOEXCEPT : __m_(nullptr), __owns_(false) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unique_lock(mutex_type& __m)\n        : __m_(&__m), __owns_(true) {__m_->lock();}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(mutex_type& __m, defer_lock_t) _NOEXCEPT\n        : __m_(&__m), __owns_(false) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(mutex_type& __m, try_to_lock_t)\n        : __m_(&__m), __owns_(__m.try_lock()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(mutex_type& __m, adopt_lock_t)\n        : __m_(&__m), __owns_(true) {}\n    template <class _Clock, class _Duration>\n    _LIBCPP_INLINE_VISIBILITY\n        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)\n            : __m_(&__m), __owns_(__m.try_lock_until(__t)) {}\n    template <class _Rep, class _Period>\n    _LIBCPP_INLINE_VISIBILITY\n        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)\n            : __m_(&__m), __owns_(__m.try_lock_for(__d)) {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~unique_lock()\n    {\n        if (__owns_)\n            __m_->unlock();\n    }\n\nprivate:\n    unique_lock(unique_lock const&); // = delete;\n    unique_lock& operator=(unique_lock const&); // = delete;\n\npublic:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(unique_lock&& __u) _NOEXCEPT\n        : __m_(__u.__m_), __owns_(__u.__owns_)\n        {__u.__m_ = nullptr; __u.__owns_ = false;}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock& operator=(unique_lock&& __u) _NOEXCEPT\n        {\n            if (__owns_)\n                __m_->unlock();\n            __m_ = __u.__m_;\n            __owns_ = __u.__owns_;\n            __u.__m_ = nullptr;\n            __u.__owns_ = false;\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void lock();\n    bool try_lock();\n\n    template <class _Rep, class _Period>\n        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);\n    template <class _Clock, class _Duration>\n        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);\n\n    void unlock();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unique_lock& __u) _NOEXCEPT\n    {\n        _VSTD::swap(__m_, __u.__m_);\n        _VSTD::swap(__owns_, __u.__owns_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    mutex_type* release() _NOEXCEPT\n    {\n        mutex_type* __m = __m_;\n        __m_ = nullptr;\n        __owns_ = false;\n        return __m;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool owns_lock() const _NOEXCEPT {return __owns_;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT\n        operator bool () const _NOEXCEPT {return __owns_;}\n    _LIBCPP_INLINE_VISIBILITY\n    mutex_type* mutex() const _NOEXCEPT {return __m_;}\n};\n\ntemplate <class _Mutex>\nvoid\nunique_lock<_Mutex>::lock()\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::lock: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::lock: already locked\");\n    __m_->lock();\n    __owns_ = true;\n}\n\ntemplate <class _Mutex>\nbool\nunique_lock<_Mutex>::try_lock()\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::try_lock: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::try_lock: already locked\");\n    __owns_ = __m_->try_lock();\n    return __owns_;\n}\n\ntemplate <class _Mutex>\ntemplate <class _Rep, class _Period>\nbool\nunique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::try_lock_for: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::try_lock_for: already locked\");\n    __owns_ = __m_->try_lock_for(__d);\n    return __owns_;\n}\n\ntemplate <class _Mutex>\ntemplate <class _Clock, class _Duration>\nbool\nunique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::try_lock_until: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::try_lock_until: already locked\");\n    __owns_ = __m_->try_lock_until(__t);\n    return __owns_;\n}\n\ntemplate <class _Mutex>\nvoid\nunique_lock<_Mutex>::unlock()\n{\n    if (!__owns_)\n        __throw_system_error(EPERM, \"unique_lock::unlock: not locked\");\n    __m_->unlock();\n    __owns_ = false;\n}\n\ntemplate <class _Mutex>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) _NOEXCEPT\n    {__x.swap(__y);}\n\n//enum class cv_status\n_LIBCPP_DECLARE_STRONG_ENUM(cv_status)\n{\n    no_timeout,\n    timeout\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(cv_status)\n\nclass _LIBCPP_TYPE_VIS condition_variable\n{\n    pthread_cond_t __cv_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_CONSTEXPR\n    constexpr condition_variable() : __cv_(PTHREAD_COND_INITIALIZER) {}\n#else\n    condition_variable() {__cv_ = (pthread_cond_t)PTHREAD_COND_INITIALIZER;}\n#endif\n    ~condition_variable();\n\nprivate:\n    condition_variable(const condition_variable&); // = delete;\n    condition_variable& operator=(const condition_variable&); // = delete;\n\npublic:\n    void notify_one() _NOEXCEPT;\n    void notify_all() _NOEXCEPT;\n\n    void wait(unique_lock<mutex>& __lk) _NOEXCEPT;\n    template <class _Predicate>\n        void wait(unique_lock<mutex>& __lk, _Predicate __pred);\n\n    template <class _Clock, class _Duration>\n        cv_status\n        wait_until(unique_lock<mutex>& __lk,\n                   const chrono::time_point<_Clock, _Duration>& __t);\n\n    template <class _Clock, class _Duration, class _Predicate>\n        bool\n        wait_until(unique_lock<mutex>& __lk,\n                   const chrono::time_point<_Clock, _Duration>& __t,\n                   _Predicate __pred);\n\n    template <class _Rep, class _Period>\n        cv_status\n        wait_for(unique_lock<mutex>& __lk,\n                 const chrono::duration<_Rep, _Period>& __d);\n\n    template <class _Rep, class _Period, class _Predicate>\n        bool\n        wait_for(unique_lock<mutex>& __lk,\n                 const chrono::duration<_Rep, _Period>& __d,\n                 _Predicate __pred);\n\n    typedef pthread_cond_t* native_handle_type;\n    _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {return &__cv_;}\n\nprivate:\n    void __do_timed_wait(unique_lock<mutex>& __lk,\n       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) _NOEXCEPT;\n};\n#endif // !_LIBCPP_HAS_NO_THREADS\n\ntemplate <class _To, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    chrono::__is_duration<_To>::value,\n    _To\n>::type\n__ceil(chrono::duration<_Rep, _Period> __d)\n{\n    using namespace chrono;\n    _To __r = duration_cast<_To>(__d);\n    if (__r < __d)\n        ++__r;\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_THREADS\ntemplate <class _Predicate>\nvoid\ncondition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)\n{\n    while (!__pred())\n        wait(__lk);\n}\n\ntemplate <class _Clock, class _Duration>\ncv_status\ncondition_variable::wait_until(unique_lock<mutex>& __lk,\n                               const chrono::time_point<_Clock, _Duration>& __t)\n{\n    using namespace chrono;\n    wait_for(__lk, __t - _Clock::now());\n    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;\n}\n\ntemplate <class _Clock, class _Duration, class _Predicate>\nbool\ncondition_variable::wait_until(unique_lock<mutex>& __lk,\n                   const chrono::time_point<_Clock, _Duration>& __t,\n                   _Predicate __pred)\n{\n    while (!__pred())\n    {\n        if (wait_until(__lk, __t) == cv_status::timeout)\n            return __pred();\n    }\n    return true;\n}\n\ntemplate <class _Rep, class _Period>\ncv_status\ncondition_variable::wait_for(unique_lock<mutex>& __lk,\n                             const chrono::duration<_Rep, _Period>& __d)\n{\n    using namespace chrono;\n    if (__d <= __d.zero())\n        return cv_status::timeout;\n    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;\n    typedef time_point<system_clock, nanoseconds> __sys_tpi;\n    __sys_tpf _Max = __sys_tpi::max();\n    system_clock::time_point __s_now = system_clock::now();\n    steady_clock::time_point __c_now = steady_clock::now();\n    if (_Max - __d > __s_now)\n        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));\n    else\n        __do_timed_wait(__lk, __sys_tpi::max());\n    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :\n                                                 cv_status::timeout;\n}\n\ntemplate <class _Rep, class _Period, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\ncondition_variable::wait_for(unique_lock<mutex>& __lk,\n                             const chrono::duration<_Rep, _Period>& __d,\n                             _Predicate __pred)\n{\n    return wait_until(__lk, chrono::steady_clock::now() + __d,\n                      _VSTD::move(__pred));\n}\n\n#endif // !_LIBCPP_HAS_NO_THREADS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___MUTEX_BASE\n","// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    FILE* __file_;\n    const codecvt<char_type, char, state_type>* __cv_;\n    state_type __st_;\n    state_type __st_last_;\n    ios_base::openmode __om_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    bool __read_mode();\n    void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const char* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = \"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = \"a\";\n            break;\n        case ios_base::in:\n            __mdstr = \"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = \"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = \"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = \"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = \"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = \"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = \"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = \"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = fopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if _WIN32\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if _WIN32\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if _WIN32\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ifstream(basic_ifstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    void swap(basic_ifstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ofstream(basic_ofstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    void swap(basic_ofstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_fstream(basic_fstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    void swap(basic_fstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FSTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;\n    typedef typename traits::pos_type pos_type;\n    typedef typename traits::off_type off_type;\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_TYPE_VIS failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    typedef iostate      io_state;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    typedef openmode     open_mode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n    typedef seekdir seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS_ONLY char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS_ONLY allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS_ONLY fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef long long streamoff;        // for char_traits in <string>\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    for (; __i < __n; ++__s, ++__i)\n    {\n        if (__nout_ < __eout_)\n            *__nout_++ = *__s;\n        else if (overflow(traits_type::to_int_type(*__s)) == __eof)\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__sun__)   || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#ifdef __GLIBC__\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__) || defined(__ANDROID__)\n#ifdef __APPLE__\n    typedef __uint32_t mask;\n#elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n#elif defined(__EMSCRIPTEN__) ||  defined(__NetBSD__)\n    typedef unsigned short mask;\n#elif defined(__ANDROID__)\n    typedef unsigned char mask;\n#endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n# if defined(__ANDROID__)\n    static const mask xdigit = _CTYPE_X | _CTYPE_D;\n# else\n    static const mask xdigit = _CTYPE_X;\n# endif\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#else  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__ || __EMSCRIPTEN__ || __sun__\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS_ONLY codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class charT> class _LIBCPP_TYPE_VIS_ONLY numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __min_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *__min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __max_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *__max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result ( *__first, *__first );\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(__prev, *__first)) {\n            if (__comp(__prev, __result.first))    __result.first  = __prev;\n            if (__comp(__result.second, *__first)) __result.second = *__first;\n            }\n        else {\n            if (__comp(*__first, __result.first)) __result.first  = *__first;\n            if (__comp(__result.second, __prev))  __result.second = __prev;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#elif defined(_NEWLIB_VERSION)\n// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an\n// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html\n// has had a chance to bake for a bit\n#include <support/newlib/xlocale.h>\n#elif !defined(__ANDROID__)\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n#ifndef _LIBCPP_LOCALE__L_EXTENSIONS\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;\n#endif\n\n// OSX has nice foo_l() functions that let you turn off use of the global\n// locale.  Linux, not so much.  The following functions avoid the locale when\n// that's possible and otherwise do the wrong thing.  FIXME.\n#if defined(__linux__) || defined(__EMSCRIPTEN__) || defined(_AIX) || \\\n    defined(_NEWLIB_VERSION)\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\ndecltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))\ninline _LIBCPP_INLINE_VISIBILITY\n__mb_cur_max_l(locale_t __l)\n{\n  return MB_CUR_MAX_L(__l);\n}\n#else  // _LIBCPP_LOCALE__L_EXTENSIONS\ninline _LIBCPP_ALWAYS_INLINE\ndecltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)\n{\n  __locale_raii __current(uselocale(__l), uselocale);\n  return MB_CUR_MAX;\n}\n#endif // _LIBCPP_LOCALE__L_EXTENSIONS\n\ninline _LIBCPP_ALWAYS_INLINE\nwint_t __btowc_l(int __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return btowc_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return btowc(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __wctob_l(wint_t __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wctob_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wctob(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcrtomb_l(__s, __wc, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcrtomb(__s, __wc, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,\n                   mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrtowc_l(__pwc, __s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrtowc(__pwc, __s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbtowc_l(__pwc, __pmb, __max, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbtowc(__pwc, __pmb, __max);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrlen_l(__s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrlen(__s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nlconv *__localeconv_l(locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return localeconv_l(__l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return localeconv();\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,\n                     mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsrtowcs(__dest, __src, __len, __ps);\n#endif\n}\n\ninline\nint __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsnprintf_l(__s, __n, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsnprintf(__s, __n, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vasprintf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vasprintf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsscanf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsscanf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\n#endif  // __linux__\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return static_cast<_Tp>(__ld);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    if (sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n#else\n    if (__sscanf_l(__buf.c_str(), __cloc(), \"%p\", &__v) != 1)\n#endif\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n#else\n        __n = __asprintf_l(&__bb, __cloc(), \"%.0Lf\", __units);\n#endif\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#if defined(_WIN32) || defined(__ANDROID__) || defined(_NEWLIB_VERSION)\n    return -1;\n#else // _WIN32 || __ANDROID__\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#endif // _WIN32 || __ANDROID__\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#if defined(_WIN32) || defined(__ANDROID__) || defined(_NEWLIB_VERSION)\n    return __dflt;\n#else // _WIN32\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#if !defined(_WIN32) && !defined(__ANDROID__) && !defined(_NEWLIB_VERSION)\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // !_WIN32\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TYPE_VIS_ONLY wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__wide_err_string_.empty())\n        throw range_error(\"wstring_convert: from_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__byte_err_string_.empty())\n        throw range_error(\"wstring_convert: to_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TYPE_VIS_ONLY wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    switch (__way)\n    {\n    case ios_base::beg:\n        break;\n    case ios_base::cur:\n        break;\n    case ios_base::end:\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","/**\n* \\class CHRTF\n*\n* \\brief Declaration of CHRTF class interface\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n\n#ifndef _CHRTF_H_\n#define _CHRTF_H_\n\n#include <unordered_map>\n#include <vector>\n#include <utility>\n#include <list>\n#include <cstdint>\n#include <Common/Buffer.h>\n#include <Common/Debugger.h>\n#include <Common/Fconvolver.h>\n\n//#include \"Core.h\"\n\n#ifndef PI \n#define PI 3.14159265\n#endif\n\n/*! \\file */\n\n// Structs and types definitions \n\n/** \\brief Defines and holds data to work with orientations\n*/\nstruct orientation\n{\n\tint32_t azimuth;\t///< Azimuth angle in degrees\n\tint32_t elevation;\t///< Elevation angle in degrees\n    orientation(int32_t _azimuth, int32_t _elevation):azimuth{_azimuth}, elevation{_elevation}{}\n    orientation():orientation{0,0}{}\n    bool operator==(const orientation& oth) const\n    {\n        return ((this->azimuth == oth.azimuth) && (this->elevation == oth.elevation));\n    }\n};\n\n/** \\brief Type definition for a left-right pair of impulse response with custom delay for ITD \n*/\nstruct HRIR_struct {\n\tuint64_t leftDelay;\t\t\t\t///< Left delay, in number of samples\n\tuint64_t rightDelay;\t\t\t///< Right delay, in number of samples\n\tCMonoBuffer<float> leftHRIR;\t///< Left impulse response data\n\tCMonoBuffer<float> rightHRIR;\t///< Right impulse response data\n};\n\n/** \\brief Type definition for an impulse response with custom delay for ITD\n*/\nstruct oneEarHRIR_struct {\n\tuint64_t delay;\t\t\t\t///< Delay, in number of samples\n\tCMonoBuffer<float> HRIR;\t///< Impulse response data\n};\n\n/**\t\\brief Type definition for barycentric coordinates\n*/\nstruct barycentricCoordinates_struct {\n\tfloat alpha;\t///< Coordinate alpha\n\tfloat beta;\t\t///< Coordinate beta\n\tfloat gamma;\t///< Coordinate gamma\n};\n\n/** \\brief Type definition for specifying one ear\n*/\nenum T_ear {LEFT,\t///< Left ear\n\t\t\tRIGHT\t///< Right ear\n\t\t\t};\n\nnamespace std\n{\n\t//[TBC]\n    template<>\n    struct hash<orientation>\n    {\n        // adapted from http://en.cppreference.com/w/cpp/utility/hash\n        size_t operator()(const orientation & key) const\n        {\n            size_t h1 = std::hash<int32_t>()(key.azimuth);\n            size_t h2 = std::hash<int32_t>()(key.elevation);\n            return h1 ^ (h2 << 1);  // exclusive or of hash functions for each int.\n        }\n    };\n}\n\n/** \\brief Type definition for the impulse response of both ears, without delay\n*/\ntypedef std::pair<CMonoBuffer<float>,CMonoBuffer<float>> HRIRbothEars_type;\n\n/** \\brief Type definition for the delay of both ears\n*/\ntypedef std::pair<unsigned long, unsigned long> DelayBothEars_type;\n\n/** \\brief Type definition for the HRTF table\n*/\ntypedef std::unordered_map<orientation, HRIR_struct> HRTFTable_type;\n\n/** \\brief Type definition for a distance-orientation pair\n*/\ntypedef std::pair <float, orientation> Pair_DistanceOrientation_type;\n\nclass CCore;\n\n/** \\details This class gets impulse response data to compose HRTFs and implements different algorithms to interpolate the HRIR functions.\n*/\nclass CHRTF\n{\n// METHODS\npublic:\n\n\t/** \\brief Constructor.\n\t*\t\\details By default, customized ITD is switched off\n\t*\t\\param [in] _azimuthStep quantization step at which azimuth is sampled in the original database, in degrees\n\t*\t\\param [in] _elevationStep quantization step at which elevation is sampled in the original database, in degrees\n\t*/\n    CHRTF(int32_t _azimuthStep, int32_t _elevationStep):\n\tazimuthStep{_azimuthStep}, \n\televationStep{_elevationStep}\t\t\n    {\n\t\t//Init \n\t\tenableCustomizedITD = false;\n\t}\n    \n\t/** \\brief Default constructor.\n\t*\t\\details By default, sets quantization steps for azimuth and elevation to 15\n\t*/\n\tCHRTF() : CHRTF{ 15,15 } \n    { }\n\n\t/** \\brief Get azimuth quantization step \n\t*\t\\retval step azimuth quantization step\n\t*/\n\tint32_t GetAzimuthStep() const \n\t{\n\t\treturn azimuthStep;\n\t}\n\n\t/** \\brief Get elevation quantization step\n\t*\t\\retval step elevation quantization step\n\t*/\n\tint32_t GetElevationStep() const \n\t{\n\t\treturn elevationStep;\n\t}\n\n\t/** \\brief Get size of each HRIR buffer\n\t*\t\\retval size number of samples of each HRIR buffer for one ear\n\t*/\n\tint32_t GetHRIRLength() const\n\t{\n\t\treturn HRIRlength;\n\t}\n\t\t\n\t/** \\brief Start a new HRTF configuration\n\t*\t\\param [in] _HRIRlength buffer size of the HRIR to be added\n\t*\t\\param [in] _bufferSize buffer size of the input signal that is going to be used in the audio loop\n\t*\t\\note This method is implemented in CoreState class\n\t*\t\\sa CoreState\n\t*/\n\tvoid BeginSetup(int32_t _HRIRlength, int32_t _bufferSize, int32_t _sampleRate);\n\n\t/** \\brief Set the full HRIR matrix. \n\t*\t\\param [in] newTable full table with all HRIR data\n\t*/\n\tvoid AddHRTFTable(HRTFTable_type && newTable);\t\t\t\t\t\t\t\n\n\t/** \\brief Add a new HRIR to the HRTF table\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] newHRIR HRIR data for both ears\n\t*   \\throws May throw warnings to debugger\n\t*/\n\tvoid AddHRIR(float azimuth, float elevation, HRIR_struct && newHRIR);\t\n\n\t/** \\brief Stop the HRTF configuration\t\n\t*\t\\retval success Setup has ended\n\t*   \\throws May throw errors to debugger\n\t*/\n\tbool EndSetup();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t/** \\brief Get HRIR buffer with Delay from database, for left ear\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] interpolate interpolation method (0: no interpolation; 1: Only pre-interpolation; 2: Only runtime-interpolation; 3: Both pre- and runtime-interpolation)\n\t*\t\\retval HRIR buffer with delay from database for left ear\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst CMonoBuffer<float> GetHRIR_fromDataBaseTableLEFT(float azimuth, float elevation, int interpolate) const;  \n\n\t/** \\brief Get HRIR buffer with Delay from database, for right ear\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] interpolate interpolation method (0: no interpolation; 1: Only pre-interpolation; 2: Only runtime-interpolation; 3: Both pre- and runtime-interpolation)\n\t*\t\\retval HRIR buffer with delay from database for right ear\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst CMonoBuffer<float> GetHRIR_fromDataBaseTableRIGHT(float azimuth, float elevation, int interpolate) const; \n\n\t\t\n\t/** \\brief Set listener head radius \n\t*\t\\param [in] _listenerHeadRadius listener head radius, in meters\n\t*/\n\tvoid SetListenerHeadRadius(float _listenerHeadRadius);\t\n\n\t/** \\brief Switch on/off ITD customization\n\t*\t\\param [in] _enableCustomizeITD switch on/off ITD customization\n\t*/\n\tvoid SetHRTFCustomizedITD(bool _enableCustomizeITD);\n\n\t/** \\brief Get raw HRTF table\n\t*\t\\retval table raw HRTF table\n\t*/\n\tconst HRTFTable_type & GetRawHRTFTable() const;  \n    \n\t/** \\brief Get HRIR buffer with Delay, for both ears\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] runTimeInterpolation interpolation method (false: no run-time interpolation; true: runtime-interpolation)\n\t*\t\\retval HRIR interpolated HRIR with delay for both ears\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst HRIRbothEars_type GetHRIR(float azimuth, float elevation, bool runTimeInterpolation) const;\n\n\t/** \\brief Get interpolated HRIR buffer with Delay, for left ear\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] runTimeInterpolation interpolation method (false: no run-time interpolation; true: runtime-interpolation)\n\t*\t\\retval HRIR interpolated buffer with delay for left ear\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst CMonoBuffer<float> GetHRIR_left(float azimuth, float elevation, bool runTimeInterpolation) const;\n\n\t/** \\brief Get interpolated HRIR buffer with Delay, for right ear\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] runTimeInterpolation interpolation method (false: no run-time interpolation; true: runtime-interpolation)\n\t*\t\\retval HRIR interpolated buffer with delay for right ear\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst CMonoBuffer<float> GetHRIR_right(float azimuth, float elevation, bool runTimeInterpolation) const;\n\n\t/** \\brief Get interpolated HRIR buffer with Delay, for left ear\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] interpolate interpolation method (0: no interpolation; 1: Only pre-interpolation; 2: Only runtime-interpolation; 3: Both pre- and runtime-interpolation)\n\t*\t\\retval HRIR interpolated buffer with delay for left ear\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst oneEarHRIR_struct GetHRIR_left_frequency(float azimuth, float elevation, bool interpolate) const;\n\n\t/** \\brief Get interpolated HRIR buffer with Delay, for right ear\n\t*\t\\param [in] azimuth azimuth angle in degrees\n\t*\t\\param [in] elevation elevation angle in degrees\n\t*\t\\param [in] interpolate interpolation method (0: no interpolation; 1: Only pre-interpolation; 2: Only runtime-interpolation; 3: Both pre- and runtime-interpolation)\n\t*\t\\retval HRIR interpolated buffer with delay for right ear\n\t*   \\throws May throw errors to debugger\n\t*/\n\tconst oneEarHRIR_struct GetHRIR_right_frequency(float azimuth, float elevation, bool interpolate) const;\n\nprivate:\t\n\t\n\tint32_t HRIRlength;\t\t\t\t\t// HRIR vector length\n\tint32_t bufferSize;\t\t\t\t\t// Input signal buffer size\n\tint32_t sampleRate;\t\t\t\t\t// Sample Rate\n\tHRIR_struct leftHRIR;\t\t\t\t// HRIR data of the user left ear\n\tHRIR_struct rightHRIR;\t\t\t\t// HRIR data of the user right ear\n\n\tbool setupInProgress;\t// Variable that indicates the HRTF add and resample algorithm are in process\n\tint32_t azimuthStep;\t\t// HRTF table Database azimuth step\n\tint32_t elevationStep;\t\t// HRTF table Database elevation step\n\t\nprivate: \n\tfloat listenerHeadRadius;\t//Radius of the listener head, coming from the Core\n\t\t\t\t\t\t\t\t\t\n\tHRTFTable_type t_HRTF_DataBase, t_HRTF_ResampleInterpolationMethod;\t// HRTF tables\n\tHRTFTable_type t_HRTF_ResampleInterpolationMethod_frequency;\t\t\t\t\t\t\t\t\t\t// HRTF tables\n\n\t// Empty object to return in some methods\n\tHRIR_struct emptyHRIR;\n\tCMonoBuffer<float> emptyMonoBuffer; //std::vector<T> have constructors initializing the object to be empty\n\toneEarHRIR_struct emptyOneEarHRTF;\n\tHRIRbothEars_type emptyHRIRbothEars;\n\n\t//FIX ME! Findf a better method to select the interpolation\n\tbool bInterpolatedResampleTable;\t// If true: calculate the HRTF resample matrix with interpolation\n\t//FIX ME! Find a better place to this\n\tint resampleStep = 5;\t\t\t// HRTF Resample table step (azimuth and elevation)\n\tbool enableCustomizedITD;\t\t// Indicate the use of a customized delay\n\n\t//Private methods\n\t/* Methods to use in the resample algortihms*/\n\tvoid FillOut_HRTFDatabaseTableInPoles();\n\tvoid Resample_HRTFTable_InterpolationMethod(int resampleStep);\n\tHRIR_struct CalculateHRIR_InterpolationMethod(int newAzimuth, int newElevation);\n\tfloat HaversineFormula(float azimuth1, float elevation1, float azimuth2, float elevation2);\n\tconst barycentricCoordinates_struct GetBarycentricCoordinates(int newAzimuth, int newElevation, float x1, float y1, float x2, float y2, float x3, float y3) const;\n\tfloat TransformAzimuth(float azimuthOrientationOfInterest, float originalAzimuth);\n\tfloat TransformElevation(float elevationOrientationOfInterest, float originalElevation);\n\tstd::list<Pair_DistanceOrientation_type> GetSortedDistancesList(int newAzimuth, int newElevation);\n\t\n\t/* Methods to use in the get HRIR run-time algortihms*/\n\tconst oneEarHRIR_struct CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(T_ear ear, int azimuth, int elevation) const;\n\tconst oneEarHRIR_struct CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(T_ear ear, int azimuth, int elevation, bool freq) const;\n\tconst oneEarHRIR_struct CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(T_ear ear, barycentricCoordinates_struct barycentricCoordinates, orientation orientation_pto1, orientation orientation_pto2, orientation orientation_pto3) const;\n\tconst oneEarHRIR_struct CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(T_ear ear, barycentricCoordinates_struct barycentricCoordinates, orientation orientation_pto1, orientation orientation_pto2, orientation orientation_pto3, bool freq) const;\t\n\tconst CMonoBuffer<float> AddDelayToHRIR(T_ear ear, oneEarHRIR_struct HRIR, float _azimuth, float _elevation)const;\n\tvoid DeleteCommonDelay_HRTFDataBaseTable();\n\tconst  float CalculateITDFromHeadRadius(float _headRadius, float _interauralAzimuth)const;\n\tconst unsigned long GetCustomizedDelay(float _azimuth, float _elevation, T_ear ear)const;\n};\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- unordered_map -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_MAP\n#define _LIBCPP_UNORDERED_MAP\n\n/*\n\n    unordered_map synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_map\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_map()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_map(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_map(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_map(const allocator_type&);\n    unordered_map(const unordered_map&);\n    unordered_map(const unordered_map&, const Allocator&);\n    unordered_map(unordered_map&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_map(unordered_map&&, const Allocator&);\n    unordered_map(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_map(size_type n, const allocator_type& a)\n      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_map(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_map();\n    unordered_map& operator=(const unordered_map&);\n    unordered_map& operator=(unordered_map&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_map& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    template <class P>\n        pair<iterator, bool> insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_map&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n    mapped_type&       at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,\n              unordered_map<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_multimap\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_multimap()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multimap(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multimap(const allocator_type&);\n    unordered_multimap(const unordered_multimap&);\n    unordered_multimap(const unordered_multimap&, const Allocator&);\n    unordered_multimap(unordered_multimap&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multimap(unordered_multimap&&, const Allocator&);\n    unordered_multimap(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multimap(size_type n, const allocator_type& a)\n      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_multimap();\n    unordered_multimap& operator=(const unordered_multimap&);\n    unordered_multimap& operator=(unordered_multimap&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multimap& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    template <class P>\n        iterator insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_multimap&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <functional>\n#include <stdexcept>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Cp, class _Hash, bool = is_empty<_Hash>::value\n#if __has_feature(is_final)\n                                         && !__is_final(_Hash)\n#endif\n         >\nclass __unordered_map_hasher\n    : private _Hash\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : _Hash() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : _Hash(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return static_cast<const _Hash&>(*this)(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return static_cast<const _Hash&>(*this)(__x);}\n};\n\ntemplate <class _Key, class _Cp, class _Hash>\nclass __unordered_map_hasher<_Key, _Cp, _Hash, false>\n{\n    _Hash __hash_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : __hash_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : __hash_(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return __hash_;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return __hash_(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return __hash_(__x);}\n};\n\ntemplate <class _Key, class _Cp, class _Pred, bool = is_empty<_Pred>::value\n#if __has_feature(is_final)\n                                         && !__is_final(_Pred)\n#endif\n         >\nclass __unordered_map_equal\n    : private _Pred\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : _Pred() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : _Pred(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x, __y.__cc.first);}\n};\n\ntemplate <class _Key, class _Cp, class _Pred>\nclass __unordered_map_equal<_Key, _Cp, _Pred, false>\n{\n    _Pred __pred_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : __pred_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : __pred_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return __pred_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return __pred_(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return __pred_(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return __pred_(__x, __y.__cc.first);}\n};\n\ntemplate <class _Alloc>\nclass __hash_map_node_destructor\n{\n    typedef _Alloc                              allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)\n        _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            const_cast<bool&>(__x.__value_constructed) = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(const __hash_value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(__hash_value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(const __hash_value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(__hash_value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator\n{\n    _HashIterator __i_;\n\n    typedef pointer_traits<typename _HashIterator::pointer>      __pointer_traits;\n    typedef const typename _HashIterator::value_type::value_type::first_type key_type;\n    typedef typename _HashIterator::value_type::value_type::second_type      mapped_type;\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef pair<key_type, mapped_type>                          value_type;\n    typedef typename _HashIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator operator++(int)\n    {\n        __hash_map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\n};\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator\n{\n    _HashIterator __i_;\n\n    typedef pointer_traits<typename _HashIterator::pointer>      __pointer_traits;\n    typedef const typename _HashIterator::value_type::value_type::first_type key_type;\n    typedef typename _HashIterator::value_type::value_type::second_type      mapped_type;\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef pair<key_type, mapped_type>                          value_type;\n    typedef typename _HashIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(\n            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)\n                 _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator operator++(int)\n    {\n        __hash_map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY unordered_map\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::__node_pointer               __node_pointer;\n    typedef typename __table::__node_const_pointer         __node_const_pointer;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n    unordered_map(size_type __n, const hasher& __hf,\n                  const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    explicit unordered_map(const allocator_type& __a);\n    unordered_map(const unordered_map& __u);\n    unordered_map(const unordered_map& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_map(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_map(unordered_map&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_map(initializer_list<value_type> __il);\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const allocator_type& __a)\n      : unordered_map(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_map(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_map(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_map() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(const unordered_map& __u)\n    {\n#if __cplusplus >= 201103L\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_map& operator=(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_map& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args>\n        pair<iterator, bool> emplace(_Args&&... __args);\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::emplace_hint(const_iterator, args...) called with an iterator not\"\n                \" referring to this unordered_map\");\n            return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n        }\n#else\n        iterator emplace_hint(const_iterator, _Args&&... __args)\n            {return emplace(_VSTD::forward<_Args>(__args)...).first;}\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __x)\n            {return __table_.__insert_unique(_VSTD::forward<_Pp>(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    iterator insert(const_iterator __p, const value_type& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n                \" referring to this unordered_map\");\n            return insert(__x).first;\n        }\n#else\n    iterator insert(const_iterator, const value_type& __x)\n        {return insert(__x).first;}\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator insert(const_iterator __p, _Pp&& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_map\");\n            return insert(_VSTD::forward<_Pp>(__x)).first;\n        }\n#else\n        iterator insert(const_iterator, _Pp&& __x)\n            {return insert(_VSTD::forward<_Pp>(__x)).first;}\n#endif\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        void insert(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_map& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n    mapped_type&       at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node_with_key(const key_type& __k);\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n            __table_.__insert_unique(\n                _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_)\n                                    );\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node()\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0,\n                                                                 _A1&& __a1,\n                                                                 _Args&&... __args)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class... _Args>\npair<typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator, bool>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                       _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(__k);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)\n{\n    iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nconst _Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const\n{\n    const_iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(__i->first);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY unordered_multimap\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multimap(size_type __n, const hasher& __hf,\n                                const key_equal& __eql,\n                                const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    explicit unordered_multimap(const allocator_type& __a);\n    unordered_multimap(const unordered_multimap& __u);\n    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_multimap(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multimap(initializer_list<value_type> __il);\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const allocator_type& __a)\n      : unordered_multimap(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multimap(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_multimap() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(const unordered_multimap& __u)\n    {\n#if __cplusplus >= 201103L\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_multimap& operator=(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multimap& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args>\n        iterator emplace(_Args&&... __args);\n\n    template <class... _Args>\n        iterator emplace_hint(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __x)\n            {return __table_.__insert_multi(_VSTD::forward<_Pp>(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p.__i_, __x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __p, _Pp&& __x)\n            {return __table_.__insert_multi(__p.__i_, _VSTD::forward<_Pp>(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        void insert(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multimap& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __table_.__insert_multi(\n                _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_)\n                                   );\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node()\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(\n        _A0&& __a0, _A1&& __a1, _Args&&... __args)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class... _Args>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __table_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class... _Args>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace_hint(\n        const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __table_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                            _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(__i->first);\n        _EqRng __yeq = __y.equal_range(__i->first);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP__HASH_TABLE\n#define _LIBCPP__HASH_TABLE\n\n#include <__config>\n#include <initializer_list>\n#include <memory>\n#include <iterator>\n#include <algorithm>\n#include <cmath>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n_LIBCPP_FUNC_VIS\nsize_t __next_prime(size_t __n);\n\ntemplate <class _NodePtr>\nstruct __hash_node_base\n{\n    typedef __hash_node_base __first_node;\n\n    _NodePtr    __next_;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_node_base() _NOEXCEPT : __next_(nullptr) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __hash_node\n    : public __hash_node_base\n             <\n                 typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__hash_node<_Tp, _VoidPtr> >\n#else\n                     rebind<__hash_node<_Tp, _VoidPtr> >::other\n#endif\n             >\n{\n    typedef _Tp value_type;\n\n    size_t     __hash_;\n    value_type __value_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__is_power2(size_t __bc)\n{\n    return __bc > 2 && !(__bc & (__bc - 1));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__constrain_hash(size_t __h, size_t __bc)\n{\n    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) : __h % __bc;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__next_pow2(size_t __n)\n{\n    return size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;\ntemplate <class _ConstNodePtr> class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n    class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_iterator\n{\n    typedef _NodePtr __node_pointer;\n\n    __node_pointer            __node_;\n\npublic:\n    typedef forward_iterator_tag                         iterator_category;\n    typedef typename pointer_traits<__node_pointer>::element_type::value_type value_type;\n    typedef typename pointer_traits<__node_pointer>::difference_type difference_type;\n    typedef value_type&                                  reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<value_type>\n#else\n                     rebind<value_type>::other\n#endif\n                                                         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __node_(nullptr)\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(const __hash_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator=(const __hash_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container iterator\");\n#endif\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator operator++(int)\n    {\n        __hash_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__node_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__node_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator\n{\n    typedef _ConstNodePtr __node_pointer;\n\n    __node_pointer         __node_;\n\n    typedef typename remove_const<\n        typename pointer_traits<__node_pointer>::element_type\n                                 >::type __node;\n\npublic:\n    typedef forward_iterator_tag                       iterator_category;\n    typedef typename __node::value_type                value_type;\n    typedef typename pointer_traits<__node_pointer>::difference_type difference_type;\n    typedef const value_type&                          reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                       pointer;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node>\n#else\n            rebind<__node>::other\n#endif\n                                                      __non_const_node_pointer;\n    typedef __hash_iterator<__non_const_node_pointer> __non_const_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __node_(nullptr)\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY \n    __hash_const_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__x);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(const __hash_const_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator=(const __hash_const_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_iterator\");\n#endif\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator operator++(int)\n    {\n        __hash_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__node_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__node_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n};\n\ntemplate <class _ConstNodePtr> class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_local_iterator\n{\n    typedef _NodePtr __node_pointer;\n\n    __node_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\npublic:\n    typedef forward_iterator_tag                                iterator_category;\n    typedef typename __pointer_traits::element_type::value_type value_type;\n    typedef typename __pointer_traits::difference_type          difference_type;\n    typedef value_type&                                         reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_local_iterator() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(const __hash_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator=(const __hash_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container local_iterator\");\n#endif\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash_, __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator operator++(int)\n    {\n        __hash_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__node_pointer __node, size_t __bucket,\n                          size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__node_pointer __node, size_t __bucket,\n                          size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator\n{\n    typedef _ConstNodePtr __node_pointer;\n\n    __node_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\n    typedef typename __pointer_traits::element_type __node;\n    typedef typename remove_const<__node>::type     __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                    __non_const_node_pointer;\n    typedef __hash_local_iterator<__non_const_node_pointer>\n                                                    __non_const_iterator;\npublic:\n    typedef forward_iterator_tag                       iterator_category;\n    typedef typename remove_const<\n                        typename __pointer_traits::element_type::value_type\n                     >::type                           value_type;\n    typedef typename __pointer_traits::difference_type difference_type;\n    typedef const value_type&                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_local_iterator() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_),\n          __bucket_(__x.__bucket_),\n          __bucket_count_(__x.__bucket_count_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__x);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __hash_const_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator=(const __hash_const_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_local_iterator\");\n#endif\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash_, __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator operator++(int)\n    {\n        __hash_const_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__node_pointer __node, size_t __bucket,\n                                size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__node_pointer __node, size_t __bucket,\n                                size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\n};\n\ntemplate <class _Alloc>\nclass __bucket_list_deallocator\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::size_type              size_type;\n\n    __compressed_pair<size_type, allocator_type> __data_;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        : __data_(0) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(const allocator_type& __a, size_type __size)\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n        : __data_(__size, __a) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(__bucket_list_deallocator&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n        : __data_(_VSTD::move(__x.__data_))\n    {\n        __x.size() = 0;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __data_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __data_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT {return __data_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __data_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        __alloc_traits::deallocate(__alloc(), __p, size());\n    }\n};\n\ntemplate <class _Alloc> class __hash_map_node_destructor;\n\ntemplate <class _Alloc>\nclass __hash_node_destructor\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __hash_node_destructor& operator=(const __hash_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_node_destructor(allocator_type& __na,\n                                    bool __constructed = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__constructed)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __hash_map_node_destructor;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nclass __hash_table\n{\npublic:\n    typedef _Tp    value_type;\n    typedef _Hash  hasher;\n    typedef _Equal key_equal;\n    typedef _Alloc allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type> __alloc_traits;\npublic:\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\npublic:\n    // Create __node\n    typedef __hash_node<value_type, typename __alloc_traits::void_pointer> __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef __hash_node_base<__node_pointer>         __first_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__first_node>\n#else\n            rebind<__first_node>::other\n#endif\n                                                     __node_base_pointer;\n\nprivate:\n\n    typedef typename __node_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node_pointer>\n#else\n            rebind_alloc<__node_pointer>::other\n#endif\n                                                            __pointer_allocator;\n    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;\n    typedef unique_ptr<__node_pointer[], __bucket_list_deleter> __bucket_list;\n    typedef allocator_traits<__pointer_allocator>          __pointer_alloc_traits;\n    typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;\n\n    // --- Member data begin ---\n    __bucket_list                                     __bucket_list_;\n    __compressed_pair<__first_node, __node_allocator> __p1_;\n    __compressed_pair<size_type, hasher>              __p2_;\n    __compressed_pair<float, key_equal>               __p3_;\n    // --- Member data end ---\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __p2_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __p2_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher& hash_function() _NOEXCEPT {return __p2_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const hasher& hash_function() const _NOEXCEPT {return __p2_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float& max_load_factor() _NOEXCEPT {return __p3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    float  max_load_factor() const _NOEXCEPT {return __p3_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal& key_eq() _NOEXCEPT {return __p3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const key_equal& key_eq() const _NOEXCEPT {return __p3_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_allocator& __node_alloc() _NOEXCEPT {return __p1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __p1_.second();}\n\npublic:\n    typedef __hash_iterator<__node_pointer>                   iterator;\n    typedef __hash_const_iterator<__node_pointer>             const_iterator;\n    typedef __hash_local_iterator<__node_pointer>             local_iterator;\n    typedef __hash_const_local_iterator<__node_pointer>       const_local_iterator;\n\n    __hash_table()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__bucket_list>::value &&\n            is_nothrow_default_constructible<__first_node>::value &&\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value);\n    __hash_table(const hasher& __hf, const key_equal& __eql);\n    __hash_table(const hasher& __hf, const key_equal& __eql,\n                 const allocator_type& __a);\n    explicit __hash_table(const allocator_type& __a);\n    __hash_table(const __hash_table& __u);\n    __hash_table(const __hash_table& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value);\n    __hash_table(__hash_table&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~__hash_table();\n\n    __hash_table& operator=(const __hash_table& __u);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __hash_table& operator=(__hash_table&& __u)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n#endif\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n    {\n        return allocator_traits<__pointer_allocator>::max_size(\n            __bucket_list_.get_deleter().__alloc());\n    }\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_multi(__node_pointer __nd);\n    iterator             __node_insert_multi(const_iterator __p,\n                                             __node_pointer __nd);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        pair<iterator, bool> __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator __emplace_multi(_Args&&... __args);\n    template <class... _Args>\n        iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n    pair<iterator, bool> __insert_unique(const value_type& __x);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n        pair<iterator, bool> __insert_unique(_Pp&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n        iterator __insert_multi(_Pp&& __x);\n    template <class _Pp>\n        iterator __insert_multi(const_iterator __p, _Pp&& __x);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator __insert_multi(const value_type& __x);\n    iterator __insert_multi(const_iterator __p, const value_type& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void clear() _NOEXCEPT;\n    void rehash(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY void reserve(size_type __n)\n        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT\n    {\n        return __bucket_list_.get_deleter().size();\n    }\n\n    iterator       begin() _NOEXCEPT;\n    iterator       end() _NOEXCEPT;\n    const_iterator begin() const _NOEXCEPT;\n    const_iterator end() const _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type bucket(const _Key& __k) const\n        {\n            _LIBCPP_ASSERT(bucket_count() > 0,\n                \"unordered container::bucket(key) called when bucket_count() == 0\");\n            return __constrain_hash(hash_function()(__k), bucket_count());\n        }\n\n    template <class _Key>\n        iterator       find(const _Key& __x);\n    template <class _Key>\n        const_iterator find(const _Key& __x) const;\n\n    typedef __hash_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __first, const_iterator __last);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    void swap(__hash_table& __u)\n        _NOEXCEPT_(\n            (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__pointer_allocator>::value) &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __pointer_alloc_traits::max_size(__bucket_list_.get_deleter().__alloc());}\n    size_type bucket_size(size_type __n) const;\n    _LIBCPP_INLINE_VISIBILITY float load_factor() const _NOEXCEPT\n    {\n        size_type __bc = bucket_count();\n        return __bc != 0 ? (float)size() / __bc : 0.f;\n    }\n    _LIBCPP_INLINE_VISIBILITY void max_load_factor(float __mlf) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__mlf > 0,\n            \"unordered container::max_load_factor(lf) called with lf <= 0\");\n        max_load_factor() = _VSTD::max(__mlf, load_factor());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    begin(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::begin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    end(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::end(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cbegin(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cbegin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cend(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cend(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return const_local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    void __rehash(size_type __n);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    __node_holder __construct_node(value_type&& __v, size_t __hash);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node(const value_type& __v);\n#endif\n    __node_holder __construct_node(const value_type& __v, size_t __hash);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __hash_table& __u)\n        {__copy_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n    void __copy_assign_alloc(const __hash_table& __u, true_type);\n    _LIBCPP_INLINE_VISIBILITY\n        void __copy_assign_alloc(const __hash_table&, false_type) {}\n\n    void __move_assign(__hash_table& __u, false_type);\n    void __move_assign(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            (is_nothrow_move_assignable<__pointer_allocator>::value &&\n             is_nothrow_move_assignable<__node_allocator>::value))\n        {__move_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__pointer_allocator>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n    {\n        __bucket_list_.get_deleter().__alloc() =\n                _VSTD::move(__u.__bucket_list_.get_deleter().__alloc());\n        __node_alloc() = _VSTD::move(__u.__node_alloc());\n    }\n    _LIBCPP_INLINE_VISIBILITY\n        void __move_assign_alloc(__hash_table&, false_type) _NOEXCEPT {}\n\n    template <class _Ap>\n    _LIBCPP_INLINE_VISIBILITY\n    static\n    void\n    __swap_alloc(_Ap& __x, _Ap& __y)\n        _NOEXCEPT_(\n            !allocator_traits<_Ap>::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<_Ap>::value)\n    {\n        __swap_alloc(__x, __y,\n                     integral_constant<bool,\n                        allocator_traits<_Ap>::propagate_on_container_swap::value\n                                      >());\n    }\n\n    template <class _Ap>\n    _LIBCPP_INLINE_VISIBILITY\n    static\n    void\n    __swap_alloc(_Ap& __x, _Ap& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<_Ap>::value)\n    {\n        using _VSTD::swap;\n        swap(__x, __y);\n    }\n\n    template <class _Ap>\n    _LIBCPP_INLINE_VISIBILITY\n    static\n    void\n    __swap_alloc(_Ap&, _Ap&, false_type) _NOEXCEPT {}\n\n    void __deallocate(__node_pointer __np) _NOEXCEPT;\n    __node_pointer __detach() _NOEXCEPT;\n\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()\n    _NOEXCEPT_(\n        is_nothrow_default_constructible<__bucket_list>::value &&\n        is_nothrow_default_constructible<__first_node>::value &&\n        is_nothrow_default_constructible<hasher>::value &&\n        is_nothrow_default_constructible<key_equal>::value)\n    : __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql)\n    : __bucket_list_(nullptr, __bucket_list_deleter()),\n      __p1_(),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)\n    : __bucket_list_(nullptr,\n          __bucket_list_deleter(allocator_traits<__pointer_allocator>::\n              select_on_container_copy_construction(\n                  __u.__bucket_list_.get_deleter().__alloc()), 0)),\n      __p1_(allocator_traits<__node_allocator>::\n          select_on_container_copy_construction(__u.__node_alloc())),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value)\n    : __bucket_list_(_VSTD::move(__u.__bucket_list_)),\n      __p1_(_VSTD::move(__u.__p1_)),\n      __p2_(_VSTD::move(__u.__p2_)),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, _VSTD::move(__u.hash_function())),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (__a == allocator_type(__u.__node_alloc()))\n    {\n        __bucket_list_.reset(__u.__bucket_list_.release());\n        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n        __u.__bucket_list_.get_deleter().size() = 0;\n        if (__u.size() > 0)\n        {\n            __p1_.first().__next_ = __u.__p1_.first().__next_;\n            __u.__p1_.first().__next_ = nullptr;\n            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n                static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n            size() = __u.size();\n            __u.size() = 0;\n        }\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()\n{\n    __deallocate(__p1_.first().__next_);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(\n        const __hash_table& __u, true_type)\n{\n    if (__node_alloc() != __u.__node_alloc())\n    {\n        clear();\n        __bucket_list_.reset();\n        __bucket_list_.get_deleter().size() = 0;\n    }\n    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();\n    __node_alloc() = __u.__node_alloc();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)\n{\n    if (this != &__u)\n    {\n        __copy_assign_alloc(__u);\n        hash_function() = __u.hash_function();\n        key_eq() = __u.key_eq();\n        max_load_factor() = __u.max_load_factor();\n        __assign_multi(__u.begin(), __u.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate(__node_pointer __np)\n    _NOEXCEPT\n{\n    __node_allocator& __na = __node_alloc();\n    while (__np != nullptr)\n    {\n        __node_pointer __next = __np->__next_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__node_ == __np)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __node_traits::destroy(__na, _VSTD::addressof(__np->__value_));\n        __node_traits::deallocate(__na, __np, 1);\n        __np = __next;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    for (size_type __i = 0; __i < __bc; ++__i)\n        __bucket_list_[__i] = nullptr;\n    size() = 0;\n    __node_pointer __cache = __p1_.first().__next_;\n    __p1_.first().__next_ = nullptr;\n    return __cache;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, true_type)\n    _NOEXCEPT_(\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    clear();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n    __u.__bucket_list_.get_deleter().size() = 0;\n    __move_assign_alloc(__u);\n    size() = __u.size();\n    hash_function() = _VSTD::move(__u.hash_function());\n    max_load_factor() = __u.max_load_factor();\n    key_eq() = _VSTD::move(__u.key_eq());\n    __p1_.first().__next_ = __u.__p1_.first().__next_;\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, false_type)\n{\n    if (__node_alloc() == __u.__node_alloc())\n        __move_assign(__u, true_type());\n    else\n    {\n        hash_function() = _VSTD::move(__u.hash_function());\n        key_eq() = _VSTD::move(__u.key_eq());\n        max_load_factor() = __u.max_load_factor();\n        if (bucket_count() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                const_iterator __i = __u.begin();\n                while (__cache != nullptr && __u.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__u.remove(__i++)->__value_);\n                    __node_pointer __next = __cache->__next_;\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                __deallocate(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __deallocate(__cache);\n        }\n        const_iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __node_holder __h =\n                    __construct_node(_VSTD::move(__u.remove(__i++)->__value_));\n            __node_insert_multi(__h.get());\n            __h.release();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    __move_assign(__u, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,\n                                                          _InputIterator __last)\n{\n    if (bucket_count() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __cache->__next_;\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    if (bucket_count() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __cache->__next_;\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__p1_.first().__next_, this);\n#else\n    return iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(nullptr, this);\n#else\n    return iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(__p1_.first().__next_, this);\n#else\n    return const_iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(nullptr, this);\n#else\n    return const_iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() _NOEXCEPT\n{\n    if (size() > 0)\n    {\n        __deallocate(__p1_.first().__next_);\n        __p1_.first().__next_ = nullptr;\n        size_type __bc = bucket_count();\n        for (size_type __i = 0; __i < __bc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)\n{\n    __nd->__hash_ = hash_function()(__nd->__value_);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __node_pointer __ndptr;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__nd->__hash_, __bc);\n        __ndptr = __bucket_list_[__chash];\n        if (__ndptr != nullptr)\n        {\n            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&\n                                             __constrain_hash(__ndptr->__hash_, __bc) == __chash;\n                                                     __ndptr = __ndptr->__next_)\n            {\n                if (key_eq()(__ndptr->__value_, __nd->__value_))\n                    goto __done;\n            }\n        }\n    }\n    {\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__nd->__hash_, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __node_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd;\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__nd->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__nd->__next_->__hash_, __bc)] = __nd;\n        }\n        else\n        {\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd;\n        }\n        __ndptr = __nd;\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__ndptr, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__ndptr), __inserted);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)\n{\n    __cp->__hash_ = hash_function()(__cp->__value_);\n    size_type __bc = bucket_count();\n    if (size()+1 > __bc * max_load_factor() || __bc == 0)\n    {\n        rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                       size_type(ceil(float(size() + 1) / max_load_factor()))));\n        __bc = bucket_count();\n    }\n    size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n    __node_pointer __pn = __bucket_list_[__chash];\n    if (__pn == nullptr)\n    {\n        __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp;\n        // fix up __bucket_list_\n        __bucket_list_[__chash] = __pn;\n        if (__cp->__next_ != nullptr)\n            __bucket_list_[__constrain_hash(__cp->__next_->__hash_, __bc)] = __cp;\n    }\n    else\n    {\n        for (bool __found = false; __pn->__next_ != nullptr &&\n                                   __constrain_hash(__pn->__next_->__hash_, __bc) == __chash;\n                                                           __pn = __pn->__next_)\n        {\n            //      __found    key_eq()     action\n            //      false       false       loop\n            //      true        true        loop\n            //      false       true        set __found to true\n            //      true        false       break\n            if (__found != (__pn->__next_->__hash_ == __cp->__hash_ &&\n                            key_eq()(__pn->__next_->__value_, __cp->__value_)))\n            {\n                if (!__found)\n                    __found = true;\n                else\n                    break;\n            }\n        }\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp;\n        if (__cp->__next_ != nullptr)\n        {\n            size_t __nhash = __constrain_hash(__cp->__next_->__hash_, __bc);\n            if (__nhash != __chash)\n                __bucket_list_[__nhash] = __cp;\n        }\n    }\n    ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__cp, this);\n#else\n    return iterator(__cp);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(\n        const_iterator __p, __node_pointer __cp)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    if (__p != end() && key_eq()(*__p, __cp->__value_))\n    {\n        __node_pointer __np = __p.__node_;\n        __cp->__hash_ = __np->__hash_;\n        size_type __bc = bucket_count();\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n        }\n        size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n        __node_pointer __pp = __bucket_list_[__chash];\n        while (__pp->__next_ != __np)\n            __pp = __pp->__next_;\n        __cp->__next_ = __np;\n        __pp->__next_ = __cp;\n        ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__cp, this);\n#else\n        return iterator(__cp);\n#endif\n    }\n    return __node_insert_multi(__cp);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_unique(const value_type& __x)\n{\n    size_t __hash = hash_function()(__x);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __node_pointer __nd;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__hash, __bc);\n        __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                                       __constrain_hash(__nd->__hash_, __bc) == __chash;\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__value_, __x))\n                    goto __done;\n            }\n        }\n    }\n    {\n        __node_holder __h = __construct_node(__x, __hash);\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__hash, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __node_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__h->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__h->__next_->__hash_, __bc)] = __h.get();\n        }\n        else\n        {\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get();\n        }\n        __nd = __h.release();\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__nd, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__nd), __inserted);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(\n        const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Pp>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_unique(_Pp&& __x)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Pp>(__x));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Pp>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(_Pp&& __x)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Pp>(__x));\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Pp>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         _Pp&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, rvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Pp>(__x));\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const value_type& __x)\n{\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, lvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)\n{\n    if (__n == 1)\n        __n = 2;\n    else if (__n & (__n - 1))\n        __n = __next_prime(__n);\n    size_type __bc = bucket_count();\n    if (__n > __bc)\n        __rehash(__n);\n    else if (__n < __bc)\n    {\n        __n = _VSTD::max<size_type>\n              (\n                  __n,\n                  __is_power2(__bc) ? __next_pow2(size_t(ceil(float(size()) / max_load_factor()))) :\n                                      __next_prime(size_t(ceil(float(size()) / max_load_factor())))\n              );\n        if (__n < __bc)\n            __rehash(__n);\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();\n    __bucket_list_.reset(__nbc > 0 ?\n                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);\n    __bucket_list_.get_deleter().size() = __nbc;\n    if (__nbc > 0)\n    {\n        for (size_type __i = 0; __i < __nbc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        __node_pointer __pp(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first())));\n        __node_pointer __cp = __pp->__next_;\n        if (__cp != nullptr)\n        {\n            size_type __chash = __constrain_hash(__cp->__hash_, __nbc);\n            __bucket_list_[__chash] = __pp;\n            size_type __phash = __chash;\n            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;\n                                                           __cp = __pp->__next_)\n            {\n                __chash = __constrain_hash(__cp->__hash_, __nbc);\n                if (__chash == __phash)\n                    __pp = __cp;\n                else\n                {\n                    if (__bucket_list_[__chash] == nullptr)\n                    {\n                        __bucket_list_[__chash] = __pp;\n                        __pp = __cp;\n                        __phash = __chash;\n                    }\n                    else\n                    {\n                        __node_pointer __np = __cp;\n                        for (; __np->__next_ != nullptr &&\n                               key_eq()(__cp->__value_, __np->__next_->__value_);\n                                                           __np = __np->__next_)\n                            ;\n                        __pp->__next_ = __np->__next_;\n                        __np->__next_ = __bucket_list_[__chash]->__next_;\n                        __bucket_list_[__chash]->__next_ = __cp;\n\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __node_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                                       __constrain_hash(__nd->__hash_, __bc) == __chash;\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return iterator(__nd, this);\n#else\n                    return iterator(__nd);\n#endif\n            }\n        }\n    }\n    return end();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __node_const_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                                           __constrain_hash(__nd->__hash_, __bc) == __chash;\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return const_iterator(__nd, this);\n#else\n                    return const_iterator(__nd);\n#endif\n            }\n        }\n\n    }\n    return end();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class ..._Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(value_type&& __v,\n                                                           size_t __hash)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::move(__v));\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const value_type& __v,\n                                                           size_t __hash)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container erase(iterator) called with an iterator not\"\n        \" referring to this container\");\n    _LIBCPP_ASSERT(__p != end(),\n        \"unordered container erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __r(__np, this);\n#else\n    iterator __r(__np);\n#endif\n    ++__r;\n    remove(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,\n                                                const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n#endif\n    for (const_iterator __p = __first; __first != __last; __p = __first)\n    {\n        ++__first;\n        erase(__p);\n    }\n    __node_pointer __np = __last.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator (__np, this);\n#else\n    return iterator (__np);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)\n{\n    size_type __r = 0;\n    iterator __i = find(__k);\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            erase(__i++);\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) _NOEXCEPT\n{\n    // current node\n    __node_pointer __cn = __p.__node_;\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__cn->__hash_, __bc);\n    // find previous node\n    __node_pointer __pn = __bucket_list_[__chash];\n    for (; __pn->__next_ != __cn; __pn = __pn->__next_)\n        ;\n    // Fix up __bucket_list_\n        // if __pn is not in same bucket (before begin is not in same bucket) &&\n        //    if __cn->__next_ is not in same bucket (nullptr is not in same bucket)\n    if (__pn == static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()))\n                            || __constrain_hash(__pn->__hash_, __bc) != __chash)\n    {\n        if (__cn->__next_ == nullptr || __constrain_hash(__cn->__next_->__hash_, __bc) != __chash)\n            __bucket_list_[__chash] = nullptr;\n    }\n        // if __cn->__next_ is not in same bucket (nullptr is in same bucket)\n    if (__cn->__next_ != nullptr)\n    {\n        size_t __nhash = __constrain_hash(__cn->__next_->__hash_, __bc);\n        if (__nhash != __chash)\n            __bucket_list_[__nhash] = __pn;\n    }\n    // remove __cn\n    __pn->__next_ = __cn->__next_;\n    __cn->__next_ = nullptr;\n    --size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__node_ == __cn)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    return __node_holder(__cn, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const\n{\n    return static_cast<size_type>(find(__k) != end());\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const\n{\n    size_type __r = 0;\n    const_iterator __i = find(__k);\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__i;\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)\n    _NOEXCEPT_(\n        (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__pointer_allocator>::value) &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value) &&\n        __is_nothrow_swappable<hasher>::value &&\n        __is_nothrow_swappable<key_equal>::value)\n{\n    {\n    __node_pointer_pointer __npp = __bucket_list_.release();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __u.__bucket_list_.reset(__npp);\n    }\n    _VSTD::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());\n    __swap_alloc(__bucket_list_.get_deleter().__alloc(),\n             __u.__bucket_list_.get_deleter().__alloc());\n    __swap_alloc(__node_alloc(), __u.__node_alloc());\n    _VSTD::swap(__p1_.first().__next_, __u.__p1_.first().__next_);\n    __p2_.swap(__u.__p2_);\n    __p3_.swap(__u.__p3_);\n    if (size() > 0)\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n    if (__u.size() > 0)\n        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash_, __u.bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__u.__p1_.first()));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < bucket_count(),\n        \"unordered container::bucket_size(n) called with n >= bucket_count()\");\n    __node_const_pointer __np = __bucket_list_[__n];\n    size_type __bc = bucket_count();\n    size_type __r = 0;\n    if (__np != nullptr)\n    {\n        for (__np = __np->__next_; __np != nullptr &&\n                                   __constrain_hash(__np->__hash_, __bc) == __n;\n                                                    __np = __np->__next_, ++__r)\n            ;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,\n     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__node_ != nullptr;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__decrementable(const const_iterator*) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__addable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__subscriptable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP__HASH_TABLE\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","/**\n* \\class CBuffer\n*\n* \\brief Declaration of CBuffer interfaces.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#ifndef _CBUFFER_H_\n#define _CBUFFER_H_\n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <Common/Debugger.h>\n#include <Common/Magnitudes.h>\n\n#define _USE_MATH_DEFINES // TODO: Test in windows! Might also be problematic for other platforms??\n#include <math.h>\n\n\n/*! \\file */\n\n/** \\details This is a template class to manage audio streamers and buffers\n*/\ntemplate <\nunsigned int NChannels,\nclass stored\n>\nclass CBuffer : public std::vector<stored,std::allocator<stored>>\n{\npublic:\n    using std::vector<stored>::vector;    //   inherit all std::vector constructors\n    using std::vector<stored>::size;      //   MacOSX clang seems to need this to compile\n    using std::vector<stored>::begin;     //   MacOSX clang seems to need this to compile\n    using std::vector<stored>::end;       //   MacOSX clang seems to need this to compile\n    using std::vector<stored>::resize;     //   MacOSX clang seems to need this to compile\n\n\t/** \\brief Get number of channels in the buffer \n\t*\t\\retval nChannels number of channels\n\t*/\n    constexpr unsigned int GetNChannels() const\n    {\n        return NChannels;\n    }\n\n\t/** \\brief Add all sample values from another buffer\n\t*/\n    CBuffer<NChannels, stored> & operator+= (const CBuffer<NChannels, stored> & oth)\n    {\n        //assert(GetNChannels()==oth.GetNChannels()); // TODO: agree on error handling\n        //assert(size()==oth.size());\n\t\t//ASSERT(GetNChannels() == oth.GetNChannels(), \"Attempt to mix two buffers of different sizes\", \"\"); \n\t\t//ASSERT(size() == oth.size(), \"Attempt to mix two buffers of different sizes\", \"\");\n\n        std::transform(begin(),end(),oth.begin(),begin(),[](stored a,stored b) { return a+b; });\n        return *this;\n    }\n   \n\t/** \\brief Multiply the values in the buffer by a constant gain\n\t*\t\\param [in] gain constant gain value to apply\n\t*/\n\tvoid ApplyGain( stored gain )\n\t{\n\t\t//SET_RESULT(RESULT_OK, \"Gain applied to buffer succesfully\");\n\t\tstd::for_each(begin(), end(), [gain](stored & a) { a *= gain; });\n\t}\n\t\n\t/** \\brief Multiply the values in the buffer by a no-constant gain (calculate using Weighted moving average method)\n\t*\t\\param [in] previousAttenuation Last frame attenuation\n\t*\t\\param [in] attenuation Current frame attenuation\n\t*\t\\param [in] bufferSize Number of samples in the frame\n\t*/\n\tvoid ApplyGainGradually(stored previousAttenuation, float attenuation, int bufferSize)\n\t{\n\t\t//Calculate the attenuation increment \n\t\tfloat attenuationInc = (attenuation - previousAttenuation) / bufferSize;\n\n\t\t//Apply atennuation to each sample\n\t\tint nChannels = GetNChannels();\n\t\tif (nChannels==1) \n\t\t{\n\t\t\tint i = 0;\n\t\t\tstd::for_each(begin(), end(), [previousAttenuation, attenuationInc, &i](stored & a) {\n\t\t\t\ta *= (previousAttenuation + attenuationInc * i++);\n\t\t\t});\n\t\t}\n\t\telse if (nChannels == 2) \n\t\t{\t\t\t\n\t\t\tint j = 0;\n\t\t\tint halfBufferSize = (int)(*this).size()/2;\n\t\t\tfor (int i = 0; i < halfBufferSize; i++) {\n\t\t\t\t(*this)[j++] *= previousAttenuation + attenuationInc * i;\n\t\t\t\t(*this)[j++] *= previousAttenuation + attenuationInc * i;\n\t\t\t}\t\t\t\n\t\t}\n\t\telse \n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_NOTIMPLEMENTED, \"Apply a gradual gain to a buffer with more than two channels is not implemented yet\");\n\t\t}\t\t\n\t}\n\n\t\n\t/** \\brief Multiply the values in the buffer by a no-constant gain (calculate using Exponential moving average method)\n\t*\t\\param [in] previousAttenuation Last frame attenuation\n\t*\t\\param [in] attenuation Current frame attenuation\n\t*\t\\param [in] bufferSize Number of samples in the frame\n\t*/\n\tvoid ApplyGainExponentially(float &previousAttenuation_Channel1, float &previousAttenuation_Channel2, float attenuation, int bufferSize, int sampleRate)\n\t{\n\t\tfloat previousGainChannel2 = previousAttenuation_Channel2;\n\t\tfloat gainChannel2 = 0.0f;\n\t\tfloat previousGainChannel1 = previousAttenuation_Channel1;\n\t\tfloat gainChannel1 = 0.0f;\n\t\tfloat alpha;\n\n\t\t//Calculate alpha\n\t\tfloat denominator = ATTACK_TIME_DISTANCE_ATTENUATION * sampleRate; \n\t\tif (denominator > EPSILON_ATTACK_SAMPLES)\t{ alpha = 1 - exp(1000 * log(0.01f) / denominator); }\n\t\telse\t\t\t\t\t\t\t\t\t\t{ alpha = 1 ;}\n\t\t\n\t\t//Apply atennuation to each sample\n\t\tint nChannels = GetNChannels();\n\t\tif (nChannels == 1)\n\t\t{\n\t\t\tint j = 0;\n\t\t\tfor (int i = 0; i < (*this).size(); i++) {\n\t\t\t\tgainChannel1 = (attenuation - previousGainChannel1)* alpha + previousGainChannel1;\n\t\t\t\t(*this)[j++] *= gainChannel1;\n\t\t\t\tpreviousGainChannel1 = gainChannel1;\n\t\t\t}\n\t\t\tpreviousAttenuation_Channel1 = previousGainChannel1;\n\t\t}\n\t\telse if (nChannels == 2)\n\t\t{\n\t\t\tint j = 0;\n\t\t\tint halfBufferSize = (int)(*this).size() / 2;\n\t\t\tfor (int i = 0; i < halfBufferSize; i++) {\t\t\t\t\t\t\t\t\n\t\t\t\tgainChannel1 = (attenuation - previousGainChannel1)* alpha + previousGainChannel1;\n\t\t\t\t(*this)[j++] *= gainChannel1;\n\t\t\t\tpreviousGainChannel1 = gainChannel1;\n\t\t\t\tgainChannel2 = (attenuation - previousGainChannel2)* alpha + previousGainChannel2;\n\t\t\t\t(*this)[j++] *= gainChannel2;\n\t\t\t\tpreviousGainChannel2 = gainChannel2;\n\t\t\t}\t\n\t\t\tpreviousAttenuation_Channel1 = previousGainChannel1;\n\t\t\tpreviousAttenuation_Channel2 = previousGainChannel2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_NOTIMPLEMENTED, \"Apply a gradual gain to a buffer with more than two channels is not implemented yet\");\n\t\t}\n\t}\n\n\t/** \\brief Fill nToFill samples of the buffer with the same value\n\t*\t\\param [in] nToFill number of samples to fill\n\t*\t\\param [in] value value to fill with\n\t*/\n\tvoid Fill(size_t nToFill, stored value)\n\t{\n\t\tSET_RESULT(RESULT_OK, \"Buffer filled with single value succesfully\");\n\t\t// Assign is the fastest implementation, after memset. See: http://stackoverflow.com/questions/8848575/fastest-way-to-reset-every-value-of-stdvectorint-to-0\n\t\tthis->assign(nToFill, value);\n\t}\n\n\n\t /* Combine two buffers by interlacing them into a new bigger buffer. \n\t If buffers have different sizes, the missing samples will be filled with zeros\n\t If firstBuffer = FB_ch1_s1, FB_ch2_s1, FB_ch1_s2, FB_ch2_s2....\n\t And secondBuffer = SB_ch1_s1, SB_ch2_s1, SB_ch1_s2, SB_ch2_s2....\n\t Then new buffer will be = FB_ch1_s1, SB_ch1_s1, FB_ch2_s1, SB_ch2_s1, FB_ch1_s2, FB_ch1_s2, FB_ch2_s2, SB_ch2_s2.... */\n#if 0 // yet untested, leave out for the moment\n\tCBuffer Interlace(CBuffer firstBuffer, CBuffer secondBuffer)\n\t{\n\t\t// Setup new buffer\n\t\tconstexpr unsigned int newBufferChannels = firstBuffer.GetNChannels() + secondBuffer.GetNChannels();\n        unsigned long newBufferNSamples = firstBuffer.GetNSamples() > secondBuffer.GetNsamples() ? firstBuffer.GetNsamples() : secondBuffer.GetNsamples();\n\t\tCBuffer<newBufferChannels, stored> newBuffer;\n\n\t\t// Interlace!\n        for (int i = 0; i < newBufferNSamples; i++)\n\t\t{\n\t\t\tif (firstBuffer.size() < i)\n\t\t\t\tnewBuffer.push_back(firstBuffer[i]);\n\t\t\telse\n\t\t\t\tnewBuffer.push_back(0);\n\n\t\t\tif (secondBuffer.size() < i)\n\t\t\t\tnewBuffer.push_back(secondBuffer[i]);\n\t\t\telse\n\t\t\t\tnewBuffer.push_back(0);\n\t\t}\n\n\t\treturn newBuffer;\n\t}\n#endif\n\n\t/** \\brief Mix a mono buffer into one channel of this buffer.\n\t*\t\\details If sourceBuffer has more samples than this buffer, this buffer size is expanded.\t \n\t*\t\\param [in] sourceBuffer mono buffer to mix from\n\t*\t\\param [in] nChannel channel where the buffer will be mixed\n\t*/\n\tvoid AddToChannel(CBuffer<1,stored> & sourceBuffer, unsigned int nChannel)\n\t{\t\t\t\n\t\t// DEBUGGER: no possible error sources, other than reallocation failure after push_back (not expected)\n\t\tSET_RESULT(RESULT_OK, \"Samples mixed into channel of buffer succesfully\");\n\n\t\tfor (int sourceSample = 0; sourceSample < sourceBuffer.size(); sourceSample++)\n\t\t{\n\t\t\tif (sourceSample < GetNsamples())\n\t\t\t\t(*this)[sourceSample*GetNChannels() + nChannel] += sourceBuffer[sourceSample];\n\n\t\t\telse // Expand all channels!\n\t\t\t{\n\t\t\t\tfor (int ch = 0; ch < GetNChannels(); ch++)\n\t\t\t\t{\n\t\t\t\t\tif (ch == nChannel)\n\t\t\t\t\t\tthis->push_back(sourceBuffer[sourceSample]);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis->push_back(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Mix any number of buffers into a single mixed buffer\n\t//CBuffer<NChannels, stored> Mix(std::vector<CBuffer<NChannels, stored>> mixChannels)\n\t//{\n\t//\t// TO DO: Check number of channels, size...\n\t//\t// TO DO: Faster implementation\n\n\t//\tCBuffer<NChannels, stored> mixedBuffer;\n\t//\tmixedBuffer = mixChannels[0];\n\n\t//\tfor (int i = 1; i < mixChannels.size(); i++)\n\t//\t\tmixedBuffer += mixChannels[i];\n\n\t//\treturn mixedBuffer;\n\t//}\n\n\t/** \\brief Expand mono buffer into a stereo buffer, duplicating channels\n\t*\t\\retval stereoBuffer expanded stereo buffer\n\t*/\n\tCBuffer<2,stored> FromMonoToStereo() const\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\t// DEBUGGER: no possible error sources, other than reallocation failure after push_back (not expected)\n\t\tSET_RESULT(RESULT_OK, \"Succesfull conversion of buffer from mono to stereo\");\n\n\t\tCBuffer<2, stored> stereoBuffer;\n\n\t\t//// PREcondition: source buffer is mono\n\t\t//if (GetNChannels() != 1)\n\t\t//\treturn stereoBuffer; // <- this wont work\n\t\t\t\t\n\t\tfor (int i = 0; i < size(); i++)\n\t\t{\n\t\t\tstereoBuffer.push_back((*this)[i]);\n\t\t\tstereoBuffer.push_back((*this)[i]);\n\t\t}\n\n\t\treturn stereoBuffer;\n\t}\n\n\t/** \\brief Expand mono buffer into a stereo buffer, with different gains for each channel\t\n\t*\t\\param [in] leftGain gain applied to left channel\n\t*\t\\param [in] rightGain gain applied to right channel\n\t*\t\\retval stereoBuffer expanded stereo buffer\n\t*/\n\tCBuffer<2, stored> FromMonoToStereo(float leftGain, float rightGain ) const\n\t{\n\t\t// DEBUGGER: no possible error sources, other than reallocation failure after push_back (not expected)\n\t\tSET_RESULT(RESULT_OK, \"Succesfull weighted conversion of buffer from mono to stereo\");\n\n\t\tCBuffer<2, stored> stereoBuffer;\n\n\t\t//// PREcondition: source buffer is mono\n\t\t//if (GetNChannels() != 1)\n\t\t//\treturn stereoBuffer; // <- this wont work\n\n\t\tfor (int i = 0; i < size(); i++)\n\t\t{\n\t\t\tstereoBuffer.push_back( leftGain  * (*this)[i] );\n\t\t\tstereoBuffer.push_back( rightGain * (*this)[i] );\n\t\t}\n\n\t\treturn stereoBuffer;\n\t}\n\n\t/** \\brief Compose a stereo buffer out of two mono buffers\t \n\t*\t\\param [in] left mono buffer for left channel\n\t*\t\\param [in] right mono buffer for right channel\n\t*\t\\pre this must be a stereo buffer\n\t*\t\\pre left and right must have the same size\n\t*\t\\throws May throw exceptions and errors to debugger\n\t*/\n\tvoid FromTwoMonosToStereo(CBuffer<1, stored> & left, CBuffer<1, stored> & right)\n\t{\n\t\t// PRECONDITION: stereo buffer\n\t\t//if (GetNChannels() != 2)\n\t\t//{\n\t\t//\tSET_RESULT(RESULT_ERROR_BADSIZE, \"Attempt to compose a buffer from two mono sources, and buffer is not stereo\");\n\t\t//\treturn;\n\t\t//}\n\t\tASSERT(GetNChannels() == 2, RESULT_ERROR_BADSIZE, \"Attempt to compose a buffer from two mono sources, and buffer is not stereo\", \"\");\n\n\t\t// PRECONDITION: buffer sizes\n\t\t//if (left.size() != right.size())\n\t\t//{\n\t\t//\tSET_RESULT(RESULT_ERROR_BADSIZE, \"Attempt to combine two mono buffers into one stereo, and buffers are of different length\");\n\t\t//\treturn;\n\t\t//}\n\t\tASSERT(left.size() == right.size(),\tRESULT_ERROR_BADSIZE, \"Attempt to combine two mono buffers into one stereo, and buffers are of different length\", \"\");\n\n\t\tSET_RESULT(RESULT_OK, \"Stereo buffer composed out of two mono buffers succesfully\");\n\n\t\t// Start with a clean buffer\n\t\tthis->clear();\n\n\t\t// Interlace channels\n\t\tfor (int sample = 0; sample < left.size(); sample++)\n\t\t{\n\t\t\tthis->push_back(left[sample]);\n\t\t\tthis->push_back(right[sample]);\n\t\t}\n\t}\n\n    \t\n\t/** \\brief Get one channel of a multi-channel buffer into a new mono buffer\n\t*\t\\param [in] nchannel channel from which compose mono buffer\n\t*\t\\retval monoBuffer new mono buffer with data extracted from channel\n\t*/\n\tCBuffer<1, stored> GetMonoChannel(int nchannel) const\n\t{\n\t\t// DEBUGGER: no possible error sources, other than reallocation failure after push_back (not expected)\n\t\tSET_RESULT(RESULT_OK, \"Obtained mono buffer from one channel of a bigger buffer succesfully\");\n\n\t\tCBuffer<1, stored> monoBuffer;\n\n\t\t/// PREcondition: source buffer has at least nchannel channels\n\t\t//if (GetNChannels() < nchannel)\n\t\t//\treturn monoBuffer; // <- this wont work\n\t\t\n\t\tfor (int i = 0; i < size(); i+=GetNChannels())\n\t\t{\n\t\t\tmonoBuffer.push_back((*this)[i+nchannel]);\n\t\t}\n\n\t\treturn monoBuffer;\n\t}\n\n\t/** \\brief Get number of samples in each channel of the buffer\n\t*\t\\pre Buffer must have at least one channel\n\t*\t\\retval nSamples number of samples per channel\n\t*/\n    unsigned long GetNsamples() const\n    {return size()/GetNChannels(); }\n\n\t/** \\brief Feed a buffer with data coming from an array \n\t*\t\\param [in] _data array of data\n\t*\t\\param [in] _length size of data array\n\t*\t\\param [in] _nchannels number of channels\n\t*/\n    void Feed(stored* _data, int _length, int _nchannels)\n    {\n\t\t// DEBUGGER: no possible error sources, other than reallocation failure after resize (not expected)\n\t\t// NOTE: nchannels is not being used\n\t\tSET_RESULT(RESULT_OK, \"Buffer fed succesfully\");\n\n        resize(_length);\n        for (int i = 0; i<size(); i++)\n        {\n            (*this)[i]=_data[i];\n        }\n    }\n\n};\n\n/** One channel specialization of CBuffer\n*/\ntemplate<class stored>\nusing CMonoBuffer = CBuffer<1,stored>;\n\n/** Two channels specialization of CBuffer\n*/\ntemplate<class stored>\nusing CStereoBuffer = CBuffer<2,stored>;\n\n/** Non-enforcing buffer \n*/\ntemplate<class stored>\nusing CMultiChannelBuffer = std::vector<stored>; \n#endif\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __split_buffer(__alloc_rr& __a);\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__alloc_rr>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_alloc(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","#pragma once\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                    ? &typeid(C)\n                    : CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                ? &typeid(value)\n                : LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n","#pragma once\n\n#include <stdint.h> // uintptr_t\n#include <emscripten/wire.h>\n#include <array>\n#include <vector>\n\n\nnamespace emscripten {\n\n    class val;\n\n    namespace internal {\n\n        template<typename WrapperType>\n        val wrapped_extend(const std::string&, const val&);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _emval_register_symbol(const char*);\n\n            enum {\n                _EMVAL_UNDEFINED = 1,\n                _EMVAL_NULL = 2,\n                _EMVAL_TRUE = 3,\n                _EMVAL_FALSE = 4\n            };\n\n            typedef struct _EM_VAL* EM_VAL;\n            typedef struct _EM_DESTRUCTORS* EM_DESTRUCTORS;\n            typedef struct _EM_METHOD_CALLER* EM_METHOD_CALLER;\n            typedef double EM_GENERIC_WIRE_TYPE;\n            typedef const void* EM_VAR_ARGS;\n\n            void _emval_incref(EM_VAL value);\n            void _emval_decref(EM_VAL value);\n\n            void _emval_run_destructors(EM_DESTRUCTORS handle);\n\n            EM_VAL _emval_new_array();\n            EM_VAL _emval_new_object();\n            EM_VAL _emval_new_cstring(const char*);\n\n            EM_VAL _emval_take_value(TYPEID type, EM_VAR_ARGS argv);\n\n            EM_VAL _emval_new(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            EM_VAL _emval_get_global(const char* name);\n            EM_VAL _emval_get_module_property(const char* name);\n            EM_VAL _emval_get_property(EM_VAL object, EM_VAL key);\n            void _emval_set_property(EM_VAL object, EM_VAL key, EM_VAL value);\n            EM_GENERIC_WIRE_TYPE _emval_as(EM_VAL value, TYPEID returnType, EM_DESTRUCTORS* destructors);\n\n            bool _emval_equals(EM_VAL first, EM_VAL second);\n            bool _emval_strictly_equals(EM_VAL first, EM_VAL second);\n\n            EM_VAL _emval_call(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            // DO NOT call this more than once per signature. It will\n            // leak generated function objects!\n            EM_METHOD_CALLER _emval_get_method_caller(\n                unsigned argCount, // including return value\n                const TYPEID argTypes[]);\n            EM_GENERIC_WIRE_TYPE _emval_call_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                EM_VAR_ARGS argv);\n            void _emval_call_void_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_VAR_ARGS argv);\n            EM_VAL _emval_typeof(EM_VAL value);\n        }\n\n        template<const char* address> \n        struct symbol_registrar {\n            symbol_registrar() {\n                internal::_emval_register_symbol(address);\n            }\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct Signature {\n            /*\n            typedef typename BindingType<ReturnType>::WireType (*MethodCaller)(\n                EM_VAL value,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                typename BindingType<Args>::WireType...);\n            */\n\n            static EM_METHOD_CALLER get_method_caller() {\n                static EM_METHOD_CALLER mc = init_method_caller();\n                return mc;\n            }\n\n        private:\n            static EM_METHOD_CALLER init_method_caller() {\n                WithPolicies<>::ArgTypeList<ReturnType, Args...> args;\n                return _emval_get_method_caller(args.getCount(), args.getTypes());\n            }\n        };\n\n        struct DestructorsRunner {\n        public:\n            explicit DestructorsRunner(EM_DESTRUCTORS d)\n                : destructors(d)\n            {}\n            ~DestructorsRunner() {\n                _emval_run_destructors(destructors);\n            }\n\n            DestructorsRunner(const DestructorsRunner&) = delete;\n            void operator=(const DestructorsRunner&) = delete;\n\n        private:\n            EM_DESTRUCTORS destructors;\n        };\n\n        template<typename WireType>\n        struct GenericWireTypeConverter {\n            static WireType from(double wt) {\n                return static_cast<WireType>(wt);\n            }\n        };\n\n        template<typename Pointee>\n        struct GenericWireTypeConverter<Pointee*> {\n            static Pointee* from(double wt) {\n                return reinterpret_cast<Pointee*>(static_cast<uintptr_t>(wt));\n            }\n        };\n\n        template<typename T>\n        T fromGenericWireType(double g) {\n            typedef typename BindingType<T>::WireType WireType;\n            WireType wt = GenericWireTypeConverter<WireType>::from(g);\n            return BindingType<T>::fromWireType(wt);\n        }\n\n        template<typename... Args>\n        struct PackSize;\n\n        template<>\n        struct PackSize<> {\n            static constexpr size_t value = 0;\n        };\n\n        template<typename Arg, typename... Args>\n        struct PackSize<Arg, Args...> {\n            static constexpr size_t value = (sizeof(typename BindingType<Arg>::WireType) + 7) / 8 + PackSize<Args...>::value;\n        };\n\n        union GenericWireType {\n            union {\n                unsigned u;\n                float f;\n                const void* p;\n            } w[2];\n            double d;\n        };\n        static_assert(sizeof(GenericWireType) == 8, \"GenericWireType must be 8 bytes\");\n        static_assert(alignof(GenericWireType) == 8, \"GenericWireType must be 8-byte-aligned\");\n\n        inline void writeGenericWireType(GenericWireType*& cursor, float wt) {\n            cursor->w[0].f = wt;\n            ++cursor;\n        }\n\n        inline void writeGenericWireType(GenericWireType*& cursor, double wt) {\n            cursor->d = wt;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T* wt) {\n            cursor->w[0].p = wt;\n            ++cursor;\n        }\n\n        template<typename ElementType>\n        inline void writeGenericWireType(GenericWireType*& cursor, const memory_view<ElementType>& wt) {\n            cursor->w[0].u = wt.size;\n            cursor->w[1].p = wt.data;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T wt) {\n            cursor->w[0].u = static_cast<unsigned>(wt);\n            ++cursor;\n        }\n\n        inline void writeGenericWireTypes(GenericWireType*&) {\n        }\n\n        template<typename First, typename... Rest>\n        EMSCRIPTEN_ALWAYS_INLINE void writeGenericWireTypes(GenericWireType*& cursor, First&& first, Rest&&... rest) {\n            writeGenericWireType(cursor, BindingType<First>::toWireType(std::forward<First>(first)));\n            writeGenericWireTypes(cursor, std::forward<Rest>(rest)...);\n        }\n\n        template<typename... Args>\n        struct WireTypePack {\n            WireTypePack(Args&&... args) {\n                GenericWireType* cursor = elements.data();\n                writeGenericWireTypes(cursor, std::forward<Args>(args)...);\n            }\n\n            operator EM_VAR_ARGS() const {\n                return elements.data();\n            }\n\n        private:\n            std::array<GenericWireType, PackSize<Args...>::value> elements;\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct MethodCaller {\n            static ReturnType call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<ReturnType, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                EM_DESTRUCTORS destructors;\n                EM_GENERIC_WIRE_TYPE result = _emval_call_method(\n                    caller,\n                    handle,\n                    methodName,\n                    &destructors,\n                    argv);\n                DestructorsRunner rd(destructors);\n                return fromGenericWireType<ReturnType>(result);\n            }\n        };\n\n        template<typename... Args>\n        struct MethodCaller<void, Args...> {\n            static void call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<void, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                _emval_call_void_method(\n                    caller,\n                    handle,\n                    methodName,\n                    argv);\n            }\n        };\n    }\n\n#define EMSCRIPTEN_SYMBOL(name)                                         \\\n    static const char name##_symbol[] = #name;                          \\\n    static const ::emscripten::internal::symbol_registrar<name##_symbol> name##_registrar\n\n    class val {\n    public:\n        // missing operators:\n        // * delete\n        // * in\n        // * instanceof\n        // * ! ~ - + ++ --\n        // * * / %\n        // * + -\n        // * << >> >>>\n        // * < <= > >=\n        // * == != === !==\n        // * & ^ | && || ?:\n        //\n        // exposing void, comma, and conditional is unnecessary\n        // same with: = += -= *= /= %= <<= >>= >>>= &= ^= |=\n\n        static val array() {\n            return val(internal::_emval_new_array());\n        }\n\n        static val object() {\n            return val(internal::_emval_new_object());\n        }\n\n        static val undefined() {\n            return val(internal::EM_VAL(internal::_EMVAL_UNDEFINED));\n        }\n\n        static val null() {\n            return val(internal::EM_VAL(internal::_EMVAL_NULL));\n        }\n\n        static val take_ownership(internal::EM_VAL e) {\n            return val(e);\n        }\n\n        static val global(const char* name = 0) {\n            return val(internal::_emval_get_global(name));\n        }\n\n        static val module_property(const char* name) {\n            return val(internal::_emval_get_module_property(name));\n        }\n\n        template<typename T>\n        explicit val(T&& value) {\n            using namespace internal;\n\n            typedef internal::BindingType<T> BT;\n            WireTypePack<T> argv(std::forward<T>(value));\n            handle = _emval_take_value(\n                internal::TypeID<T>::get(),\n                argv);\n        }\n\n        val() = delete;\n\n        explicit val(const char* v)\n            : handle(internal::_emval_new_cstring(v))\n        {}\n\n        val(val&& v)\n            : handle(v.handle)\n        {\n            v.handle = 0;\n        }\n\n        val(const val& v)\n            : handle(v.handle)\n        {\n            internal::_emval_incref(handle);\n        }\n\n        ~val() {\n            internal::_emval_decref(handle);\n        }\n\n        val& operator=(val&& v) {\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            v.handle = 0;\n            return *this;\n        }\n\n        val& operator=(const val& v) {\n            internal::_emval_incref(v.handle);\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            return *this;\n        }\n\n        bool hasOwnProperty(const char* key) const {\n            return val::global(\"Object\")[\"prototype\"][\"hasOwnProperty\"].call<bool>(\"call\", *this, val(key));\n        }\n\n        bool isNull() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_NULL);\n        }\n\n        bool isUndefined() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_UNDEFINED);\n        }\n\n        bool isTrue() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_TRUE);\n        }\n\n        bool isFalse() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_FALSE);\n        }\n\n        bool equals(const val& v) const {\n            return internal::_emval_equals(handle, v.handle);\n        }\n\n        bool strictlyEquals(const val& v) const {\n            return internal::_emval_strictly_equals(handle, v.handle);\n        }\n\n        template<typename... Args>\n        val new_(Args&&... args) const {\n            return internalCall(internal::_emval_new,std::forward<Args>(args)...);\n        }\n\n        template<typename T>\n        val operator[](const T& key) const {\n            return val(internal::_emval_get_property(handle, val(key).handle));\n        }\n\n        template<typename K>\n        void set(const K& key, const val& v) {\n            internal::_emval_set_property(handle, val(key).handle, v.handle);\n        }\n\n        template<typename K, typename V>\n        void set(const K& key, const V& value) {\n            internal::_emval_set_property(handle, val(key).handle, val(value).handle);\n        }\n\n        template<typename... Args>\n        val operator()(Args&&... args) {\n            return internalCall(internal::_emval_call, std::forward<Args>(args)...);\n        }\n\n        template<typename ReturnValue, typename... Args>\n        ReturnValue call(const char* name, Args&&... args) const {\n            using namespace internal;\n\n            return MethodCaller<ReturnValue, Args...>::call(handle, name, std::forward<Args>(args)...);\n        }\n\n        template<typename T>\n        T as() const {\n            using namespace internal;\n\n            typedef BindingType<T> BT;\n\n            EM_DESTRUCTORS destructors;\n            EM_GENERIC_WIRE_TYPE result = _emval_as(\n                handle,\n                TypeID<T>::get(),\n                &destructors);\n            DestructorsRunner dr(destructors);\n            return fromGenericWireType<T>(result);\n        }\n\n        val typeof() const {\n            return val(_emval_typeof(handle));\n        }\n\n    private:\n        // takes ownership, assumes handle already incref'd\n        explicit val(internal::EM_VAL handle)\n            : handle(handle)\n        {}\n\n        template<typename WrapperType>\n        friend val internal::wrapped_extend(const std::string& , const val& );\n\n        internal::EM_VAL __get_handle() const {\n            return handle;\n        }\n\n        template<typename Implementation, typename... Args>\n        val internalCall(Implementation impl, Args&&... args)const {\n            using namespace internal;\n\n            WithPolicies<>::ArgTypeList<Args...> argList;\n            WireTypePack<Args...> argv(std::forward<Args>(args)...);\n            return val(\n                impl(\n                    handle,\n                    argList.getCount(),\n                    argList.getTypes(),\n                    argv));\n        }\n\n        internal::EM_VAL handle;\n\n        friend struct internal::BindingType<val>;\n    };\n\n    namespace internal {\n        template<>\n        struct BindingType<val> {\n            typedef internal::EM_VAL WireType;\n            static WireType toWireType(const val& v) {\n                _emval_incref(v.handle);\n                return v.handle;\n            }\n            static val fromWireType(WireType v) {\n                return val::take_ownership(v);\n            }\n        };\n    }\n\n    template<typename T>\n    std::vector<T> vecFromJSArray(val v) {\n        auto l = v[\"length\"].as<unsigned>();\n\n        std::vector<T> rv;\n        for(unsigned i = 0; i < l; ++i) {\n            rv.push_back(v[i].as<T>());\n        }\n\n        return rv;\n    };\n}\n","// /**\n// * \\class CListener\n// *\n// * \\brief Declaration of CListener interfaces.\n// * \\version $1.0$\n// * \\date\tJuly 2016\n// *\n// * \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n// * \\b Contact: areyes@uma.es\n// *\n// * \\b Contributions: (additional authors/contributors can be added here)\n// *\n// * \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n// * \\b Website: http://3d-tune-in.eu/\n// *\n// * \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n// *\n// * \\b License: (insert agreed license terms here)\n// *\n// */\n\n#ifndef _CLISTENER_H_\n#define _CLISTENER_H_\n\n#include <BinauralSpatializer/HRTF.h>\n#include <Common/Transform.h>\n#include <Common/Magnitudes.h>\n#include <Common/Buffer.h>\n#include <vector>\n#include <memory>\n\n\nnamespace Binaural {\n\nclass CCore;\n\n/** \\details Class for centralization of several funtionalities of the binaural spatializer, such as handling sound sources, audio state, listener and environment.\n*/\nclass CListener\n{\n    // METHODS\npublic:\n    \n\t/** \\brief Constructor with parameters should not be called directly (use CreateListener in \\link Core \\endLink instead)\n\t*\t\\param [in] _listenerHeadRadius listener head radius for ITD customization, in meters\n    *\t\\param [in] _ownerCore audio state configuration (See \\link AudioState \\endlink)\n\t*/\n\tCListener(CCore* _ownerCore, float _listenerHeadRadius=0.0875f);\n\n\t/** \\brief Set listener position and orientation\n\t*\t\\param [in] _listenerTransform new listener position and orientation\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tvoid SetListenerTransform(CTransform _listenerTransform);\t\t\t\t\t\t\t\n\n\t/** \\brief Get listener position and orientation\n\t*\t\\retval transform current listener position and orientation\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tconst CTransform GetListenerTransform() const;\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set HRTF of listener \n\t*\t\\param [in] _listenerHRTF new listener HRTF\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tvoid LoadHRTF(CHRTF && _listenerHRTF);\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get HRTF of listener\n\t*\t\\retval HRTF current listener HRTF\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tconst CHRTF& GetHRTF() const;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set head radius of listener\n\t*\t\\param [in] _listenerHeadRadius new listener head radius, in meters\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tvoid SetHeadRadius(float _listenerHeadRadius);\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Switch on/off customized ITD\n\t*\t\\details Listener head radius is used only if ITD customization is enabled\n\t*\t\\param [in] enable switch for ITD customization\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tvoid SetCustomizedITD(bool enable);\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get head radius of listener\n\t*\t\\retval radius current listener head radius, in meters\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tfloat GetHeadRadius() const;\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get position and orientation of listener left ear\n\t*\t\\retval transform current listener left ear position and orientation\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tconst CTransform GetListenerLeftEarTransform() const;\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get position and orientation of listener right ear\n\t*\t\\retval transform current listener right ear position and orientation\n\t*\t\\note This method is implemented in \\link CoreState \\endlink\n\t*/\n\tconst CTransform GetListenerRightEarTransform() const;\t\t\t\t\t\t\t\t\n\n\n// ATTRIBUTES\nprivate:\n\n\t// HRTF of listener\n    CHRTF listenerHRTF;\n    \n    // Head radius of listener\n\tfloat listenerHeadRadius;\n    \n    // Transform matrix (position and orientation) of listener\n\tCTransform listenerTransform;\n\n\t// owner Core\n    CCore* ownerCore;\n};\n    \n}\n\n#endif","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n    const char* __type_name;\n#else\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        : __type_name(__n) {}\n#else\n        : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name;}\n#else\n        {return reinterpret_cast<const char*>(__type_name & ~_LIBCPP_NONUNIQUE_RTTI_BIT);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name < __arg.__type_name;}\n#else\n        {if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return __type_name < __arg.__type_name;\n         return __compare_nonunique_names(__arg) < 0;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n#else\n        {if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT)) return __type_name;\n         const char *__ptr = name();\n         size_t __hash = 5381;\n         while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n           __hash = (__hash * 33) ^ __c;\n         return __hash;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name == __arg.__type_name;}\n#else\n        {if (__type_name == __arg.__type_name) return true;\n         if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return false;\n         return __compare_nonunique_names(__arg) == 0;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n#ifdef _LIBCPP_NONUNIQUE_RTTI_BIT\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n        {return __builtin_strcmp(name(), __arg.name());}\n#endif\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n","// -*- C++ -*-\n//===---------------------------- cmath -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CMATH\n#define _LIBCPP_CMATH\n\n/*\n    cmath synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nnamespace std\n{\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <math.h>\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::signbit;\nusing ::fpclassify;\nusing ::isfinite;\nusing ::isinf;\nusing ::isnan;\nusing ::isnormal;\nusing ::isgreater;\nusing ::isgreaterequal;\nusing ::isless;\nusing ::islessequal;\nusing ::islessgreater;\nusing ::isunordered;\nusing ::isunordered;\n\nusing ::float_t;\nusing ::double_t;\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !defined(_AIX)\n\n#ifndef __sun__\n\n// acos\n\nusing ::acos;\nusing ::acosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\nusing ::asin;\nusing ::asinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\nusing ::atan;\nusing ::atanf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\nusing ::atan2;\nusing ::atan2f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\nusing ::ceil;\nusing ::ceilf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\nusing ::cos;\nusing ::cosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\nusing ::cosh;\nusing ::coshf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n#endif // __sun__\n// exp\n\nusing ::exp;\nusing ::expf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\nusing ::fabs;\nusing ::fabsf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\nusing ::floor;\nusing ::floorf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#endif //__sun__\nusing ::fmod;\nusing ::fmodf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n\n// frexp\n\nusing ::frexp;\nusing ::frexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\nusing ::ldexp;\nusing ::ldexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#endif // __sun__\nusing ::log;\nusing ::logf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n\n// log10\n\nusing ::log10;\nusing ::log10f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\nusing ::modf;\nusing ::modff;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#endif // __sun__ \nusing ::pow;\nusing ::powf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\nusing ::sin;\nusing ::sinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\nusing ::sinh;\nusing ::sinhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#endif // __sun__\nusing ::sqrt;\nusing ::sqrtf;\n\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(__sun__) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\nusing ::tan;\nusing ::tanf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\nusing ::tanh;\nusing ::tanhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::acosh;\nusing ::acoshf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::asinh;\nusing ::asinhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::atanh;\nusing ::atanhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\nusing ::cbrt;\nusing ::cbrtf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\nusing ::copysign;\nusing ::copysignf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       copysign(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return copysignf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double copysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return copysignl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\nusing ::erf;\nusing ::erff;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\nusing ::erfc;\nusing ::erfcf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\nusing ::exp2;\nusing ::exp2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\nusing ::expm1;\nusing ::expm1f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\nusing ::fdim;\nusing ::fdimf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\nusing ::fmaf;\nusing ::fma;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value &&\n    is_arithmetic<_A3>::value,\n    typename __promote<_A1, _A2, _A3>::type\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value &&\n                      is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\nusing ::fmax;\nusing ::fmaxf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\nusing ::fmin;\nusing ::fminf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\nusing ::hypot;\nusing ::hypotf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\nusing ::ilogb;\nusing ::ilogbf;\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\nusing ::lgamma;\nusing ::lgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n\n// llrint\n\nusing ::llrint;\nusing ::llrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\nusing ::llround;\nusing ::llroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\nusing ::log1p;\nusing ::log1pf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\nusing ::log2;\nusing ::log2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\nusing ::logb;\nusing ::logbf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\nusing ::lrint;\nusing ::lrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\nusing ::lround;\nusing ::lroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n#endif // _LIBCPP_MSVCRT\n#endif // __sun__\n\n// nan\n\n#ifndef _LIBCPP_MSVCRT\nusing ::nan;\nusing ::nanf;\n#endif // _LIBCPP_MSVCRT\n\n#ifndef __sun__\n#ifndef _LIBCPP_MSVCRT\n\n// nearbyint\n\nusing ::nearbyint;\nusing ::nearbyintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\nusing ::nextafter;\nusing ::nextafterf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\nusing ::nexttoward;\nusing ::nexttowardf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\nusing ::remainder;\nusing ::remainderf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\nusing ::remquo;\nusing ::remquof;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\nusing ::rint;\nusing ::rintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\nusing ::round;\nusing ::roundf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\nusing ::scalbln;\nusing ::scalblnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\nusing ::scalbn;\nusing ::scalbnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\nusing ::tgamma;\nusing ::tgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\nusing ::trunc;\nusing ::truncf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\nusing ::acosl;\nusing ::asinl;\nusing ::atanl;\nusing ::atan2l;\nusing ::ceill;\nusing ::cosl;\nusing ::coshl;\nusing ::expl;\nusing ::fabsl;\nusing ::floorl;\nusing ::fmodl;\nusing ::frexpl;\nusing ::ldexpl;\nusing ::logl;\nusing ::log10l;\nusing ::modfl;\nusing ::powl;\nusing ::sinl;\nusing ::sinhl;\nusing ::sqrtl;\nusing ::tanl;\n#ifndef _LIBCPP_MSVCRT\nusing ::tanhl;\nusing ::acoshl;\nusing ::asinhl;\nusing ::atanhl;\nusing ::cbrtl;\n#endif  // !_LIBCPP_MSVCRT\nusing ::copysignl;\n#ifndef _LIBCPP_MSVCRT\nusing ::erfl;\nusing ::erfcl;\nusing ::exp2l;\nusing ::expm1l;\nusing ::fdiml;\nusing ::fmal;\nusing ::fmaxl;\nusing ::fminl;\nusing ::hypotl;\nusing ::ilogbl;\nusing ::lgammal;\nusing ::llrintl;\nusing ::llroundl;\nusing ::log1pl;\nusing ::log2l;\nusing ::logbl;\nusing ::lrintl;\nusing ::lroundl;\nusing ::nanl;\nusing ::nearbyintl;\nusing ::nextafterl;\nusing ::nexttowardl;\nusing ::remainderl;\nusing ::remquol;\nusing ::rintl;\nusing ::roundl;\nusing ::scalblnl;\nusing ::scalbnl;\nusing ::tgammal;\nusing ::truncl;\n#endif // !_LIBCPP_MSVCRT\n\n#else \nusing ::lgamma;\nusing ::lgammaf;\n#endif // __sun__\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CMATH\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return -_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_return<type, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm)\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\ntemplate<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    template <class _Fp>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const _Fp&) {return true;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const function<_R2(_Ap...)>& __p) {return !!__p;}\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value =\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp>\n      function(_Fp, typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                      >::type* = 0);\n\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f,\n               typename enable_if<__callable<_Fp>::value>::type* = 0);\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f,\n                                     typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                     >::type*)\n    : __f_(0)\n{\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,\n                                     typename enable_if<__callable<_Fp>::value>::type*)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<_FF>\n#else\n            rebind_alloc<_FF>::other\n#endif\n            _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = (__base*)&__tempbuf;\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = (__base*)&__buf_;\n        __t->__clone((__base*)&__f.__buf_);\n        __t->destroy();\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f_ == (__base*)&__buf_)\n    {\n        __f_->__clone((__base*)&__f.__buf_);\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = (__base*)&__buf_;\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__f_ == 0)\n        throw bad_function_call();\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n_LIBCPP_FUNC_VIS extern __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern __ph<10> _10;\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_bind_expression<_Ti>::value,\n    typename __invoke_of<_Ti&, _Uj...>::type\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(const __bind& __b)\n        : __f_(__b.__f_),\n          __bound_args_(__b.__bound_args_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(const __bind& __b)\n    {\n        __f_ = __b.__f_;\n        __bound_args_ = __b.__bound_args_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(__bind&& __b)\n        : __f_(_VSTD::move(__b.__f_)),\n          __bound_args_(_VSTD::move(__b.__bound_args_)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(__bind&& __b)\n    {\n        __f_ = _VSTD::move(__b.__f_);\n        __bound_args_ = _VSTD::move(__b.__bound_args_);\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(const __bind_r& __b)\n        : base(_VSTD::forward<const base&>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(const __bind_r& __b)\n    {\n        base::operator=(_VSTD::forward<const base&>(__b));\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(__bind_r&& __b)\n        : base(_VSTD::forward<base>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(__bind_r&& __b)\n    {\n        base::operator=(_VSTD::forward<base>(__b));\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__c = 0;\n        __u.__d = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b ^ __u.__c ^ __u.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash\n    : public unary_function<_Tp, size_t>\n{\n    static_assert(is_enum<_Tp>::value, \"This hash only works for enumeration types\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","/**\n* \\class CSingleSourceDSP\n*\n* \\brief Declaration of CSingleSource interface.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#ifndef _CSINGLESOURCEDSP_H_\n#define _CSINGLESOURCEDSP_H_\n\n#include <Common/Buffer.h>\n#include <Common/Transform.h>\n#include <BinauralSpatializer/Convolver.h>\n#include <BinauralSpatializer/Core.h>\n#include <BinauralSpatializer/Listener.h>\n#include <Common/DistanceAttenuator.h>\n\n\nnamespace Binaural {\n\nclass CCore;\n\n/** \\details This class manages the spatialization of a single source\n*/\nclass CSingleSourceDSP\n{\n// PUBLIC TYPES\npublic:\n\n\t/** \\brief Type definition to allow switching on/off different modules that belong to the processes in CSingleSourceDSP \n\t*/\n\tstruct ModulesEnabler\n\t{\n\tpublic:\n\t\tbool doFarDistanceLPF;        ///< Enables/Disables the low pass filtering that is applied at far distances\n\t\tbool doDistanceAttenuation;   ///< Enables/Disables the attenuation that depends on the distance to the listener \n\t\tbool doILD;                   ///< Enables/Disables the ILD (Interaural Level Difference) processing\n\t\tbool doHRTF;                  ///< Enables/Disables the HRTF convolution\n\n\t\tModulesEnabler() : doFarDistanceLPF(true), doDistanceAttenuation(true), doILD(true), doHRTF(true) {}\n\t};\n\n// PUBLIC METHODS\npublic:\n\n//Constructors\n\n\t/** \\brief Constructor with parameters\n\t*\t\\Details links the source to the binaural core\n\t*\t\\param [in] _ownerCore pointer to the binaural core\n\t*\t\\exception May throw exceptions and errors to debugger\n\t*/\n\tCSingleSourceDSP(CCore* _ownerCore);\n\n\t/** \\brief Default constructor\n\t*\t\\details Does nothing\n\t*/\n\tCSingleSourceDSP();\n\n// Basic in/out methods\n\n\t/** \\brief Update internal buffer\n\t*\t\\details This must be called before calling to \\link ProcessAnechoic \\endlink or \\link ProcessVirtualAmbisonicReverb \\endlink\n\t*\t\\param [in] buffer reference to new buffer content\n\t*/\n\tvoid UpdateBuffer(CMonoBuffer<float> & buffer);\t\t\t\t\t\n\n\t/** \\brief Get internal buffer\n\t*\t\\retval buffer internal buffer content\n\t*\t\\exception May throw exceptions and errors to debugger\n\t*/\n\tconst CMonoBuffer<float> GetBuffer() const;\t\t\t\t\t\t\n\n\t/** \\brief Process data from internal buffer to generate anechoic spatialization (direct path)\n\t*\t\\param [out] outBuffer output stereo buffer with spatialized audio\n\t*\t\\pre Internal buffer must be updated (See \\link UpdateBuffer \\endlink)\n\t*\t\\exception May throw exceptions and errors to debugger\n\t*/\n\tvoid ProcessAnechoic(const CListener& listener, CStereoBuffer<float> & outBuffer);\n\n\t/** \\brief Process data from input buffer to generate anechoic spatialization (direct path)\t\n\t*\t\\param [in] inBuffer input buffer with anechoic audio\n\t*\t\\param [out] outBuffer output stereo buffer with spatialized audio\t\n\t*\t\\pre Internal buffer must be updated (See \\link UpdateBuffer \\endlink)\n\t*\t\\exception May throw exceptions and errors to debugger\n\t*/\n\tvoid ProcessAnechoic(const CListener & listener, const CMonoBuffer<float> & inBuffer, CStereoBuffer<float> & outBuffer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n// Get/Set methods\n\n\t/** \\brief Move source (position and orientation)\n\t*\t\\param [in] _sourceTransform new position and orientation of source\n\t*/\n\tvoid SetSourceTransform(CTransform _sourceTransform);\t\t    \n\t\n\t/** \\brief Get source transform (position and orientation)\n\t*\t\\retval transform current position and orientation of source\n\t*/\n\tconst CTransform & GetSourceTransform() const;\t\t\t\t    \n\n\n\t/** \\brief Set HRTF convolution method\n\t*\t\\param [in] _interpolate HRTF interpolation method (true: perform convolution in frequency domain, false: perform convolution in time domain)\n\t*/\n\tvoid SetFrequencyConvolution(bool _bFreqConvolution);\n\n\t/** \\brief Set HRTF interpolation method\n\t*\t\\param [in] _interpolate HRTF interpolation method (true: Run-time interpolation ON, false: run-time interpolation OFF)\n\t*\t\\sa GetInterpolated_HRIR\n\t*/\n\tvoid SetInterpolation(bool _bInterpolate);\n\n// Distance Model Methods\n\n\t/** \\brief Get the cutoff frequency of the long-distance filter for a given distance. \n\t*\t\\details The long-distance filter is a low-pass filter which cutoff frequency depends on distance\n\t*\t\\param [in] distance distance for checking long-distance filter cutoff\n\t*\t\\retval cutoff cutoff frequency of long-distance filter for given distance\n\t*/\n\tfloat GetCutOffFreqForFarDistances(float distance);                 \n\t                                                                    \n\t/** \\brief Get the attenuation in anechoic process for a given distance \t\n\t*\t\\param [in] distance distance for checking attenuation\n\t*\t\\retval gain attenuation, as gain (typically, between 0 and 1)\n\t*\t\\exception May throw exceptions and errors to debugger\n\t*/\n\tfloat GetAnechoicDistanceAttenuation(float distance) const;\t\t\t\n\n\t/** \\brief Get the attenuation in reverb process for a given distance\n\t*\t\\param [in] distance distance for checking attenuation\n\t*\t\\retval gain attenuation, as gain (typically, between 0 and 1)\n\t*\t\\exception May throw exceptions and errors to debugger\n\t*/\n\tfloat GetReverbDistanceAttenuation(float distance) const;\t\t\t\n\n\t/** \\brief Initialize anechoic convolvers \n\t*\t\\details Allocates memory for buffers used internally for convolution\n\t*\t\\param [in] bufferSize size of buffers used for convolution. \n\t*\t\\pre bufferSize must agree with buffer size defined in binaural core (See \\link SetAudioState \\endlink and \\link CCore \\endlink constructor)\t\n\t*/\n\tvoid SetupAnechoicConvolvers(int bufferSize);\t\t\t\t\t\t\n\n// PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nprivate:\t\t\n\tvoid PropagateSound(const CListener & listener, CStereoBuffer<float> & buffer, int bufferSize, int sampleRate);     // Applies sound propagation effects over a stereo buffer\n\t//void AddDelay(const CMonoBuffer<float> & input, int delaySize, delay_struct & signalDelay, CMonoBuffer<float> & output);\n\n// ATTRIBUTES\npublic:\n\tModulesEnabler modEnabler;                      ///< Modules can be switched on/off through this attribute (See \\link ModulesEnabler \\endlink)\n\nprivate:\t\n\tCTransform sourceTransform;\t\t\t\t\t\t// Position and orientation of source\n\tconst CCore* ownerCore;\t\t\t\t\t\t\t// Reference to the core where information shared by all sources is stored (listener, room and audio state attributes)\n\tCConvolver leftConvolution;\t\t\t\t\t\t// Time Convolution of the left channel\n\tCConvolver rightConvolution;\t\t\t\t\t// Time Convolution of the rigth channel\n\n\tCDistanceAttenuator distAttenuator;             // Computes the attenuation due to distance\n\t\t\n\tbool bInterpolate;\t\t\t\t\t\t// Vrble to activate the interpolation on run time (true) or deactivate (false)\n\tbool bFreqConvolution;\t\t\t\t\t// Vrble to activate the convolution in frequency domain\n\t\t\n\tCMonoBuffer<float> internalBuffer;\t\t// Buffer storage\n\t//Auxiliar objects to make the inverse fft of the channels\n\tCommon::CFconvolver outputLeft;   \t   // Frequency Convolution of the left channel\n\tCommon::CFconvolver outputRight;\t   // Frequency Convolution of the rigth channel\n\t\n\t//FIXME delete me\n\tbool firstTime;\n};\n    \n}\n\n#endif\n","/**\n* \\class CFconvolver\n*\n* \\brief  Declaration of CFconvolver interfaces.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#ifndef _CFCONVOLVER_H_\n#define _CFCONVOLVER_H_\n\n//#include \"Buffer.h\"\n//#include <math.h>\n#include <iostream>\n#include <vector>\n#include \"fftsg.h\"\n#include \"Buffer.h\"\n\n#ifndef THRESHOLD\n#define THRESHOLD 0.0000001f\n#endif\n\n/** \\details This class implements the necessary algorithms to do the convolution, in frequency domain, between signal and a impulse response.\n*/\n\nnamespace Common {\n\tclass CFconvolver\n\t{\n\n\tpublic:\n\n\t\t/** \\brief Default constructor\n\t\t*/\n\t\tCFconvolver();\n\n\t\t/** \\brief Initialize the class and allocate memory.\n\t\t*   \\details When this method is called, the system initializes variables and allocates memory space for the buffer.\n\t\t*\t\\param [in] _inputSize size of the input signal buffer (L size)\n\t\t*\t\\param [in] _impulseResponseSize size of the Impulse Response, which is the size of the buffer that contains the AIR or HRIR signal (P size)\n\t\t*   \\throws May throw exceptions and errors to debugger\n\t\t*/\n\t\tvoid Setup(int _inputSize, int _impulseResponseSize);\n\n\t\t/** \\brief Get the FFT of the input signal\n\t\t*   \\details This method will extend the signal with zeros at the end until reaching the size (L+P + k) = 2^n and then make the FFT.\n\t\t*\t\\param [in] inputSource_time vector containing the samples of input signal in time-domain.\n\t\t*\t\\param [out] inputSource_frequency FFT of the input signal\n\t\t*/\n\t\tstatic void GetFFT(const std::vector<float>& inputSource_time, std::vector<float>& inputSource_frequency, int _IRSize);\n\t\t\n\t\t/** \\brief Get the FFT of an impulse response\n\t\t*   \\details This method will extend the AIR with zeros at the end until reaching the size of (L+P + k) = 2^n and then make the FFT.\n\t\t*\t\\param [in] IR_time impulse response in time-domain.\n\t\t*\t\\param [out] IR_frequency FFT of the impulse response.\n\t\t*\t\\pre Size of IR_time has to agree with the size indicated by the \\link Setup \\endlink method.\n\t\t*   \\throws May throw exceptions and errors to debugger\n\t\t*/\n\t\tvoid GetFFT_IR(const CMonoBuffer<float>& IR_time, CMonoBuffer<float>& IR_frequency);\n\n\t\t/** \\brief Get the FFT of the input signal\n\t\t*   \\details This method will extend the signal with zeros at the end until reaching the size (L+P + k) = 2^n and then make the FFT.\n\t\t*\t\\param [in] inputSource_time vector containing the samples of input signal in time-domain.\n\t\t*\t\\param [out] inputSource_frequency FFT of the input signal\n\t\t*\t\\pre Size of input signal has to aagree with the size indicated by the \\link Setup \\endlink method.\n\t\t*   \\throws May throw exceptions and errors to debugger\n\t\t*/\n\t\tvoid GetFFT_Input(const std::vector<float>& inputSource_time, std::vector<float>& inputSource_frequency);\n\n\t\t/** \\brief Complex multiplication between the elements of two vectors.\n\t\t*   \\details This method makes the complex multiplication of vector samples: (a+bi)(c+di) = (ac-bd)+i(ad+bc)\n\t\t*   \\param [in] x Vector of samples that has real and imaginary parts interlaced. x[i] = Re[Xj], x[i+1] = Img[Xj]\n\t\t*   \\param [in] h Vector of samples that has real and imaginary parts interlaced. h[i] = Re[Hj], h[i+1] = Img[Hj]\n\t\t*\t\\param [out] y Complex multiplication of x and h vectors\n\t\t*\t\\pre Both vectors (x and h) have to be the same size\n\t\t*   \\throws May throw exceptions and errors to debugger\n\t\t*/\n\t\tstatic void ComplexMultiplication(const std::vector<float>& x, const std::vector<float>& h, std::vector<float>& y);\n\n\t\t/** \\brief Get the IFFT of the output signal\n\t\t*   \\details This method makesthe IFFT of the signal, adds the samples obtained with buffer samples in order to get output signal, and updates the buffer.\n\t\t*   \\param [in] signal_frequency Vector of samples storing the output signal in frecuency domain.\n\t\t*   \\param [out] signal_time Vector of samples where the IFFT of the output signal will be returned in time domain. This vector will have the size indicated in \\link Setup \\endlink method.\n\t\t*\t\\pre signal_frequency has to have the same size that the one returned by any of the GetFFT_ methods.\n\t\t*   \\throws May throw exceptions and errors to debugger\n\t\t*\t\\sa GetFFT_Input, GetFFT_IR\n\t\t*/\n\t\tvoid GetIFFT_Output(const std::vector<float>& signal_frequency, std::vector<float>& signal_time, int delayDifference);\n\t\t\n\tprivate:\n\t\t// ATTRIBUTES\t\n\t\tint inputSize;\t\t\t//Size of the inputs buffer\t\t\n\t\tint IRSize;\t\t\t\t//Size of the AmbiIR buffer\n\t\tint FFTBufferSize;\t\t//Size of the outputbuffer and zeropadding buffers\t\n\t\tdouble normalizeCoef;\t\t//Coef to normalize the Inverse FFT\n\t\tint ip_size;\t\t\t//Size of the auxiliary array ip;\n\t\tint w_size;\t\t\t\t//Size of the auxiliary array w;\t\n\t\tstd::vector<double> storageBuffer;\t\t//To store the results of the convolution\n\n\n\t\t// METHODS \t\n\t\t//This method copies the input vector into an array and insert the imaginary part.\n\t\tstatic void AddImaginaryPart(const std::vector<float>& input, std::vector<double>& output);\n\t\t//This method copy the FFT-1 output array into the storage vector, remove the imaginary part and normalize the output.\t\n\t\tbool CalculateOutputBuffer_OverlapAddMethod(std::vector<double>& input, std::vector<float>& outBuffer, int delay);\t\t\n\t\t//This method rounds to zero a value that is very close to zero.\n\t\tdouble CloseToZero(double number);\n\t\t//This method check if a number is a power of 2\n\t\tstatic bool IsPowerOfTwo(int x);\n\t\t//This method Round up to the next highest power of 2 \n\t\tstatic int NextPowerOfTwo(int v);\n\t};\n}\n#endif\n","/**\n* \\class CDistanceAttenuator\n*\n* \\brief Declaration of CDistanceAttenuator class.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#ifndef _CDISTANCE_ATTENUATOR_H_\n#define _CDISTANCE_ATTENUATOR_H_\n\n#include <Common/Buffer.h>\n#include <Common/FiltersChain.h>\n#include <BinauralSpatializer/ILD.h>\n\nclass CCore;\n\n/** \\details Applies distance effects (attenuation, far-distance low-pass filter and near-distance ILD) depending on the distance\n   from the listener to the sound source */\nclass CDistanceAttenuator\n{\t\npublic:                                                             // PUBLIC METHODS\n\n\t/** \\brief Default constructor\n\t*\t\\details Setup reference distance to 1.95 meters\n\t*/\n\tCDistanceAttenuator();\n\n\t/** \\brief Setup the distance attenuator\n\t*\t\\details Creates the low-pass filters for far-distance (currently, 1) and setup sample rate for each filter\n\t*\t\\param [in] samplingRate sampling rate, in Hertzs\n\t*/\n\tvoid Setup(int samplingRate);                                \n\n\t/** \\brief Get the attenuation gain due to distance for a given distance attenuation constant\n\t*\t\\param [in] doDistanceAttenuation if false, return 1.0 gain instead of computing distance attenuation\n\t*\t\\param [in] attenuationConstant distance attenuation constant, in decibels\n\t*\t\\param [in] distance distance, in meters\n\t*\t\\param [in] extraAttenuation_dB fixed attenuation (non distance-dependent) to be added, in decibels\n\t*\t\\exception May throw errors to debugger\n\t*/\n\tfloat GetDistanceAttenuation(bool doDistanceAttenuation, float attenuationConstant, float distance, \n\t\t                         float extraAttennuation_dB = 0) const;\n\n\t/** \\brief Process stereo input buffer to apply all distance effects (attenuation, far-distance filter and near-distance ILD)\n\t*\t\\details For use in binaural spatializer\n\t*\t\\param [in,out] buffer input and output stereo buffer\n\t*\t\\param [in] distance distance of source, in meters\n\t*\t\\param [in] attenuationConstant distance attenuation constant, in decibels\n\t*\t\\param [in] interauralAzimuthForILD interaural azimuth of source for computing near-distance ILD, in degrees\n\t*\t\\param [in] doDistanceAttenuation switch on/off distance attenuation effect\n\t*\t\\param [in] doFarDistanceLPF switch on/off far-distance low-pass filter\n\t*\t\\param [in] doILD switch on/off near-distance ILD\n\t*\t\\param [in] extraAttenuation_dB fixed attenuation (non distance-dependent) to be added, in decibels\n\t*\t\\exception May throw exceptions and errors to debugger\t\n\t*/\n\tvoid ApplyDistanceEffects( CStereoBuffer<float> & buffer, float distance, float attenuationConstant, \n\t\t                       float interauralAzimuthForILD, int bufferSize, int sampleRate,\n\t\t                       bool doDistanceAttenuation, bool doFarDistanceLPF, bool doILD, \n\t\t                       float extraAttennuation_dB = 0 );\n\n\t/** \\brief Process mono input buffer to apply all distance effects (attenuation, far-distance filter and near-distance ILD)\n\t*\t\\details For use in loudspeakers spatializer\n\t*\t\\param [in,out] buffer input and output stereo buffer\n\t*\t\\param [in] distance distance of source, in meters\n\t*\t\\param [in] attenuationConstant distance attenuation constant, in decibels\n\t*\t\\param [in] interauralAzimuthForILD interaural azimuth of source for computing near-distance ILD, in degrees\n\t*\t\\param [in] doDistanceAttenuation switch on/off distance attenuation effect\n\t*\t\\param [in] doFarDistanceLPF switch on/off far-distance low-pass filter\n\t*\t\\param [in] doILD switch on/off near-distance ILD \n\t*\t\\param [in] extraAttenuation_dB fixed attenuation (non distance-dependent) to be added, in decibels\n\t*\t\\exception May throw exceptions and errors to debugger\t\n\t*/\n\tvoid ApplyDistanceEffects( CMonoBuffer<float> & buffer, float distance,\n\t\t\t\t\t\t\t   float attenuationConstant, float interauralAzimuthForILD, int bufferSize, int sampleRate,\n\t\t\t\t\t\t\t   bool doDistanceAttenuation, bool doFarDistanceLPF, bool doILD,\n\t\t                       float extraAttennuation_dB = 0 );\n\n\t/** \\brief Get the cutoff frequency of the far-distance low-pass filter, for a given distance\n\t*\t\\param [in] distance, in meters\n\t*\t\\retval cutoff cutoff frequency, in Hertzs\n\t*/\n\tfloat GetCutOffFreqForFarDistances(float distance);             \n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\npublic:                                                             // PUBLIC ATTRIBUTES\n\n\tfloat referenceDistance;                    ///< Distance at which the attenuation is 0 dB, in meters.\n\nprivate:                                                            // PRIVATE FUNCTIONS \n\n\t// Implementation of public ApplyDistanceEffects functions.\n\tvoid ApplyDistanceEffects( CStereoBuffer<float> *bufferStereo, CMonoBuffer<float> *bufferMono,\n\t\t                       float distance, float attenuationConstant, float interauralAzimuthForILD, int bufferSize, int sampleRate,\n\t\t                       bool doDistanceAttenuation, bool doFarDistanceLPF, bool doILD,\n\t\t                       float extraAttennuation_dB );\n\t\n\tvoid ApplyGain_ExponentialMovingAverage(CStereoBuffer<float> & buffer, int gain2, float alpha);\n\nprivate:                                                            // PRIVATE ATTRIBUTES\n\n\tCFiltersChain distanceFiltersChain;     // It will be used to model the effect of the distance in the anechoic process.\n\tCILD          ILD;                      // It models the effect of distance when the sound source is close to the listener.\n\n\tfloat previousFrameAttenuation;\t\t\t\t// Store the gain applied to the previous frame\t\n\tfloat previousAttenuation_Channel1;\n\tfloat previousAttenuation_Channel2;\n};\n\n#endif\n","/**\n* \\class CConvolver\n*\n* \\brief Declaration of CConvolver interfaces.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n\n#ifndef _CCONVOLVER_H_\n#define _CCONVOLVER_H_\n\n#include <Common/Buffer.h>\n\n/** \\details This class implements the necessary algorithms to do the convolution between signal and HRIR. \n*/\nclass CConvolver\n{\n\t\npublic:\n\tCConvolver();\n\n\t/** \\brief Allocate memory space for the output buffer.\n\t*   \\details Required to store previously computed convolutions\n\t*\t\\param bufferSize size of the convolution buffer.\t\n\t*/\t\n\tvoid SetBuffer(int bufferSize);\n\t\n\t/** \\brief Set a new impulse response in the convolver\n\t*\t\\param _HRIR impulse response data. \n\t*\t\\\\param frameSize size of the input buffer signal\n\t*/\n\tvoid SetHRIR(const CMonoBuffer<float> & _HRIR, int frameSize);\t\n\n\t/** \\brief Do the convolution between the input and the stored HRIR. \n\t*\t\\param [in] input input buffer. Must have the same size of the output buffer and HRIRs\n\t*\t\\param [out] _output output buffer\n\t*\t\\param [in] channelNumber number of the channel to be processed (1-left channel, 2-right channel).\t\n\t*   \\pre Before calling this method: \n\t*   \\pre (1) Allocate memory for buffer (\\link SetBuffer \\endlink)\n\t*   \\pre (2) Set a new impulse response (\\link SetHRIR \\endlink)\n\t*   \\throws May throw exceptions and errors to debugger\n\t*\t\\sa SetBuffer, SetHRIR\n\t*/\n\tvoid Process(const CMonoBuffer<float>& input, CStereoBuffer<float> & _output, int channelNumber);\t\n\nprivate:\n\t// ATTRIBUTES\n\tCMonoBuffer<float> h;\t\t// h[n] Impulse response data.\n\tCMonoBuffer<float> buffer;\t// This will store the necessary buffer to do the convolution. If size has to be equal to h[n] length.\n\tbool firstTime;\t\t\t\t// TODO change something in order to delete this var\n\n\t// PRIVATE METHODS\n\tvoid SimpleTimeConvolver(float *input, float *h, float *output, float *buffer, \n\t\t\t\t\t\t\tconst unsigned inputLength, const unsigned hLength, \n\t\t\t\t\t\t\tconst unsigned bufferLength, int numberOfChannels, int channelNumber);\t///< Simple convolver in time domain.\n\tvoid ShiftLeft(float *myarray, int size, int shiftBy);\t\t\t\t\t\t\t\t\t\t\t///< Makes a left shift in the buffer of shiftBy positions\n};\n\n#endif","/**\n* \\class CILD\n*\n* \\brief Declaration of CILD class.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#ifndef _CILD_H_\n#define _CILD_H_\n\n#include <unordered_map>\n#include <Common/FiltersChain.h>\n#include <Common/Buffer.h>\n\n/*! \\file */\n\n/** \\brief Class to be used as Key in the hash table used by CILD\n*/\nclass CILD_Key\n{\npublic:\n\tint distance;      ///< Distance to the center of the head, in millimeters \n\tint azimuth;       ///< Azimuth angle of interaural coordinates, in degrees\n\n\tCILD_Key() :CILD_Key{ 0,0 } {}\n\n\tCILD_Key(int _distance, int _azimuth) :distance{ _distance }, azimuth{ _azimuth } {}\n\n\tbool operator==(const CILD_Key& key) const\n\t{\n\t\treturn (this->azimuth == key.azimuth && this->distance == key.distance);\n\t}\n};\n\nnamespace std\n{\n\ttemplate<>\n\tstruct hash<CILD_Key>\n\t{\n\t\t// adapted from http://en.cppreference.com/w/cpp/utility/hash\n\t\tsize_t operator()(const CILD_Key & key) const\n\t\t{\n\t\t\tsize_t h1 = std::hash<int>()(key.distance);\n\t\t\tsize_t h2 = std::hash<int>()(key.azimuth);\n\t\t\treturn h1 ^ (h2 << 1);  // exclusive or of hash functions for each int.\n\t\t}\n\t};\n}\n\n/** \\brief Template class to hold the coefficients of a set of biquad filters.\n*/\ntemplate <int NUMBER_OF_BIQUAD_FILTERS>\nclass CILD_BiquadFilterCoefs\n{\npublic:\n\tfloat coefs[5 * NUMBER_OF_BIQUAD_FILTERS];   /**< Holds the coefficients of one or more biquad filters. \n\t\t\t\t\t\t\t\t\t\t\t\t    Each biquad filter has 5 coefficients.\n\t\t\t\t\t\t\t\t\t\t\t\t    Format: f1_b0, f1_b1, f1_b2, f1_a1, f1_a2, f2_b0, f2_b1, f2_b2, f2_a1, f2_a2, ...\n\t\t\t\t\t\t\t\t\t\t\t\t        where fx means filter xth     */\n\t                                              \n};\n\n/** \\brief Type definition to work with a set of coefficients for two biquad filters\n*/\ntypedef CILD_BiquadFilterCoefs<2> CILD_TwoBiquadFilterCoefs;\n\n/** \\brief Hash table that contains a set of coefficients for two biquads filters that are indexed through a pair of distance\n and azimuth values (interaural coordinates). */\ntypedef std::unordered_map<CILD_Key, CILD_TwoBiquadFilterCoefs> ILD_HashTable;\n\n\n/** \\details Models the effect of distance when the sound source is close to the listener\n*/\nclass CILD\n{\n// METHODS\npublic:\n\n\t/** \\brief Default constructor.\n\t*\t\\details Leaves ILD Table empty. Use SetILD_HashTable to load. \n\t*/\n\tCILD(); \n\n\t/** \\brief Set the hash table for computing ILD\n\t*\t\\param [in] _ILD_Data data for hash table\n\t*/\n\tstatic void SetILD_HashTable(ILD_HashTable && _ILD_Data) { ILD_Data = _ILD_Data;  }     \n\n\t/** \\brief Get the internal hash table. \n\t*\t\\retval ILD_Data data from the hash table\n\t*/\n\tconst ILD_HashTable & GetILD_HashTable() { return ILD_Data;  }                         \n\n\t/** \\brief Applies ILD to all audio samples in buffer\n\t*\t\\param [in,out] buffer input and output buffer\n\t*\t\\param [in] distance_m distance at which audio source is located, in meters\n\t*\t\\param [in] azimuth azimuth angle at which audio source is located, in degrees\n\t*\t\\pre buffer cannot be empty\n\t*\t\\pre distance must not be zero\n\t*\t\\pre azimuth must be between -90 and 90\n\t*   \\throws May throw exceptions and errors to debugger\n\t*/\n\tvoid Process( CStereoBuffer<float> & buffer, float distance_m, float azimuth );  \n\n// PRIVATE METHODS:\nprivate:\n\n\n// ATTRIBUTES\nprivate:\n\tstatic ILD_HashTable ILD_Data;  // Global pointer to class data. FIXME: This currently allows for only one application-wide ILD table\n\tstatic int Default_ILD_AzimuthStep;\n\tstatic int Default_ILD_DistanceStep; \n\tCFiltersChain FiltersLeft, FiltersRight;\n};\n\n#endif\n","/**\n* \\class CFiltersChain\n*\n* \\brief Declaration of FiltersChain class.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#ifndef _CFILTERS_CHAIN_H_\n#define _CFILTERS_CHAIN_H_\n\n#include <Common/BiquadFilter.h>\n#include <vector>\n#include <memory>\n\nusing namespace std;  //TODO: Try to avoid this\n\n/** \\details Class to handle a set of cascade digital filters that are arranged so the samples are processed along a pipeline\n*/\nclass CFiltersChain\n{\npublic:                                                     // PUBLIC METHODS\n\n\t/** \\brief Default constructor\n\t*/\n\tCFiltersChain();\t\t\t\t\t\t\t\t\t\t\n\n\n\t/** \\brief Create and add a new CBiquadFilter object to the chain\n\t*\t\\retval filter Filter created and added to the bank\n\t*   \\throws May throw exceptions and errors to debugger\n\t*/\n    shared_ptr <CBiquadFilter> AddFilter( );                \n\n\t/** \\brief Get one filter from the chain\n\t*\t\\param [in] index ID of the filter within the chain\n\t*\t\\retval filter Filter from the chain\n\t*   \\throws May throw errors to debugger\n\t*/\n\tshared_ptr <CBiquadFilter> GetFilter( int index);       \n\n\t/** \\brief Remove all previously created filters.\n\t*/\n\tvoid RemovesFilters();                                  \n\n\t/** \\brief Process an buffer through the whole set of filters\n\t*\t\\details The buffer is processed through each filter in the bank in chain. \n\t*\t\\param [in,out] buffer input and output buffer\n\t*\t\\param [in] target which channel/s to process (See \\link TargetSamples \\endlink)\n\t*/\n\tvoid Process(CStereoBuffer<float> & buffer, TargetSamples target); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/// Applies the whole set of filters in the chain to the data\n\tvoid Process(CMonoBuffer <float> & buffer);\n\n\t/** \\brief Get the current number of filters in the chain\n\t*\t\\retval n Current number of filters in the chain\n\t*/\n\tint GetNumFilters();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    // PRIVATE METHODS\nprivate:\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// PRIVATE ATTRIBUTES\nprivate:\n\n\tvector<shared_ptr<CBiquadFilter>> filters;                      // Hold the filters in the chain. \n\t                                                                // Indexes indicate the order within the chain.\n};\n\n#endif\n","// /**\n// * \\class CCore\n// *\n// * \\brief Declaration of CCore interfaces.\n// * \\version $1.0$\n// * \\date\tJuly 2016\n// *\n// * \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n// * \\b Contact: areyes@uma.es\n// *\n// * \\b Contributions: (additional authors/contributors can be added here)\n// *\n// * \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n// * \\b Website: http://3d-tune-in.eu/\n// *\n// * \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n// *\n// * \\b License: (insert agreed license terms here)\n// *\n// */\n\n#ifndef _CCORE_H_\n#define _CCORE_H_\n\n#include <BinauralSpatializer/HRTF.h>\n#include <Common/Transform.h>\n#include <Common/AudioState.h>\n#include <BinauralSpatializer/SingleSourceDSP.h>\n#include <Common/Magnitudes.h>\n#include <Common/AIR.h>\n#include <Common/Buffer.h>\n#include <Common/Fconvolver.h>\n#include <vector>\n#include <memory>\n\n\nusing namespace std;  //TODO: Try to avoid this\n\nnamespace Binaural {\n\n    class CSingleSourceDSP;\n    class CListener;\n    class CEnvironment;\n    \n\n/** \\details Class for centralization of several funtionalities of the binaural spatializer, such as handling sound sources, audio state, listener and environment.\n*/\nclass CCore\n{\n// METHODS\npublic:\n\n\t/** \\brief Constructor with parameters\n\t*\t\\param [in] _audioState audio state configuration (See \\link AudioState \\endlink)\n\t*\t\\param [in] _listenerHeadRadius listener head radius for ITD customization, in meters\n\t*/\n\tCCore(AudioState_Struct _audioState);\n\n\t/** \\brief Default constructor \n\t*\t\\details By default, sets sampling frequency to 44100Hz, buffer size to 512, and listenerHeadRadius to 0.0875 meters. \n\t*/\n\tCCore();\n\n//\n// General purpose methods\t\n//\n\n\t/** \\brief Get global audio state\n\t*\t\\retval audioState currently set audio state\n\t*/\n\tAudioState_Struct GetAudioState() const;\n\n\t/** \\brief Set global audio state\n\t*\t\\param [in] _audioState audio state to set\n\t*/\n\tvoid SetAudioState(AudioState_Struct _audioState);\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get global physical magnitudes\n\t*\t\\retval magnitudes currently set physical magnitudes\n\t*/\n\tCMagnitudes GetMagnitudes() const;\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set global physical magnitudes\n\t*\t\\param [in] _magnitudes physical magnitudes to set\n\t*/\n\tvoid SetMagnitudes(CMagnitudes _magnitudes);\t\n\n//\n// Listener methods\n//\n\n    /** \\brief Creates a new listener\n     *\t\\retval source shared pointer to newly created listener with empty HRTF.\n     */\n    shared_ptr<CListener> CreateListener(float listenerHeadRadius = 0.0875f);\n    \n    /** \\brief Removes one listener udio source for spatialization\n     *\t\\param [in] listener shared pointer to remove\n     */\n    void RemoveListener(shared_ptr<CListener> listener);\n\n    \n//\n// Environment methods\n//\n\n    /** \\brief Creates a new environment\n     *\t\\retval source shared pointer to newly created environment with empty ABIR.\n     */\n    shared_ptr<CEnvironment> CreateEnvironment();\n    \n    /** \\brief Removes one environment\n     *\t\\param [in] environment shared pointer  to remove\n     */\n    void RemoveEnvironment(shared_ptr<CEnvironment> listener);\n\n//\n// Audio source methods\n//\n    \n    /** \\brief Creates a new audio source for spatialization\n     *\t\\retval source shared pointer to newly created audio source\n     *\t\\note This method is implemented in \\link CoreState \\endlink\n     */\n    shared_ptr<CSingleSourceDSP> CreateSingleSourceDSP();\n    \n    /** \\brief Removes one audio source for spatialization\n     *\t\\param [in] source shared pointer of audio source to remove\n     *\t\\note This method is implemented in \\link CoreState \\endlink\n     */\n    void RemoveSingleSourceDSP(shared_ptr<CSingleSourceDSP> source);\n\n\n// ATTRIBUTES\nprivate:\n\n\t// Listener attributes\n    vector<shared_ptr<CListener>> listeners;\n\t// Environment attributes\n    vector<shared_ptr<CEnvironment>> environments;\n \n\t// General attributes\n\tAudioState_Struct audioState;\t\t\t\t\t// Global audio state\n\tCMagnitudes magnitudes;\t\t\t\t\t// Physical magnitudes\n\n\t// List of audio sources \n\tvector<shared_ptr<CSingleSourceDSP>> audioSources;\n\n\t// Friend class State\n    friend class CEnvironment;\n};\n\n}\n\n#endif","/*\n* \\class CBiquadFilter\n*\n* \\brief Definition of BiquadFilter class.\n*\n* Class to implement a Biquad Digital Filter\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: February 2016\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n#include <Common/BiquadFilter.h>\n#include <Common/BiquadFilter.h>\n#include <math.h>\n\n#ifndef M_PI \n#define M_PI 3.1415926535 \n#endif\n\n#define DEFAULT_SAMPLING_RATE 44100\n\n//////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\nCBiquadFilter::CBiquadFilter( )\n{\n\tInit( DEFAULT_SAMPLING_RATE );\n}\n\nCBiquadFilter::CBiquadFilter(double _samplingFreq)\n{\n\tInit(_samplingFreq);\n}\n\n//////////////////////////////////////////////\nvoid CBiquadFilter::Init(float _samplingFreq)\n{\n\t// DEBUGGER: Trust in SetSamplingFreq for result\n\n\tz1_l = 0;\n\tz2_l = 0;\n\tz1_r = 0;\n\tz2_r = 0;\n\n\tgeneralGain = 1.0f;\n\n\tSetSamplingFreq(_samplingFreq);\n}\n\n//////////////////////////////////////////////\nvoid CBiquadFilter::SetSamplingFreq( float _samplingFreq )\n{\n\tif (_samplingFreq < 0.1)\n\t{\n\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Sampling frequency for biquad filter is invalid\");\n\t\treturn;\n\t}\n\n\tSET_RESULT(RESULT_OK, \"Sampling frequency for biquad filter succesfully set\");\n\tsamplingFreq = _samplingFreq;\n}\n\n//////////////////////////////////////////////\nbool CBiquadFilter::SetCoefsFor_ButterworthFilter(double cutoffFreq)\n{\n\tif (samplingFreq < 0.1 || cutoffFreq > samplingFreq / 2.0) // To prevent aliasing problems\n\t{\n\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Cutoff frequency of biquad (butterworth) filter is higher than Nyquist frequency\");\n\t\treturn false;\n\t}\n\n\tdouble freqRatio = cutoffFreq / samplingFreq;\n\n\tdouble ita = 1.0 / tan(M_PI * freqRatio);\n\n\tconst double q = sqrt(2.0);\n\n\tdouble den = (1.0 + q*ita + ita*ita);\n\n\tif (fabs(den) < 0.0000001)\n\t{\n\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Bad ratio between cutoff and sampling frequency in biquad (butterworth) filter\");\n\t\treturn false;\n\t}\n\n\tb0   = 1.0 / den;\n\tb1   = 2 * b0;\n\tb2   = b0;\n\ta1   = -  2.0 * (ita*ita - 1.0)  * b0;\n\ta2   =   (1.0 - q*ita + ita*ita) * b0;\n\n\tSET_RESULT(RESULT_OK, \"Butterworth filter coefficients of biquad filter succesfully set\");\n\n\treturn true;\n}\n\n//////////////////////////////////////////////\nbool CBiquadFilter::SetCoefsFor_BandPassFilter( double centerFreqHz, double Q )\n{\n\tif (samplingFreq < 0.1 || Q < 0.0000001 || centerFreqHz > samplingFreq / 2.0) // To prevent aliasing problems\n\t{\n\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Cutoff frequency of biquad (bandpass) filter is higher than Nyquist frequency\");\n\t\treturn false;\n\t}\n\n\ttry // -> To handle division by 0\n\t{\n\t\tdouble K = tan(M_PI * centerFreqHz / samplingFreq);\n\n\t\tdouble norm = 1 / (1 + K / Q + K * K);\n\t\tb0 = K / Q * norm;\n\t\tb1 = 0;\n\t\tb2 = -b0;\n\t\ta1 =     2 * (K * K - 1) * norm;\n\t\ta2 = (1 - K / Q + K * K) * norm;\n\n\t\tSET_RESULT(RESULT_OK, \"Bandpass filter coefficients of biquad filter succesfully set\");\n\n\t\treturn true;\n\t}\n\tcatch(exception e) \n\t{\n\t\t//SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"\");\n\t\tSET_RESULT(RESULT_ERROR_DIVBYZERO, \"Division by zero setting coefficients for bandpass biquad filter\");\n\t\treturn false;\n\t}\t\t\n}\n\n\n//////////////////////////////////////////////\nbool CBiquadFilter::SetCoefsFor_LPF( double cutoffFreq, double Q)\n{\n\tif (samplingFreq < 0.1 || cutoffFreq > samplingFreq / 2.0) // To prevent aliasing problems\n\t{\n\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Cutoff frequency of biquad (LPF) filter is higher than Nyquist frequency\");\n\t\treturn false;\n\t}\n\n\ttry // -> To handle division by 0\n\t{\n\t\tdouble K = tan(M_PI * cutoffFreq / samplingFreq);\n\n\t\tdouble norm = 1 / (1 + K / Q + K * K);\n\t\tb0 = K * K * norm;\n\t\tb1 = 2 * b0;\n\t\tb2 = b0;\n\t\ta1 = 2 * (K * K - 1) * norm;\n\t\ta2 = (1 - K / Q + K * K) * norm;\n\n\t\tSET_RESULT(RESULT_OK, \"LPF filter coefficients of biquad filter succesfully set\");\n\n\t\treturn true;\n\t}\n\tcatch(exception e) \n\t{\n\t\t//SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"\");\n\t\tSET_RESULT(RESULT_ERROR_DIVBYZERO, \"Division by zero setting coefficients for LPF biquad filter\");\n\t\treturn false;\n\t}\t\t\n}\n\n\n//////////////////////////////////////////////\nbool CBiquadFilter::SetCoefsFor_HPF(double cutoffFreq, double Q)\n{\n\tif (samplingFreq < 0.1 || cutoffFreq > samplingFreq / 2.0) // To prevent aliasing problems\n\t{\n\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Cutoff frequency of biquad (HPF) filter is higher than Nyquist frequency\");\n\t\treturn false;\n\t}\n\n\ttry // -> To handle division by 0\n\t{\n\t\tdouble K = tan(M_PI * cutoffFreq / samplingFreq);\n\n\t\tdouble norm = 1 / (1 + K / Q + K * K);\n\t\tb0 = 1 * norm;\n\t\tb1 = -2 * b0;\n\t\tb2 = b0;\n\t\ta1 = 2 * (K * K - 1) * norm;\n\t\ta2 = (1 - K / Q + K * K) * norm;\n\n\t\tSET_RESULT(RESULT_OK, \"HPF filter coefficients of biquad filter succesfully set\");\n\n\t\treturn true;\n\t}\n\tcatch (exception e)\n\t{\n\t\t//SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"\");\n\t\tSET_RESULT(RESULT_ERROR_DIVBYZERO, \"Division by zero setting coefficients for HPF biquad filter\");\n\t\treturn false;\n\t}\n}\n\n//////////////////////////////////////////////\nvoid CBiquadFilter::SetCoefs(float coefs[5])\n{\n\t//SET_RESULT(RESULT_OK, \"\");\n\tb0 = coefs[0];\n\tb1 = coefs[1];\n\tb2 = coefs[2]; \n\ta1 = coefs[3];\n\ta2 = coefs[4];\n}\n\n//////////////////////////////////////////////\n\nvoid CBiquadFilter::SetCoefs(float _b0, float _b1, float _b2, float _a1, float _a2)\n{\n\t//SET_RESULT(RESULT_OK, \"\");\n\tb0 = _b0;\n\tb1 = _b1;\n\tb2 = _b2;\n\ta1 = _a1;\n\ta2 = _a2;\n}\n\n//////////////////////////////////////////////\nvoid CBiquadFilter::Process( CStereoBuffer<float> & buffer, TargetSamples target )\n{\n\tint size = buffer.size();\n\n\tif (size <= 0 )\n\t{\n\t\t//SET_RESULT(RESULT_ERROR_INVALID_PARAM,\"The buffer is empty\");\n\t\tSET_RESULT(RESULT_ERROR_BADSIZE, \"Attempt to process a biquad filter with an empty input buffer\");\n\t\treturn;\n\t}\n\n\t//SET_RESULT(RESULT_OK, \"Biquad filter process succesfull\");\n\n\t// This is expression of the biquad filter but the implementation follows a more efficient\n\t// approach in which only 2 delays cells are used.\n\t//   See schemes in: https://en.wikipedia.org/wiki/Digital_biquad_filter\n\t//   y(n) = b0.x(n) + b1.x(n-1) + b2.x(n-2) + a1.y(n-1) + a2.y(n-2) \t\n\n\tbool left  = ( target == TARGET_SAMPLES_LEFT  || target == TARGET_SAMPLES_BOTH );\n\tbool right = ( target == TARGET_SAMPLES_RIGHT || target == TARGET_SAMPLES_BOTH );\n\t\t\n\tfor (int c = 0; c < size; c += 2)\n\t{\n\t\tif (left)\n\t\t{\n\t\t\tdouble m_l = buffer[c] - a1 * z1_l - a2 * z2_l;\n\t\t\tbuffer[c] = generalGain * (float)(b0 * m_l + b1 * z1_l + b2 * z2_l);\n\t\t\tz2_l = z1_l;\n\t\t\tz1_l = m_l;\n\t\t}\n\n\t\tif (right)\n\t\t{\n\t\t\tdouble m_r = buffer[c + 1] - a1 * z1_r - a2 * z2_r;\n\t\t\tbuffer[c + 1] = generalGain * (float)(b0 * m_r + b1 * z1_r + b2 * z2_r);\n\t\t\tz2_r = z1_r;\n\t\t\tz1_r = m_r;\n\t\t}\n\t}\n\tAvoidNanValues();\n}\n\n//////////////////////////////////////////////\nvoid CBiquadFilter::Process( CStereoBuffer<float> &  inBuffer, CStereoBuffer<float> & outBuffer, \n\t\t                     TargetSamples target, bool addResult)\n{\n\tint size = inBuffer.size();\n\n\tif (size <= 0)\n\t{\n\t\t//SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"The input buffer is empty\");\n\t\tSET_RESULT(RESULT_ERROR_BADSIZE, \"Attempt to process a biquad filter with an empty input buffer\");\n\t\treturn;\n\t}\n\telse if( size != outBuffer.size() )\n\t{\n\t\t//SET_RESULT( RESULT_ERROR_INVALID_PARAM, \"Input and output buffers size must agree\" );\n\t\tSET_RESULT(RESULT_ERROR_BADSIZE, \"Attempt to process a biquad filter with different sizes for input and output buffers\");\n\t\treturn;\n\t}\n\n\t//SET_RESULT(RESULT_OK, \"\");\n\n\t// This is expression of the biquad filter but the implementation follows a more efficient\n\t// approach in which only 2 delays cells are used.\n\t//   See schemes in: https://en.wikipedia.org/wiki/Digital_biquad_filter\n\t//   y(n) = b0.x(n) + b1.x(n-1) + b2.x(n-2) + a1.y(n-1) + a2.y(n-2) \t\n\n\tbool left  = (target == TARGET_SAMPLES_LEFT  || target == TARGET_SAMPLES_BOTH);\n\tbool right = (target == TARGET_SAMPLES_RIGHT || target == TARGET_SAMPLES_BOTH);\n\t\t\n\tfor (int c = 0; c < size; c += 2)\n\t{\n\t\tif (left)\n\t\t{\n\t\t\tdouble m_l = inBuffer[c] - a1 * z1_l - a2 * z2_l;\n\t\t\tdouble res = generalGain * (float)(b0 * m_l + b1 * z1_l + b2 * z2_l);\n\t\t\toutBuffer[c] = addResult ? outBuffer[c]  + res : res;\n\t\t\tz2_l = z1_l;\n\t\t\tz1_l = m_l;\n\t\t}\n\n\t\tif (right)\n\t\t{\n\t\t\tdouble m_r = inBuffer[c + 1] - a1 * z1_r - a2 * z2_r;\n\t\t\tdouble res = generalGain * (float)(b0 * m_r + b1 * z1_r + b2 * z2_r);\n\t\t\toutBuffer[c+1] = addResult ? outBuffer[c+1] + res : res;\n\t\t\tz2_r = z1_r;\n\t\t\tz1_r = m_r;\n\t\t}\n\t}\n\tAvoidNanValues();\n}\n//////////////////////////////////////////////\nvoid CBiquadFilter::Process(CMonoBuffer<float> &buffer)\n{\n\tint size = buffer.size();\n\n\tif (size <= 0)\n\t{\n\t\tSET_RESULT(RESULT_ERROR_BADSIZE, \"Attempt to process a biquad filter with an empty input buffer\");\n\t\treturn;\n\t}\n\n\t//SET_RESULT(RESULT_OK, \"Biquad filter process succesfull\");\n\n\t// This is expression of the biquad filter but the implementation follows a more efficient\n\t// approach in which only 2 delays cells are used.\n\t//   See schemes in: https://en.wikipedia.org/wiki/Digital_biquad_filter\n\t//   y(n) = b0.x(n) + b1.x(n-1) + b2.x(n-2) + a1.y(n-1) + a2.y(n-2) \t\n\n\tfor (int c = 0; c < size; c++)\n\t{\n\t\tdouble m_l = buffer[c] - a1 * z1_l - a2 * z2_l;\n\t\tbuffer[c] = generalGain * (float)(b0 * m_l + b1 * z1_l + b2 * z2_l);\n\t\tz2_l = z1_l;\n\t\tz1_l = m_l;\n\t}\n\n\tAvoidNanValues();\n}\n//////////////////////////////////////////////\nvoid CBiquadFilter::AvoidNanValues()\n{\n\t// FIXME: IIRs filters can eventually end up in a non stable state that can lead the filter output\n\t//      to +/-Inf. To prevent this situation we reset the delay cells of the filter when this happens.\n\t//    A known scenario in whinch this happens is this: In the binaural test app when two sound sources\n\t//   are played at the same time using anechoic an reverb and one of the sourcers is moved beyond the \n\t//   far distances threshold, the LPF of the distances can end up with this unstable state.\n#ifndef UNITY_ANDROID\n\tif (isnan(z1_l)) z1_l = 0;\n\tif (isnan(z2_l)) z2_l = 0;\n\tif (isnan(z1_r)) z1_r = 0;\n\tif (isnan(z2_r)) z2_r = 0;\n#else\n\tif (std::isnan(z1_l)) z1_l = 0;\n\tif (std::isnan(z2_l)) z2_l = 0;\n\tif (std::isnan(z1_r)) z1_r = 0;\n\tif (std::isnan(z2_r)) z2_r = 0;\n#endif\n}\n","#ifndef _MATH_H\n#define _MATH_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <features.h>\n\n#define __NEED_float_t\n#define __NEED_double_t\n#include <bits/alltypes.h>\n\n#if 100*__GNUC__+__GNUC_MINOR__ >= 303\n#define NAN       __builtin_nanf(\"\")\n#define INFINITY  __builtin_inff()\n#else\n#define NAN       (0.0f/0.0f)\n#define INFINITY  1e5000f\n#endif\n\n#define HUGE_VALF INFINITY\n#define HUGE_VAL  ((double)INFINITY)\n#define HUGE_VALL ((long double)INFINITY)\n\n#define MATH_ERRNO  1\n#define MATH_ERREXCEPT 2\n#define math_errhandling 2\n\n#define FP_ILOGBNAN (-1-(int)(((unsigned)-1)>>1))\n#define FP_ILOGB0 FP_ILOGBNAN\n\n#define FP_NAN       0\n#define FP_INFINITE  1\n#define FP_ZERO      2\n#define FP_SUBNORMAL 3\n#define FP_NORMAL    4\n\nint __fpclassify(double);\nint __fpclassifyf(float);\nint __fpclassifyl(long double);\n\nstatic __inline unsigned __FLOAT_BITS(float __f)\n{\n\tunion {float __f; unsigned __i;} __u;\n\t__u.__f = __f;\n\treturn __u.__i;\n}\nstatic __inline unsigned long long __DOUBLE_BITS(double __f)\n{\n\tunion {double __f; unsigned long long __i;} __u;\n\t__u.__f = __f;\n\treturn __u.__i;\n}\n\n#define fpclassify(x) ( \\\n\tsizeof(x) == sizeof(float) ? __fpclassifyf(x) : \\\n\tsizeof(x) == sizeof(double) ? __fpclassify(x) : \\\n\t__fpclassifyl(x) )\n\n#define isinf(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) == 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) == 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) == FP_INFINITE)\n\n#define isnan(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) > 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) == FP_NAN)\n\n#define isnormal(x) ( \\\n\tsizeof(x) == sizeof(float) ? ((__FLOAT_BITS(x)+0x00800000) & 0x7fffffff) >= 0x01000000 : \\\n\tsizeof(x) == sizeof(double) ? ((__DOUBLE_BITS(x)+(1ULL<<52)) & -1ULL>>1) >= 1ULL<<53 : \\\n\t__fpclassifyl(x) == FP_NORMAL)\n\n#define isfinite(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) < 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) < 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) > FP_INFINITE)\n\nint __signbit(double);\nint __signbitf(float);\nint __signbitl(long double);\n\n#define signbit(x) ( \\\n\tsizeof(x) == sizeof(float) ? (int)(__FLOAT_BITS(x)>>31) : \\\n\tsizeof(x) == sizeof(double) ? (int)(__DOUBLE_BITS(x)>>63) : \\\n\t__signbitl(x) )\n\n#define isunordered(x,y) (isnan((x)) ? ((void)(y),1) : isnan((y)))\n\n#define __ISREL_DEF(rel, op, type) \\\nstatic __inline int __is##rel(type __x, type __y) \\\n{ return !isunordered(__x,__y) && __x op __y; }\n\n__ISREL_DEF(lessf, <, float_t)\n__ISREL_DEF(less, <, double_t)\n__ISREL_DEF(lessl, <, long double)\n__ISREL_DEF(lessequalf, <=, float_t)\n__ISREL_DEF(lessequal, <=, double_t)\n__ISREL_DEF(lessequall, <=, long double)\n__ISREL_DEF(lessgreaterf, !=, float_t)\n__ISREL_DEF(lessgreater, !=, double_t)\n__ISREL_DEF(lessgreaterl, !=, long double)\n__ISREL_DEF(greaterf, >, float_t)\n__ISREL_DEF(greater, >, double_t)\n__ISREL_DEF(greaterl, >, long double)\n__ISREL_DEF(greaterequalf, >=, float_t)\n__ISREL_DEF(greaterequal, >=, double_t)\n__ISREL_DEF(greaterequall, >=, long double)\n\n#define __tg_pred_2(x, y, p) ( \\\n\tsizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \\\n\tsizeof((x)+(y)) == sizeof(double) ? p(x, y) : \\\n\tp##l(x, y) )\n\n#define isless(x, y)            __tg_pred_2(x, y, __isless)\n#define islessequal(x, y)       __tg_pred_2(x, y, __islessequal)\n#define islessgreater(x, y)     __tg_pred_2(x, y, __islessgreater)\n#define isgreater(x, y)         __tg_pred_2(x, y, __isgreater)\n#define isgreaterequal(x, y)    __tg_pred_2(x, y, __isgreaterequal)\n\ndouble      acos(double);\nfloat       acosf(float);\nlong double acosl(long double);\n\ndouble      acosh(double);\nfloat       acoshf(float);\nlong double acoshl(long double);\n\ndouble      asin(double);\nfloat       asinf(float);\nlong double asinl(long double);\n\ndouble      asinh(double);\nfloat       asinhf(float);\nlong double asinhl(long double);\n\ndouble      atan(double);\nfloat       atanf(float);\nlong double atanl(long double);\n\ndouble      atan2(double, double);\nfloat       atan2f(float, float);\nlong double atan2l(long double, long double);\n\ndouble      atanh(double);\nfloat       atanhf(float);\nlong double atanhl(long double);\n\ndouble      cbrt(double);\nfloat       cbrtf(float);\nlong double cbrtl(long double);\n\ndouble      ceil(double);\nfloat       ceilf(float);\nlong double ceill(long double);\n\ndouble      copysign(double, double);\nfloat       copysignf(float, float);\nlong double copysignl(long double, long double);\n\ndouble      cos(double);\nfloat       cosf(float);\nlong double cosl(long double);\n\ndouble      cosh(double);\nfloat       coshf(float);\nlong double coshl(long double);\n\ndouble      erf(double);\nfloat       erff(float);\nlong double erfl(long double);\n\ndouble      erfc(double);\nfloat       erfcf(float);\nlong double erfcl(long double);\n\ndouble      exp(double);\nfloat       expf(float);\nlong double expl(long double);\n\ndouble      exp2(double);\nfloat       exp2f(float);\nlong double exp2l(long double);\n\ndouble      expm1(double);\nfloat       expm1f(float);\nlong double expm1l(long double);\n\ndouble      fabs(double);\nfloat       fabsf(float);\nlong double fabsl(long double);\n\ndouble      fdim(double, double);\nfloat       fdimf(float, float);\nlong double fdiml(long double, long double);\n\ndouble      floor(double);\nfloat       floorf(float);\nlong double floorl(long double);\n\ndouble      fma(double, double, double);\nfloat       fmaf(float, float, float);\nlong double fmal(long double, long double, long double);\n\ndouble      fmax(double, double);\nfloat       fmaxf(float, float);\nlong double fmaxl(long double, long double);\n\ndouble      fmin(double, double);\nfloat       fminf(float, float);\nlong double fminl(long double, long double);\n\ndouble      fmod(double, double);\nfloat       fmodf(float, float);\nlong double fmodl(long double, long double);\n\ndouble      frexp(double, int *);\nfloat       frexpf(float, int *);\nlong double frexpl(long double, int *);\n\ndouble      hypot(double, double);\nfloat       hypotf(float, float);\nlong double hypotl(long double, long double);\n\nint         ilogb(double);\nint         ilogbf(float);\nint         ilogbl(long double);\n\ndouble      ldexp(double, int);\nfloat       ldexpf(float, int);\nlong double ldexpl(long double, int);\n\ndouble      lgamma(double);\nfloat       lgammaf(float);\nlong double lgammal(long double);\n\nlong long   llrint(double);\nlong long   llrintf(float);\nlong long   llrintl(long double);\n\nlong long   llround(double);\nlong long   llroundf(float);\nlong long   llroundl(long double);\n\ndouble      log(double);\nfloat       logf(float);\nlong double logl(long double);\n\ndouble      log10(double);\nfloat       log10f(float);\nlong double log10l(long double);\n\ndouble      log1p(double);\nfloat       log1pf(float);\nlong double log1pl(long double);\n\ndouble      log2(double);\nfloat       log2f(float);\nlong double log2l(long double);\n\ndouble      logb(double);\nfloat       logbf(float);\nlong double logbl(long double);\n\nlong        lrint(double);\nlong        lrintf(float);\nlong        lrintl(long double);\n\nlong        lround(double);\nlong        lroundf(float);\nlong        lroundl(long double);\n\ndouble      modf(double, double *);\nfloat       modff(float, float *);\nlong double modfl(long double, long double *);\n\ndouble      nan(const char *);\nfloat       nanf(const char *);\nlong double nanl(const char *);\n\ndouble      nearbyint(double);\nfloat       nearbyintf(float);\nlong double nearbyintl(long double);\n\ndouble      nextafter(double, double);\nfloat       nextafterf(float, float);\nlong double nextafterl(long double, long double);\n\ndouble      nexttoward(double, long double);\nfloat       nexttowardf(float, long double);\nlong double nexttowardl(long double, long double);\n\ndouble      pow(double, double);\nfloat       powf(float, float);\nlong double powl(long double, long double);\n\ndouble      remainder(double, double);\nfloat       remainderf(float, float);\nlong double remainderl(long double, long double);\n\ndouble      remquo(double, double, int *);\nfloat       remquof(float, float, int *);\nlong double remquol(long double, long double, int *);\n\ndouble      rint(double);\nfloat       rintf(float);\nlong double rintl(long double);\n\ndouble      round(double);\nfloat       roundf(float);\nlong double roundl(long double);\n\ndouble      scalbln(double, long);\nfloat       scalblnf(float, long);\nlong double scalblnl(long double, long);\n\ndouble      scalbn(double, int);\nfloat       scalbnf(float, int);\nlong double scalbnl(long double, int);\n\ndouble      sin(double);\nfloat       sinf(float);\nlong double sinl(long double);\n\ndouble      sinh(double);\nfloat       sinhf(float);\nlong double sinhl(long double);\n\ndouble      sqrt(double);\nfloat       sqrtf(float);\nlong double sqrtl(long double);\n\ndouble      tan(double);\nfloat       tanf(float);\nlong double tanl(long double);\n\ndouble      tanh(double);\nfloat       tanhf(float);\nlong double tanhl(long double);\n\ndouble      tgamma(double);\nfloat       tgammaf(float);\nlong double tgammal(long double);\n\ndouble      trunc(double);\nfloat       truncf(float);\nlong double truncl(long double);\n\n\n#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE)\n#undef  MAXFLOAT\n#define MAXFLOAT        3.40282346638528859812e+38F\n#endif\n\n#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\n#define M_E             2.7182818284590452354   /* e */\n#define M_LOG2E         1.4426950408889634074   /* log_2 e */\n#define M_LOG10E        0.43429448190325182765  /* log_10 e */\n#define M_LN2           0.69314718055994530942  /* log_e 2 */\n#define M_LN10          2.30258509299404568402  /* log_e 10 */\n#define M_PI            3.14159265358979323846  /* pi */\n#define M_PI_2          1.57079632679489661923  /* pi/2 */\n#define M_PI_4          0.78539816339744830962  /* pi/4 */\n#define M_1_PI          0.31830988618379067154  /* 1/pi */\n#define M_2_PI          0.63661977236758134308  /* 2/pi */\n#define M_2_SQRTPI      1.12837916709551257390  /* 2/sqrt(pi) */\n#define M_SQRT2         1.41421356237309504880  /* sqrt(2) */\n#define M_SQRT1_2       0.70710678118654752440  /* 1/sqrt(2) */\n\nextern int signgam;\n\ndouble      j0(double);\ndouble      j1(double);\ndouble      jn(int, double);\n\ndouble      y0(double);\ndouble      y1(double);\ndouble      yn(int, double);\n#endif\n\n#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\n#define HUGE            3.40282346638528859812e+38F\n\ndouble      drem(double, double);\nfloat       dremf(float, float);\n\nint         finite(double);\nint         finitef(float);\n\ndouble      scalb(double, double);\nfloat       scalbf(float, float);\n\ndouble      significand(double);\nfloat       significandf(float);\n\ndouble      lgamma_r(double, int*);\nfloat       lgammaf_r(float, int*);\n\nfloat       j0f(float);\nfloat       j1f(float);\nfloat       jnf(int, float);\n\nfloat       y0f(float);\nfloat       y1f(float);\nfloat       ynf(int, float);\n#endif\n\n#ifdef _GNU_SOURCE\nlong double lgammal_r(long double, int*);\n\nvoid        sincos(double, double*, double*);\nvoid        sincosf(float, float*, float*);\nvoid        sincosl(long double, long double*, long double*);\n\ndouble      exp10(double);\nfloat       exp10f(float);\nlong double exp10l(long double);\n\ndouble      pow10(double);\nfloat       pow10f(float);\nlong double pow10l(long double);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/*\n* \\class CDebugger\n*\n* \\brief Definition of CDebugger class.\n*\n* Debugger class for error reporting and watching variables.\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: January 2016\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n\n#include <Common/Debugger.h>\n\n#if defined (SWITCH_ON_3DTI_DEBUGGER) || defined(_3DTI_ANDROID_DEBUGGER)\n\n//////////////////////////////////////////////////////////\n// Last result reporting\n\n\t// Generic method for obtaining description and suggestions of a result ID\n\tvoid CDebugger::GetDescriptionAndSuggestion(TDebuggerResultID result, string& description, string& suggestion)\n\t{\n\t\t// Set specific strings for each error type. Suggestions are generic and might be replaced with the one specified when calling to SetResult\n\t\tswitch (result)\n\t\t{\n\t\t\tcase RESULT_OK: { description = \"OK\"; suggestion = \"Nothing to do\"; break;  }\n\t\t\tcase RESULT_ERROR_UNKNOWN: { description = \"Unknown error\"; suggestion = \"There are no specific details about this error type\"; break;  }\n\t\t\tcase RESULT_ERROR_NOTSET: { description = \"Value not set\"; suggestion = \"Tried to use a parameter and its value was not set\"; break;  }\n\t\t\tcase RESULT_ERROR_BADALLOC: { description = \"Memory allocation failure\"; suggestion = \"Bad alloc exception thrown using New\"; break;  }\n\t\t\tcase RESULT_ERROR_NULLPOINTER: { description = \"Null pointer\"; suggestion = \"Attempt to use a null pointer\"; break;  }\n\t\t\tcase RESULT_ERROR_DIVBYZERO: { description = \"Division by zero\"; suggestion = \"\"; break;  }\n\t\t\tcase RESULT_ERROR_CASENOTDEFINED: { description = \"Case not defined\"; suggestion = \"A switch statement went through an unexpected default case\"; break;  }\n\t\t\tcase RESULT_ERROR_PHYSICS: { description = \"Violation of physics\"; suggestion = \"You tried to do something which is not physically correct\"; break;  }\n\t\t\tcase RESULT_ERROR_OUTOFRANGE: { description = \"Out of range\"; suggestion = \"Trying to access an array or vector position outside its size\"; break;  }\n\t\t\tcase RESULT_ERROR_BADSIZE: { description = \"Bad size\"; suggestion = \"Trying to fill a data structure with a bad size\"; break;  }\n\t\t\tcase RESULT_ERROR_NOTINITIALIZED: { description = \"Not initialized\"; suggestion = \"Using or returning a value which was not initialized\"; break;  }\n\t\t\tcase RESULT_ERROR_INVALID_PARAM: { description = \"Invalid parameter\"; suggestion = \"One or more parameters passed to a method have an incorrect value\"; break;  }\n\t\t\tcase RESULT_ERROR_SYSTEMCALL: { description = \"Error in System Call\"; suggestion = \"Some platform-specific system call returned an error\"; break;  }\n\t\t\tcase RESULT_ERROR_NOTALLOWED: { description = \"Not allowed\"; suggestion = \"Attempt to do something which is not allowed in the current context\"; break;  }\n\t\t\tcase RESULT_ERROR_NOTIMPLEMENTED: { description = \"Not implemented yet\"; suggestion = \"Call to a method not implemented yet in this version of the toolkit core\"; break;  }\n\t\t\tcase RESULT_WARNING: { description = \"Warning!\"; suggestion = \"This is not an error, only a warning\"; break;  }\n\t\t\tdefault: { description = \"Unknown error type\"; suggestion = \"The debugger was not properly used for setting result\"; }\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Returns a struct with the last result info\n\tTDebuggerResultStruct CDebugger::GetLastResultStruct()\n\t{\n\t\treturn lastResult;\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Returns just the ID of the last error\n\tTDebuggerResultID CDebugger::GetLastResult()\n\t{\n\t\treturn lastResult.id;\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Set error value of last operation\n\tvoid CDebugger::SetResult(TDebuggerResultID resultID, string suggestion, string filename, int linenumber)\n\t{\n\t\tif (assertMode != ASSERT_MODE_EMPTY)\t// Alternative: put this before logging to file\n\t\t{\n\t\t\tlock_guard<mutex> lock(debugMutex);\n\n\t\t\t// Set result struct\n\n\t\t\tlastResult.id = resultID;\n\t\t\tlastResult.linenumber = linenumber;\n\t\t\tlastResult.filename = filename;\n\n\t\t\t// Set specific strings for each result type. Suggestions are generic and might be replaced with the one specified\n\t\t\tstring defaultDescription, defaultSuggestion;\n\t\t\tGetDescriptionAndSuggestion(lastResult.id, defaultDescription, defaultSuggestion);\n\t\t\tlastResult.description = defaultDescription;\n\n\t\t\t// Replace default suggestion with the provided one, if it was specified\n\t\t\tif (suggestion != \"\")\n\t\t\t\tlastResult.suggestion = suggestion;\n\t\t\telse\n\t\t\t\tlastResult.suggestion = defaultSuggestion;\n\n\t\t\t// For filename, remove the path (WARNING! This may be platform-dependent)\n\t\t\tconst size_t last_slash = lastResult.filename.find_last_of(\"\\\\/\");\n\t\t\tif (std::string::npos != last_slash)\n\t\t\t\tlastResult.filename.erase(0, last_slash + 1);\n\n\t\t\t// SET FIRST ERROR \n\t\t\tif (resultID != RESULT_OK)\n\t\t\t{\n\t\t\t\tif (firstError.id == RESULT_OK)\n\t\t\t\t{\n\t\t\t\t\tfirstError = lastResult;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// LOG TO FILE\n\t\t\tif (errorLogFile.is_open())\n\t\t\t\tLogErrorToFile(lastResult);\t\t\n\n\t\t\t// TERMINATE PROGRAM IF ERROR IN PARANOID MODE \n\t\t\t// TO THINK: Do we include RESULT_WARNING here????\n\t\t\tif ((lastResult.id != RESULT_OK) && (assertMode == ASSERT_MODE_PARANOID))\n\t\t\t{\n\t\t\t\tstd::terminate();\n\t\t\t}\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n// First error reporting\n\n\t// Changes the state, so that the next error will be stored as the first error\n\tvoid CDebugger::ResetErrors()\n\t{\n\t\tif (assertMode != ASSERT_MODE_EMPTY)\n\t\t{\n\t\t\tstring description, suggestion;\n\t\t\tfirstError.id = RESULT_OK;\n\t\t\tGetDescriptionAndSuggestion(firstError.id, description, suggestion);\n\t\t\tfirstError.description = description;\n\t\t\tfirstError.suggestion = suggestion;\n\t\t\tfirstError.filename = \"Nobody\";\n\t\t\tfirstError.linenumber = -1;\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Returns a struct with the first error info\n\tTDebuggerResultStruct CDebugger::GetFirstErrorStruct()\n\t{\n\t\treturn firstError;\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Returns just the ID of the first error\n\tTDebuggerResultID CDebugger::GetFirstError()\n\t{\n\t\treturn firstError.id;\n\t}\n\n//////////////////////////////////////////////////////////\n// Verbosity modes\n\n\t// Set verbosity mode from one of the presets\n\tvoid CDebugger::SetVerbosityMode(int presetMode)\n\t{\n\t\t// By default, all presets show all attributes of the debugger result\n\t\tverbosityMode.showID = true;\n\t\tverbosityMode.showDescription = true;\n\t\tverbosityMode.showSuggestion = true;\n\t\tverbosityMode.showFilename = true;\n\t\tverbosityMode.showLinenumber = true;\n\n\t\t// What type of results to show, depending on preset\n\t\tswitch (presetMode)\n\t\t{\n\t\t\tcase VERBOSITY_MODE_SILENT:\n\t\t\t\tverbosityMode.showErrors = false;\n\t\t\t\tverbosityMode.showOk = false;\n\t\t\t\tverbosityMode.showWarnings = false;\n\t\t\t\t//SET_RESULT(RESULT_OK, \"Verbosity mode changed to Silent.\");\t// actually, setting this result is nonsense :)\n\t\t\t\tbreak;\n\t\t\tcase VERBOSITY_MODE_ONLYERRORS:\n\t\t\t\tverbosityMode.showErrors = true;\n\t\t\t\tverbosityMode.showOk = false;\n\t\t\t\tverbosityMode.showWarnings = false;\n\t\t\t\t//SET_RESULT(RESULT_OK, \"Verbosity mode changed to Only Errors.\");\t// actually, setting this result is nonsense :)\n\t\t\t\tbreak;\n\t\t\tcase VERBOSITY_MODE_ALL:\n\t\t\t\tverbosityMode.showErrors = true;\n\t\t\t\tverbosityMode.showOk = true;\n\t\t\t\tverbosityMode.showWarnings = true;\n\t\t\t\t//SET_RESULT(RESULT_OK, \"Verbosity mode changed to All.\");\n\t\t\t\tbreak;\n\t\t\tcase VERBOSITYMODE_ERRORSANDWARNINGS:\n\t\t\t\tverbosityMode.showErrors = true;\n\t\t\t\tverbosityMode.showOk = false;\n\t\t\t\tverbosityMode.showWarnings = true;\n\t\t\t\t//SET_RESULT(RESULT_OK, \"Verbosity mode changed to Errors and Warnings.\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tverbosityMode.showErrors = false;\n\t\t\t\tverbosityMode.showOk = false;\n\t\t\t\tverbosityMode.showWarnings = false;\n\t\t\t\t//SET_RESULT(RESULT_ERROR_CASENOTDEFINED, \"Preset not found for verbosity mode.\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Set custom verbosity mode\n\tvoid CDebugger::SetVerbosityMode(TDebuggerVerbosityMode _verbosityMode)\n\t{\n\t\tverbosityMode = _verbosityMode;\n\t}\n\n//////////////////////////////////////////////////////////\n// Logging to file\n\n\t// Enable/disable log to file, using current verbosity mode (Optional: include verbosity mode as a parameter?)\t\n\tvoid CDebugger::SetErrorLogFile(string filename, bool logOn)\n\t{\n\t\t// TO DO: check errors!\n\n\t\tif (errorLogFile.is_open())\n\t\t\terrorLogFile.close();\n\t\t\t\t\t\t\n\t\tif (logOn)\n\t\t{\n\t\t\terrorLogFile.open(filename, std::ofstream::out | std::ofstream::app);\t// Using append, we allow enabling/disabling log to the same file in runtime\n\t\t\t// TO DO: Put a text header in log file each time you open it? (for example, with a time stamp, but this might be platform-dependent)\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Log to file\n\tvoid CDebugger::LogErrorToFile(TDebuggerResultStruct result)\n\t{\n\t\t// Return if we want to log an OK in a verbosity mode not logging OK\n\t\tif ((!verbosityMode.showOk) && (result.id == RESULT_OK))\n\t\t\treturn;\n\n\t\t// Return if we want to log an error in a verbosity mode not logging errors\n\t\tif ((!verbosityMode.showErrors) && (result.id != RESULT_OK))\n\t\t\treturn;\n\n\t\t// Return if we want to log a warning in a verbosity mode not logging warnings\n\t\tif ((!verbosityMode.showWarnings) && (result.id == RESULT_WARNING))\n\t\t\treturn;\t\t\n\n\t\t// Go ahead with loggin in any other case\n\t\t// TO DO: coherent text, brackets, etc for custom verbosity modes\n\t\tif (verbosityMode.showID)\n\t\t{\n\t\t\tif (result.id == RESULT_OK)\n\t\t\t\terrorLogFile << \"    OK\";\t// We put spaces to clearly spot errors at first sight\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (result.id == RESULT_WARNING)\n\t\t\t\t\terrorLogFile << \"  Warning\";\n\t\t\t\telse\n\t\t\t\t\terrorLogFile << \"ERROR #\" << result.id;\n\t\t\t}\n\t\t}\n\t\tif (verbosityMode.showFilename)\n\t\t{\n\t\t\terrorLogFile << \" in \" << result.filename << \" (\";\n\t\t}\n\t\tif (verbosityMode.showLinenumber)\n\t\t{\n\t\t\terrorLogFile << result.linenumber << \"): \";\n\t\t}\n\t\tif (verbosityMode.showDescription)\n\t\t{\n\t\t\terrorLogFile << result.description;\n\t\t}\n\t\tif (verbosityMode.showSuggestion)\n\t\t{\n\t\t\terrorLogFile << \" - \" << result.suggestion;\n\t\t}\n\t\terrorLogFile << std::endl;\n\t}\n\n//////////////////////////////////////////////////////////\n// Assert modes\n\n\t// Sets an assert mode. Defines what to do when an error happens\n\tvoid CDebugger::SetAssertMode(TAssertMode _assertMode)\n\t{\n\t\tassertMode = _assertMode;\n\t\tif (assertMode == ASSERT_MODE_EMPTY)\n\t\t{\n\t\t\tlastResult.id = RESULT_OK;\n\t\t\tlastResult.description = \"No results\";\n\t\t\tlastResult.suggestion = \"Assert mode is empty; results are not being reported.\";\n\t\t\tlastResult.filename = \"\";\n\t\t\tlastResult.linenumber = -1;\n\t\t\tfirstError = lastResult;\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Test a condition and generate error if false, doing the action specified by the assert mode\n\tvoid CDebugger::AssertTest(bool condition, TDebuggerResultID errorID, string suggestionError, string suggestionOK, string filename, int linenumber)\n\t{\n\t\tif (assertMode != ASSERT_MODE_EMPTY)\n\t\t{\n\t\t\tif (condition)\n\t\t\t{\n\t\t\t\tif (suggestionOK != \"\")\n\t\t\t\t\tSetResult(RESULT_OK, suggestionOK, filename, linenumber);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetResult(errorID, suggestionError, filename, linenumber);\n\n\t\t\t\tif (assertMode == ASSERT_MODE_ABORT)\n\t\t\t\t{\n\t\t\t\t\tstd::terminate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n// Variable watcher\n\n\t// Reset all watches\n\tvoid CDebugger::ResetWatcher()\n\t{\n\t\tfor (int i = 0; i < WV_END; i++)\n\t\t{\n\t\t\twatcherVariables[i] = false;\t\t\t\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Add a variable to the list of variables to watch\n\tvoid CDebugger::AddVariableWatch(TWatcherVariable whichVar)\n\t{\n\t\twatcherVariables[whichVar] = true;\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Remove a variable from the list of variables to watch\n\tvoid CDebugger::RemoveVariableWatch(TWatcherVariable whichVar)\n\t{\n\t\twatcherVariables[whichVar] = false;\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Enable/disable log to file of watched variables\n\tvoid CDebugger::SetWatcherLogFile(TWatcherVariable whichVar, string filename, bool logOn)\n\t{\n\t\t// TO DO: check errors!\n\n\t\tif (watcherLogFiles[whichVar].is_open())\n\t\t\twatcherLogFiles[whichVar].close();\n\n\t\tif (logOn)\n\t\t{\n\t\t\twatcherLogFiles[whichVar].open(filename, std::ofstream::out | std::ofstream::app);\t// Using append, we allow enabling/disabling log to the same file in runtime\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TO DO: Put a text header in log file each time you open it? (for example, with a time stamp, but this might be platform-dependent)\t\t\t\n\t\t}\n\t}\n\n//////////////////////////////////////////////////////////\n\n\t// Enable/disable watcher output to stream\n\t//void CDebugger::SetWatchStream(std::ostream stream, bool streamOn)\n\t//{\n\t//}\n\n//////////////////////////////////////////////////////////\n\n#endif","/**\n* \\class CDebugger\n*\n* \\brief Declaration of CDebugger interface.\n* \\version $1.0$\n* \\date\tJuly 2016\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre-del Olmo, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n\n#ifndef _DEBUGGER_H_\n#define _DEBUGGER_H_\n\n#include <string>\n#include <mutex>\n#include <fstream>\n\n/*! \\file */\n\nusing namespace std;\n\n/** \\brief If SWITCH_ON_3DTI_DEBUGGER is undefined, the debugger is completely disabled, causing 0 overhead\n*/\n\n//#define SWITCH_ON_3DTI_DEBUGGER // Make sure you know what you are doing if you define this as it will create a lot of overhead even in Release mode.\n\n//#define _3DTI_ANDROID_DEBUGGER\n#ifdef _3DTI_ANDROID_DEBUGGER\n\n#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, \"3DTI_CORE\", __VA_ARGS__))\n#define LOGV(...) ((void)__android_log_print(ANDROID_LOG_VERBOSE, \"3DTI_CORE\", __VA_ARGS__))\n#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, \"3DTI_CORE\", __VA_ARGS__))\n\n#define SET_RESULT(errorID, suggestion) CDebugger::Instance().AndroidSetResult(errorID, suggestion, __FILE__, __LINE__)\n\n#define ASSERT(condition, errorID, suggestionError, suggestionOK) CDebugger::Instance().AndroidAssertTest(condition, errorID, suggestionError, suggestionOK, __FILE__, __LINE__)\n\n#define WATCH(whichVar, varValue, className) ((void)0)\n\n#define GET_LAST_RESULT() ((void)0)\n\n#define GET_LAST_RESULT_STRUCT() ((void)0)\n\n#define GET_FIRST_ERROR_STRUCT() ((void)0)\n\n#endif\n\n#if !defined (SWITCH_ON_3DTI_DEBUGGER) && !defined(_3DTI_ANDROID_DEBUGGER)\n\n///////////////////////////////////////////////////\n/// Dummy Macro definitions \n\n#define SET_RESULT(errorID, suggestion) ((void)0)\n\n#define ASSERT(condition, errorID, suggestionError, suggestionOK) ((void)0)\n\n#define WATCH(whichVar, varValue, className) ((void)0)\n\n#define GET_LAST_RESULT() ((void)0)\n\n#define GET_LAST_RESULT_STRUCT() ((void)0)\n\n#define GET_FIRST_ERROR_STRUCT() ((void)0)\n\n#endif\n\n#if defined(SWITCH_ON_3DTI_DEBUGGER)\n\n///////////////////////////////////////////////////\n/// Macro definitions for asserts, setting results and watching variables\n\n/** \\brief Macro used by internal classes for reporting results to debugger\n*/\n#define SET_RESULT(errorID, suggestion) CDebugger::Instance().SetResult(errorID, suggestion, __FILE__, __LINE__)\n\n/** \\brief Macro used by internal classes for throwing asserts to debugger\n*/\n#define ASSERT(condition, errorID, suggestionError, suggestionOK) CDebugger::Instance().AssertTest(condition, errorID, suggestionError, suggestionOK, __FILE__, __LINE__)\n\n/** \\brief Macro used by internal classes to allow watch of internal variables in debugger\n*/\n#define WATCH(whichVar, varValue, className) CDebugger::Instance().Watch<className>(whichVar, varValue)\n\n/** \\brief Macro for getting (only the ID of) the last result reported to the debugger\n*\t\\details Please, check in the documentation which methods report errors/warnings to debugger\n*\t\\retval result ID of last result/error/warning\n*/\n#define GET_LAST_RESULT() CDebugger::Instance().GetLastResult()\n\n/** \\brief Macro for getting (the full structure of) the last result reported to the debugger\n*\t\\details Please, check in the documentation which methods report errors/warnings to debugger\n*\t\\retval resultStruct full structure with information on the last result/error/warning (See \\link TDebuggerResultStruct \\endlink)\n*/\n#define GET_LAST_RESULT_STRUCT() CDebugger::Instance().GetLastResultStruct()\n\n/** \\brief Macro for getting (the full structure of) the first error reported to the debugger in a block of code\n*\t\\details Please, check in the documentation which methods report errors/warnings to debugger\n*\t\\pre The starting point of the block of code is marked using \\link ResetErrors \\endlink\n*\t\\retval errorStruct full structure with information on the first result/error/warning (See \\link TDebuggerResultStruct \\endlink)\n*/\n#define GET_FIRST_ERROR_STRUCT() CDebugger::Instance().GetFirstErrorStruct()\n\n#endif\n\n#if defined(SWITCH_ON_3DTI_DEBUGGER) || defined(_3DTI_ANDROID_DEBUGGER)\n\n//\n// Result/Error data structures\n//\n\n/** \\brief ID of result reported to debugger\n*/\nenum TDebuggerResultID\n{ \n\t// No error\n\tRESULT_OK,\t\t\t\t\t\t///< No error. Everything went ok\n\n\t// General errors\n\tRESULT_ERROR_UNKNOWN,\t\t\t///< Unknown error (use only for weird situations, when you don't have any clue of the error source)\n\tRESULT_ERROR_NOTSET,\t\t\t///< The value of some parameter was not set\n\tRESULT_ERROR_BADALLOC,\t\t\t///< Memory allocation failure\n\tRESULT_ERROR_NULLPOINTER,\t\t///< Trying to use a pointer which is null\n\tRESULT_ERROR_DIVBYZERO,\t\t\t///< Division by zero\n\tRESULT_ERROR_CASENOTDEFINED,\t///< Some case in a switch was not defined (typically, use this for the \"default\" case of a switch)\t\n\tRESULT_ERROR_PHYSICS,\t\t\t///< Trying to do something which is not physically correct\n\tRESULT_ERROR_INVALID_PARAM,     ///< Param value is not valid\n\tRESULT_ERROR_OUTOFRANGE,\t\t///< Trying to access an array or vector position outside its size\n\tRESULT_ERROR_BADSIZE,\t\t\t///< Trying to fill a data structure with a bad data size\n\tRESULT_ERROR_NOTINITIALIZED,\t///< Using or returning a value which is not initialized\n\tRESULT_ERROR_SYSTEMCALL,\t\t///< A system call returned an error\n\tRESULT_ERROR_NOTALLOWED,\t\t///< Trying to do something which is not allowed in the current context\n\tRESULT_ERROR_NOTIMPLEMENTED,\t///< A method was defined in the interface for future versions, but it is not implemented yet\n\n\t// More errors...\n\n\t// Warnings\n\tRESULT_WARNING\t\t\t\t\t///< Description to be specified in suggestion\t\n};\n\n/** Struct with full information about one error/result/warning\n*/\nstruct TDebuggerResultStruct\n{\n\tTDebuggerResultID id;\t///< ID of result\n\tstring description;\t\t///< Description of result\n\tstring suggestion;\t\t///< Suggestion for fixing error or further information about result\n\tstring filename;\t\t///< File from which result was reported\n\tint linenumber;\t\t\t///< Line numer at which result was reported (within filename file)\n};\n\n/** \\brief Stream output of \\link TDebuggerResultStruct \\endlink\n*/\ninline std::ostream & operator<<(std::ostream & out, const TDebuggerResultStruct & r)\n{\n\tout << \"RESULT #\" << r.id << \" in File \" << r.filename << \"(\" << r.linenumber << \"): \" << r.description << \" - \" << r.suggestion;\n\treturn out;\n}\n\n//\n// Verbosity modes data structures and presets\n//\n\n/*********************************************/\n\n/** \\brief Preset verbosity modes\n*/\n#define VERBOSITY_MODE_SILENT\t\t\t0\t///< Nothing to show\n#define VERBOSITYMODE_ERRORSANDWARNINGS\t1\t///< Show errors and warnings, but not OK results\n#define VERBOSITY_MODE_ONLYERRORS\t\t2\t///< Show only errors, not OK nor warnings\n#define VERBOSITY_MODE_ALL\t\t\t\t3\t///< Show every type of result: error, warning and OK. Use this with caution, may report a huge amount of information...\n\n/*********************************************/\n\n/** \\brief Type definition for verbosity modes\n*/\nstruct TDebuggerVerbosityMode\n{\n\tbool showErrors;\t\t///< Do show error results\n\tbool showWarnings;\t\t///< Do show warning results\n\tbool showOk;\t\t\t///< Do show OK results\n\n\tbool showID;\t\t\t///< Do show ID of result\n\tbool showDescription;\t///< Do show description of result\n\tbool showSuggestion;\t///< Do show suggestion of result\n\tbool showFilename;\t\t///< Do show filename of result\n\tbool showLinenumber;\t///< Do show linenumber of result\n};\n\n//\n// Assert modes \n//\n\n/** \\brief Type definition of assert modes\n*/\nenum TAssertMode\t{ASSERT_MODE_EMPTY,\t\t///< Do nothing. Ignore even result reporting. The debugger becomes useless with this setting. For maximum performance, undefine \\link SWITCH_ON_3DTI_DEBUGGER \\endlink\n\t\t\t\t\tASSERT_MODE_CONTINUE,\t///< Allow reporting of results, but do nothing with them. Will never terminate program execution\n\t\t\t\t\tASSERT_MODE_ABORT,\t\t///< Abort execution when an ASSERT is evaluated as false. The error will be reported/logged before terminating\n\t\t\t\t\tASSERT_MODE_PARANOID\t///< Abort execution if any error is reported to the debugger, even if it was reported using SET_RESULT rather than ASSERT. The error will be reported/logged before terminating\n\t\t\t\t\t};\n\n\n//\n// Definitions of variables for variable watcher\n//\n\n/** \\brief Definition of variables reported to the variable watcher\n*\t\\details This is just an example, you can add here any variables you may need\n*/\nenum TWatcherVariable\t{WV_ANECHOIC_AZIMUTH_LEFT,\t///< Azimuth of audio source for listener left ear\n\t\t\t\t\t\tWV_ANECHOIC_AZIMUTH_RIGHT,\t///< Azimuth of audio source for listener right ear\n\t\t\t\t\t\tWV_END};\n\n/*********************************************/\n\n/** \\details Debugger class for error reporting and watching variables \n*\t\\details Follows Meyers Singleton design pattern\n*/\nclass CDebugger \n{\npublic:\n// PUBLIC METHODS:\n\n\t/** \\brief Access to singleton instance with lazy initialization\n\t*\t\\details Use CDebugger::Instance().Method to call any debugger method, or use the defined MACROS instead\n\t*\t\\sa SET_RESULT, ASSERT, GET_RESULT, GET_RESULT_STRUCT, GET_FIRST_ERROR_STRUCT, WATCH\n\t*/\n\tstatic CDebugger& Instance()\n\t{\n\t\tstatic CDebugger singletonInstance;\n\t\treturn singletonInstance;\n\t}\n\n//\n// Result reporting\n//\n\n\t/** \\brief Get a struct with the info of the last reported result \n\t*\t\\retval resultStruct info of last reported result\n\t*/\n\tTDebuggerResultStruct GetLastResultStruct();\t\t\n\n\t/** \\brief Get the ID of the last reported result\n\t*\t\\retval result ID of last reported result\n\t*/\n\tTDebuggerResultID GetLastResult();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set result of last operation\n\t*\t\\note Instead of calling this method, using the macros \\link SET_RESULT \\endlink or \\link ASSERT \\endlink is recommended\n\t*\t\\param [in] resultID ID of result\n\t*\t\\param [in] suggestion suggestion or further information about result\n\t*\t\\param [in] filename file from which result is being reported\n\t*\t\\param [in] linenumber line number at which result is being reported (whithin filename file)\n\t*/\n\tvoid SetResult(TDebuggerResultID resultID, string suggestion, string filename, int linenumber);\t\t\t\t\t\n\n#if defined (_3DTI_ANDROID_DEBUGGER)\n\tvoid AndroidSetResult(TDebuggerResultID resultID, string suggestion, string filename, int linenumber)\n\t{\n\t\tstring newdescription;\n\t\tstring newsuggestion;\n\t\tGetDescriptionAndSuggestion(resultID, newdescription, newsuggestion);\n\n\t\tif (suggestion != \"\")\n\t\t\tnewsuggestion = suggestion;\n\n\t\tif (resultID == RESULT_OK)\n\t\t\tLOGV(\"OK: %s in file %s (%d)\", newsuggestion.c_str(), filename.c_str(), linenumber);\n\t\telse\n\t\t{\n\t\t\tif (resultID == RESULT_WARNING)\n\t\t\t\tLOGW(\"WARNING: %s in file %s (%d)\", newsuggestion.c_str(), filename.c_str(), linenumber);\n\t\t\telse\n\t\t\t\tLOGE(\"ERROR (%s): %s in file %s (%d)\", newdescription.c_str(), newsuggestion.c_str(), filename.c_str(), linenumber);\n\t\t}\n\t}\n#endif\n\n//\n// First error (error reporting in blocks of code)\n//\n\n\t/** \\brief Inits the first error report, so that the next error will be stored as the first error\n\t*\t\\details Used to mark the starting point of the code block\n\t*/\n\tvoid ResetErrors();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Get a struct with the info of the first reported error in code block\n\t*\t\\retval resultStruct info of first reported error in code block\n\t*/\n\tTDebuggerResultStruct GetFirstErrorStruct();\t\t\t\t\t\t\n\n\t/** \\brief Get the ID of the first reported error in code block\n\t*\t\\retval result ID of first reported error in code block\n\t*/\n\tTDebuggerResultID GetFirstError();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n//\n// Verbosity modes\n//\n\n\t/** \\brief Set verbosity mode from one of the presets\n\t*\t\\sa VERBOSITY_MODE_SILENT, VERBOSITYMODE_ERRORSANDWARNINGS, VERBOSITY_MODE_ONLYERRORS, VERBOSITY_MODE_ALL\n\t*/\n\tvoid SetVerbosityMode(int presetMode);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Set custom verbosity mode\n\t*\t\\param [in] _verbosityMode definition of custom verbosity mode\n\t*/\n\tvoid SetVerbosityMode(TDebuggerVerbosityMode _verbosityMode);\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n//\n// Logging to file\n//\n\n\t/** \\brief Enable/disable log of reported results to file, using current verbosity mode \n\t*\t\\param [in] filename name of log file\n\t*\t\\param [in] logOn switch on/off logging to file (default, true)\n\t*/\n\tvoid SetErrorLogFile(string filename, bool logOn=true);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n//\n// Assert modes\n//\n\n\t/** \\brief Set an assert mode \n\t*\t\\details Defines what to do when an error is reported\n\t*\t\\param [in] _assertMode one of the preset assert modes\n\t*\t\\sa ASSERT_MODE_EMPTY, ASSERT_MODE_CONTINUE, ASSERT_MODE_ABORT, ASSERT_MODE_PARANOID\t\n\t*/\n\tvoid SetAssertMode(TAssertMode _assertMode);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Test a condition and report error if false, doing the action specified by the assert mode\n\t*\t\\details Internally used by the \\link ASSERT \\endlink macro. Using the macro instead of this method is recommended\n\t*\t\\param [in] condition condition to evaluate\n\t*\t\\param [in] errorID ID of error to report if condition is evaluated false\n\t*\t\\param [in] suggestionError suggestion for reported result struct if condition is evaluated false (result error)\n\t*\t\\param [in] suggestionOK suggestion for reported result struct if condition is evaluated true (result OK)\n\t*\t\\param [in] filename filename for reported result struct \n\t*\t\\param [in] linenumber linenumber for reported result struct\n\t*/\n\tvoid AssertTest(bool condition, TDebuggerResultID errorID, string suggestionError, string suggestionOK, string filename, int linenumber);\t\n\n#if defined (_3DTI_ANDROID_DEBUGGER)\n\tvoid AndroidAssertTest(bool condition, TDebuggerResultID errorID, string suggestionError, string suggestionOK, string filename, int linenumber)\n\t{\n\t\tif (condition)\n\t\t{\n\t\t\tif (suggestionOK != \"\")\n\t\t\t\tAndroidSetResult(RESULT_OK, suggestionOK, filename, linenumber);\n\t\t}\n\t\telse\n\t\t\tAndroidSetResult(errorID, suggestionError, filename, linenumber);\n\t}\n#endif\n\n//\n// Variable watcher\n//\n\n\t/** \\brief Add a variable to the list of variables to watch\n\t*\t\\param [in] whichVar variable to watch, which has to be added first to the \\link TWatcherVariable \\endlink enum\n\t*/\n\tvoid AddVariableWatch(TWatcherVariable whichVar);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Remove a variable from the list of variables to watch\n\t*\t\\param [in] whichVar which variable to stop watching\n\t*\t\\pre Variable was added to watch first\n\t*/\n\tvoid RemoveVariableWatch(TWatcherVariable whichVar);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t/** \\brief Enable/disable log to file of a specific watched variable\n\t*\t\\param [in] whichVar which variable to log to file\n\t*\t\\param [in] filename name of file with the log\n\t*\t\\param [in] logOn switch on/off file logging for this war (default, true)\n\t*\t\\pre Variable was added to watch first\n\t*/\n\tvoid SetWatcherLogFile(TWatcherVariable whichVar, string filename, bool logOn = true);\t\t\t\t\t\t\t\n\n\t/** \\brief Sends the value of a variable to the watcher \n\t*\t\\details The value will be recorded ONLY if the variable is on the list of watched variables. No overhead if the variable is not in the list\n\t*\t\\param [in] whichVar from which variable are we reporting value\n\t*\t\\param [in] varValue the value we are reporting\n\t*/\n\ttemplate <class T>\n\tvoid Watch(TWatcherVariable whichVar, const T& varValue)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\t// Check first if this variable is being watched\n\t\tif (!watcherVariables[whichVar])\n\t\t\treturn;\n\n\t\t// Log to file\n\t\tif (watcherLogFiles[whichVar].is_open())\n\t\t{\n\t\t\twatcherLogFiles[whichVar] << varValue << std::endl;\n\t\t}\n\t}\n\n// HIDDEN METHODS\nprotected:\n\n\t/** \\brief Default constructor\n\t*\t\\details Resets all result and error reporting, sets verbosity mode to \\link VERBOSITY_MODE_ONLYERRORS \\endlink and assert mode to \\link ASSERT_MODE_ABORT \\endlink\n\t*/\n\tCDebugger()\n\t{\n\t\tlastResult.id = RESULT_OK;\n\t\tlastResult.filename = \"Nobody\";\n\t\tlastResult.linenumber = -1;\n\t\tlastResult.suggestion = \"Nothing has been reported to the debugger yet\";\n\n\t\tResetErrors();\n\t\tSetVerbosityMode(VERBOSITY_MODE_ONLYERRORS);\n\t\tSetAssertMode(ASSERT_MODE_ABORT);\n\t\tResetWatcher();\n\t}\n\t\t\n\t/** \\brief Destructor\n\t*\t\\details Closes all open files (error log and watcher)\n\t*/\n\t~CDebugger() \n\t{\n\t\tif (errorLogFile.is_open())\n\t\t\terrorLogFile.close();\n\t\tfor (int i = 0; i < WV_END; i++)\n\t\t{\n\t\t\tif (watcherLogFiles[i].is_open())\n\t\t\t\twatcherLogFiles[i].close();\n\t\t}\n\t}\n\n\t// Generic method for obtaining description and suggestions of a result ID\n\tvoid GetDescriptionAndSuggestion(TDebuggerResultID result, string& description, string& suggestion);\n\n\t// Log to file\n\tvoid LogErrorToFile(TDebuggerResultStruct result);\n\n\t// Reset all watches\n\tvoid ResetWatcher();\n\nprivate:\n// ATTRIBUTES:\n\n\tmutex debugMutex;\n\n\t// Last Result handling\n\tTDebuggerResultStruct lastResult;\t\n\n\t// First error (error reporting in blocks of code)\n\tTDebuggerResultStruct firstError;\t\n\n\t// Verbosity modes\n\t// TO DO: we can think in having different modes for different things: log to file, stream output...\n\tTDebuggerVerbosityMode verbosityMode;\n\n\t// Logging to file\n\tstd::ofstream errorLogFile;\n\n\t// Assert modes\n\tTAssertMode assertMode;\n\n\t// Variable watcher\n\tbool watcherVariables[TWatcherVariable::WV_END];\n\tstd::ofstream watcherLogFiles [TWatcherVariable::WV_END];\n\t//std::ostream watcherStream;\t\n};\n\n#endif\n\n#endif \n","/*\n* \\class CDistanceAttenuator\n*\n* \\brief Definition of CDistanceAttenuator class.\n*\n* Class to apply the effects of the distance of the sound source on the listener\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: February 2016\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n#include <Common/DistanceAttenuator.h>\n#include <Common/Debugger.h>\n//#include \"Defaults.h\"\n#include <Common/Magnitudes.h>\n#include <BinauralSpatializer/Core.h>\n\n#define DISTANCE_ATENUATION_FILTER_DEFAULT_CUTOFF_FREQ 10000\n\n// Defines the frequency at which audible frequencies are not attenuated in a low pass filter.\n#define NO_FILTERING_CUT_OFF_FREQUENCY 20000\n\n// Attenuation effects for far and medium distances, include low pas filtering. This is implemented with a chain of \n// biquads filters. The number of filters in this chain is defined by:\n#define NUM_OF_BIQUAD_FILTERS_FOR_FAR_DISTANCE_FILTERING 1\n\n// The default function that provides the cutoff frequency that models the distortion of far sound sources\n// follows this expression:   Fc = A  10^-B(distance - C)\n// The A and B constants are obtained from the following specifications:\n//   Distance = 15m --> Fc = 20Khz\n//   Distance = 50m --> Fc =  5Khz\n// After solving an equations system:   Cutoff Frecuency = 20000 * pow(10, -0.0172 * (distance - 15));\n#define CUT_OFF_FREQUENCY_FUNCTION__COEF_A NO_FILTERING_CUT_OFF_FREQUENCY\n#define CUT_OFF_FREQUENCY_FUNCTION__COEF_B 0.0172\n#define CUT_OFF_FREQUENCY_FUNCTION__COEF_C DISTANCE_MODEL_THRESHOLD_FAR\n\n//#define USE_PROFILER_DistanceAttenuator\n#ifdef USE_PROFILER_DistanceAttenuator\n#include <Common/Profiler.h>\nCProfilerDataSet dsDAFar;\nCProfilerDataSet dsDANear;\nCProfilerDataSet dsDAAttenuation;\n#endif\n\n//////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\nCDistanceAttenuator::CDistanceAttenuator()\n{\n\treferenceDistance = DISTANCE_MODEL_THRESHOLD_NEAR;\n\t//Simple distance attenuation vrbles initialization\n\tpreviousAttenuation_Channel1 = 0.0f;\n\tpreviousAttenuation_Channel2 = 0.0f;\n\tpreviousFrameAttenuation = 0.0f;\n}\n\n//////////////////////////////////////////////\n\nvoid CDistanceAttenuator::Setup( int samplingRate )\n{\n#ifdef USE_PROFILER_DistanceAttenuator\t\n\tPROFILER3DTI.SetAutomaticWrite(dsDAFar, \"PROF_Distance_Far.txt\");\n\tPROFILER3DTI.SetAutomaticWrite(dsDANear, \"PROF_Distance_Near.txt\");\n\tPROFILER3DTI.SetAutomaticWrite(dsDAAttenuation, \"PROF_Distance_Attenuation.txt\");\n\tPROFILER3DTI.StartRelativeSampling(dsDAFar);\n\tPROFILER3DTI.StartRelativeSampling(dsDANear);\n\tPROFILER3DTI.StartRelativeSampling(dsDAAttenuation);\n#endif\n\tfor (int c = 0; c < NUM_OF_BIQUAD_FILTERS_FOR_FAR_DISTANCE_FILTERING; c++)\n\t{\n\t\tshared_ptr <CBiquadFilter>f = distanceFiltersChain.AddFilter();\n\n\t\tf->SetSamplingFreq( samplingRate );\n\n\t\tf->SetCoefsFor_ButterworthFilter(NO_FILTERING_CUT_OFF_FREQUENCY);\n\t}\n}\n\n//////////////////////////////////////////////\n\nvoid CDistanceAttenuator::ApplyDistanceEffects( CStereoBuffer<float> & buffer, float distance, \n\t                                            float attenuationConstant    , float interauralAzimuthForILD, int bufferSize, int sampleRate,\n\t                                            bool doDistanceAttenuation   , bool doFarDistanceLPF, bool doILD,\n\t                                            float extraAttennuation_dB)\n{\n\tApplyDistanceEffects( &buffer, NULL, distance, attenuationConstant, interauralAzimuthForILD, bufferSize, sampleRate,\n\t\t                 doDistanceAttenuation, doFarDistanceLPF, doILD, extraAttennuation_dB);\n}\n\n//////////////////////////////////////////////\n\nvoid CDistanceAttenuator::ApplyDistanceEffects(CMonoBuffer<float> & buffer, float distance,\n\t\t\t\t\t\t\t\t\t\t\t   float attenuationConstant, float interauralAzimuthForILD, int bufferSize, int sampleRate,\n\t\t\t\t\t\t\t\t\t\t\t   bool doDistanceAttenuation, bool doFarDistanceLPF, bool doILD,\n\t                                           float extraAttennuation_dB)\n{\n\tApplyDistanceEffects( NULL, &buffer, distance, attenuationConstant, interauralAzimuthForILD, bufferSize, sampleRate,\n\t\t                  doDistanceAttenuation, doFarDistanceLPF, doILD, extraAttennuation_dB);\n}\n\n//////////////////////////////////////////////\n\nvoid CDistanceAttenuator::ApplyDistanceEffects( CStereoBuffer<float> *bufferStereo, CMonoBuffer<float> *bufferMono,float distance,\n\t\t\t\t\t\t\t\t\t\t\t\tfloat attenuationConstant, float interauralAzimuthForILD, int bufferSize, int sampleRate,\n\t\t\t\t\t\t\t\t\t\t\t\tbool doDistanceAttenuation, bool doFarDistanceLPF, bool doILD,\n\t                                            float extraAttennuation_dB)\n{\n\n\t// Error check:\n\t//ASSERT(ownerCore != NULL, RESULT_ERROR_NULLPOINTER, \"Single source DSP has no pointer to the Core\", \"Distance effects succesfully applied to single source\");\n\n\tbool near_distance = distance <= DISTANCE_MODEL_THRESHOLD_NEAR;\n\tbool far_distance  = distance >= DISTANCE_MODEL_THRESHOLD_FAR;\n\tbool medium_distance = !far_distance && !near_distance;\n\n\t// Modeling filtering effects of the distance\n\tif (far_distance && doFarDistanceLPF)\n\t{\n#ifdef USE_PROFILER_DistanceAttenuator\n\t\tPROFILER3DTI.RelativeSampleStart(dsDAFar);\n#endif\n\n\t\tfloat fc = GetCutOffFreqForFarDistances(distance);\n\n\t\tfor (int c = 0; c < NUM_OF_BIQUAD_FILTERS_FOR_FAR_DISTANCE_FILTERING; c++)\n\t\t\tdistanceFiltersChain.GetFilter(c)->SetCoefsFor_ButterworthFilter(fc);\n\n\t\tif( bufferStereo != NULL)  distanceFiltersChain.Process( *bufferStereo, TARGET_SAMPLES_BOTH);\n\t\tif (bufferMono   != NULL)  distanceFiltersChain.Process( *bufferMono );\n\n#ifdef USE_PROFILER_DistanceAttenuator\n\t\tPROFILER3DTI.RelativeSampleEnd(dsDAFar);\n#endif\n\t}\n\telse if (near_distance && doILD && bufferStereo != NULL)\n\t{\n#ifdef USE_PROFILER_DistanceAttenuator\n\t\tPROFILER3DTI.RelativeSampleStart(dsDANear);\n#endif\n\n\t\tILD.Process(*bufferStereo, distance, interauralAzimuthForILD);\n\n#ifdef USE_PROFILER_DistanceAttenuator\n\t\tPROFILER3DTI.RelativeSampleEnd(dsDANear);\n#endif\n\t}\n#ifdef USE_PROFILER_DistanceAttenuator\n\tPROFILER3DTI.RelativeSampleStart(dsDAAttenuation);\n#endif\n\t\n\t// Attenuation is computed independently\n\tfloat attenuation = GetDistanceAttenuation(doDistanceAttenuation, attenuationConstant, distance, extraAttennuation_dB);\t\n\t////Apply attenuation directly\n\t//if( bufferMono   != NULL )  bufferMono  ->ApplyGain( attenuation );\n\t//if (bufferStereo != NULL )  bufferStereo->ApplyGain( attenuation );\t\t\t\n\t\n\t////Apply attenuation gradually using Weighted Moving Average method\n\t//if( bufferMono   != NULL )  bufferMono  ->ApplyGainGradually(previousFrameAttenuation, attenuation, bufferSize);\n\t//if (bufferStereo != NULL)  bufferStereo->ApplyGainGradually(previousFrameAttenuation, attenuation, bufferSize);\t\t\t\n\t//previousFrameAttenuation = attenuation;\n\n\t//Apply attenuation gradually using Exponential Moving Average method\n\tif( bufferMono   != NULL )  bufferMono\t->ApplyGainExponentially(previousAttenuation_Channel1, previousAttenuation_Channel2, attenuation, bufferSize, sampleRate);\n\tif (bufferStereo != NULL)\tbufferStereo->ApplyGainExponentially(previousAttenuation_Channel1, previousAttenuation_Channel2, attenuation, bufferSize, sampleRate);\n\t\n\n#ifdef USE_PROFILER_DistanceAttenuator\n\tPROFILER3DTI.RelativeSampleEnd(dsDAAttenuation);\n#endif\n\t\n}\n\n//////////////////////////////////////////////\n\nfloat CDistanceAttenuator::GetDistanceAttenuation( bool doDistanceAttenuation, float attenuationConstant, \n\t                                               float distance, float extraAttennuation_dB) const\n{\n\t// Debugger:\n\tif (distance <= 0.0f)\n\t{\n\t\tSET_RESULT(RESULT_ERROR_DIVBYZERO, \"Attempt to compute distance attenuation for a negative or zero distance\");\n\t\treturn 1.0f;\n\t}\n\t//else\n\t//\tSET_RESULT(RESULT_OK, \"Distance attenuation returned succesfully for single source\");\t\n\n\t// Compute attenuation factor\n\tfloat attenuationFactor = attenuationConstant / DISTANCE_ATTENUATION_REFERENCE_DB;\n\n\t// Compute gain\n\tif ( doDistanceAttenuation && distance > EPSILON_DISTANCE)\n\t{\n\t\treturn powf(10.0f, extraAttennuation_dB + attenuationFactor * log10f( referenceDistance / distance ));\n\t}\n\telse\n\t\treturn 1.0;\n}\n\n//////////////////////////////////////////////\n\n// Returns the cutoff frequency of the low pass filters that is applied for long distances.\nfloat CDistanceAttenuator::GetCutOffFreqForFarDistances(float distance)\n{\n\t//SET_RESULT(RESULT_OK, \"\");\n\n\tif (distance > DISTANCE_MODEL_THRESHOLD_FAR)\n\t{\n\t\t// See comments in definition of constants CUT_OFF_FREQUENCY_FUNCTION__COEF_X\n\t\tfloat A = CUT_OFF_FREQUENCY_FUNCTION__COEF_A;\n\t\tfloat B = CUT_OFF_FREQUENCY_FUNCTION__COEF_B;\n\t\tfloat C = CUT_OFF_FREQUENCY_FUNCTION__COEF_C;\n\n\t\treturn A * pow(10, -B * (distance - C));\n\t}\n\telse\n\t\treturn NO_FILTERING_CUT_OFF_FREQUENCY;\n}\n\n\nvoid CDistanceAttenuator::ApplyGain_ExponentialMovingAverage(CStereoBuffer<float> & buffer, int gain2, float alpha) \n{\n\tfloat previousGainOdd = 0.0f;\n\tfloat gainOdd = 0.0f;\n\tfloat previousGainEven = 0.0f;\n\tfloat gainEven = 0.0f;\n\tint halfBufferSize = (int)(0.5f * buffer.size());\n\tint j = 0;\n\tfor (int i = 0; i < halfBufferSize; i++)\n\t{\n\t\tgainEven = (gain2 - previousGainEven)* alpha + previousGainEven;\n\t\tbuffer[j++] *= gainEven;\n\t\tpreviousGainEven = gainEven;\n\t\tgainOdd = (gain2 - previousGainOdd)* alpha + previousGainOdd;\n\t\tbuffer[j++] *= gainOdd;\n\t\tpreviousGainOdd = gainOdd;\n\t}\n}\n\n\n\n\n\n","/**\n* \\class CFconvolver\n*\n* \\brief Definition of CFconvolver class.\n*\n* This class implements the necessary algorithms to do the convolution, in frequency domain, between signal and a impulse response.\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: April 2016\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n#include \"Fconvolver.h\"\n#include \"Debugger.h\"\n#include <cmath>\n\n//#define USE_PROFILER_FConvolver\n#ifdef USE_PROFILER_FConvolver\n#include <Common/Profiler.h>\nCProfilerDataSet dataSetFFT;\nCProfilerDataSet dataSetComplexMult;\nCProfilerDataSet dataSetIFFT;\nCProfilerDataSet dataSetOthers;\n#endif\nnamespace Common {\n\t/////////////////////////////\n\t// CONSTRUCTOR/DESTRUCTOR  //\n\t/////////////////////////////\n\tCFconvolver::CFconvolver()\n\t{\n\t\tinputSize = 0;\n\t\t//ambiBinIRSize = 0;\t\t\t\n\t\tIRSize = 0;\n\t\tFFTBufferSize = 0;\n\t}\n\n\n\t///////////////////\n\t// Public Methods //\n\t///////////////////\n\n\t//Initialize the class and allocate memory.\n\tvoid CFconvolver::Setup(int _inputSize, int _AIRSize)\n\t{\n\t\tASSERT(_inputSize > 0, RESULT_ERROR_BADSIZE, \"Bad input size when setting up frequency convolver\", \"\");\n\t\tASSERT(_AIRSize > 0, RESULT_ERROR_BADSIZE, \"Bad ABIR size when setting up frequency convolver\", \"\");\n\n\t\tinputSize = _inputSize;\t\t\t\t\n\t\tIRSize = _AIRSize;\t\t\t\t\t\n\t\tFFTBufferSize = inputSize + IRSize;\t\t\t//FIXME Could be shorter -1;\n\n\t\t//Check if if power of two, if not round up to the next highest power of 2 \n\t\tif (!IsPowerOfTwo(FFTBufferSize)) {\n\t\t\tFFTBufferSize = NextPowerOfTwo(FFTBufferSize);\n\t\t}\n\t\tstorageBuffer.resize(FFTBufferSize);\t\t//Prepare the buffer with the space that we are going to needed\n\t\tnormalizeCoef = 1.0f/FFTBufferSize;\t\t\t\t//Store the normalize coef for the FFT-1\n\t\tFFTBufferSize *= 2;\t\t\t\t\t\t\t//We multiplicate by 2 because we need to store real and imaginary part\n\n\t\tip_size = sqrt(FFTBufferSize / 2) + 2;\t\t//Size of the auxiliary array w. This come from lib documentation/examples.\n\t\tw_size = FFTBufferSize * 5 / 4;\t\t\t\t//Size of the auxiliary array w. This come from lib documentation/examples.\n\n#ifdef USE_PROFILER_FConvolver\n\t\tPROFILER3DTI.SetAutomaticWrite(dataSetFFT, \"PROF_FConvolver_FFT.txt\");\n\t\tPROFILER3DTI.SetAutomaticWrite(dataSetComplexMult, \"PROF_FConvolver_ComplexMult.txt\");\n\t\tPROFILER3DTI.SetAutomaticWrite(dataSetIFFT, \"PROF_FConvolver_IFFT.txt\");\n\t\tPROFILER3DTI.SetAutomaticWrite(dataSetOthers, \"PROF_FConvolver_Others.txt\");\n\t\tPROFILER3DTI.StartRelativeSampling(dataSetFFT);\n\t\tPROFILER3DTI.StartRelativeSampling(dataSetComplexMult);\n\t\tPROFILER3DTI.StartRelativeSampling(dataSetIFFT);\n\t\tPROFILER3DTI.StartRelativeSampling(dataSetOthers);\n#endif\n\n\t\tSET_RESULT(RESULT_OK, \"Frequency convolver succesfully set\");\n\t}//Setup\n\n\t //Get a the FFT of the input signal\n\tvoid CFconvolver::GetFFT(const std::vector<float>& inputSource_time, std::vector<float>& inputSource_frequency, int _IRSize)\n\t{\n\t\tint _inputSize = inputSource_time.size();\n\t\t\n\t\tASSERT(_inputSize > 0, RESULT_ERROR_BADSIZE, \"Bad input size when setting up frequency convolver\", \"\");\n\t\tASSERT(_IRSize > 0, RESULT_ERROR_BADSIZE, \"Bad ABIR size when setting up frequency convolver\", \"\");\n\t\t//SET_RESULT(RESULT_OK, \"Frequency convolver succesfully set\");\n\t\t\n\t\tint FFTBufferSize = _inputSize + _IRSize;\t//FIXME Could be shorter -1;\n\n\t\t\t\t\t\t\t\t\t\t\t//Check if if power of two, if not round up to the next highest power of 2 \n\t\tif (!IsPowerOfTwo(FFTBufferSize)) {\n\t\t\tFFTBufferSize = NextPowerOfTwo(FFTBufferSize);\n\t\t}\n\t\tstd::vector<double> storageBuffer;\n\t\tstorageBuffer.resize(FFTBufferSize);\t\t//Prepare the buffer with the space that we are going to needed\n\t\tFFTBufferSize *= 2;\t\t\t\t\t\t\t//We multiplicate by 2 because we need to store real and imaginary part\n\n\t\tint ip_size = sqrt(FFTBufferSize / 2) + 2;\t\t//Size of the auxiliary array w. This come from lib documentation/examples.\n\t\tint w_size = FFTBufferSize * 5 / 4;\t\t\t\t//Size of the auxiliary array w. This come from lib documentation/examples.\n\t\t\t\t\n\n\t\t//Initialize the vector of doubles to Store the AmbiBinIR\n\t\tstd::vector<double> inputSource_FFT(FFTBufferSize);\n\n\t\t//Copy the input vector into an vector of doubles and insert the imaginary part.\t\t\t\n\t\tAddImaginaryPart(inputSource_time, inputSource_FFT);\n\n\t\t//Prepare the FFT\t\t\t\t\t\t\n\t\tstd::vector<int> ip(ip_size);\t//Define the auxiliary array ip \n\t\tstd::vector<double> w(w_size);\t//Define the auxiliary array w\t\t\t\n\t\tip[0] = 0;\t\t\t\t\t\t//w[],ip[] are initialized if ip[0] == 0.\n\n\t\t\t\t\t\t\t\t\t\t//Make the FFT\n\t\tcdft(FFTBufferSize, 1, inputSource_FFT.data(), ip.data(), w.data());\n\n\t\t//Copy to the output float vector\t\t\t\n\t\tinputSource_frequency.resize(FFTBufferSize);\n\t\tfor (int i = 0; i < inputSource_FFT.size(); i++) {\n\t\t\tinputSource_frequency[i] = static_cast<float>(inputSource_FFT[i]);\n\t\t}\n\t}\n\n\t//Gets the FFT of an impulse response\n\tvoid CFconvolver::GetFFT_IR(const CMonoBuffer<float>& IR_time, CMonoBuffer<float>& IR_frequency)\n\t{\n\t\t//Check if the size is the same that the has been initialize with the setup method\n\t\tASSERT(IR_time.size() == IRSize, RESULT_ERROR_BADSIZE, \"Buffer size does not agree with the size specified in the setup of the frequency convolver\", \"\");\n\n\t\t//Initialize the vector of doubles to Store the AmbiBinIR\n\t\tstd::vector<double> IR_FFT(FFTBufferSize);\n\n\t\t//Copy the input vector into an vector of doubles and insert the imaginary part.\t\t\t\n\t\tAddImaginaryPart(IR_time, IR_FFT);\n\n\t\t//Prepare the FFT\t\t\t\t\t\t\n\t\tstd::vector<int> ip(ip_size);\t//Define the auxiliary array ip \n\t\tstd::vector<double> w(w_size);\t//Define the auxiliary array w\t\t\t\n\t\tip[0] = 0;\t\t\t\t\t\t//w[],ip[] are initialized if ip[0] == 0.\n\n\t\t//Make the FFT\n\t\tcdft(FFTBufferSize, 1, IR_FFT.data(), ip.data(), w.data());\n\n\t\t//Copy to the output float vector\t\t\t\n\t\tIR_frequency.resize(FFTBufferSize);\n\t\tfor (int i = 0; i < IR_FFT.size(); i++)\n\t\t{\n\t\t\tIR_frequency[i] = static_cast<float>(IR_FFT[i]);\n\t\t}\n\t}//GetFFT_AmbiBinIR\n\n\t//Get a the FFT of the input signal\n\tvoid CFconvolver::GetFFT_Input(const std::vector<float>& inputSource_time, std::vector<float>& inputSource_frequency)\n\t{\n\t\t//Check if the size is the same that was initialized with the setup method\n\t\tASSERT(inputSource_time.size() == inputSize, RESULT_ERROR_BADSIZE, \"Buffer size does not agree with the size specified in the setup of the frequency convolver\", \"\");\n\n\t\t//Initialize the vector of doubles to Store the AmbiBinIR\n\t\tstd::vector<double> inputSource_FFT(FFTBufferSize);\n\n\t\t//Copy the input vector into an vector of doubles and insert the imaginary part.\t\t\t\n\t\tAddImaginaryPart(inputSource_time, inputSource_FFT);\n\n\t\t//Prepare the FFT\t\t\t\t\t\t\n\t\tstd::vector<int> ip(ip_size);\t//Define the auxiliary array ip \n\t\tstd::vector<double> w(w_size);\t//Define the auxiliary array w\t\t\t\n\t\tip[0] = 0;\t\t\t\t\t\t//w[],ip[] are initialized if ip[0] == 0.\n\n\t\t\t\t\t\t\t\t\t\t//Make the FFT\n\t\tcdft(FFTBufferSize, 1, inputSource_FFT.data(), ip.data(), w.data());\n\n\t\t//Copy to the output float vector\t\t\t\n\t\tinputSource_frequency.resize(FFTBufferSize);\n\t\tfor (int i = 0; i < inputSource_FFT.size(); i++) {\n\t\t\tinputSource_frequency[i] = static_cast<float>(inputSource_FFT[i]);\n\t\t}\n\t};\n\n\t//This method does the complex multiplication between the vector elements. Both vectors have to be the same size\n\tvoid CFconvolver::ComplexMultiplication(const std::vector<float>& x, const std::vector<float>& h, std::vector<float>& y)\n\t{\n\t\tASSERT(x.size() == h.size(), RESULT_ERROR_BADSIZE, \"Complex multiplication in frequency convolver requires two vectors of the same size\", \"\");\n\n\t\ty.resize(x.size());\n\t\tfor (int i = 0; i < (y.size()*0.5f); i++)\n\t\t{\n\t\t\tfloat a = x[2 * i];\n\t\t\tfloat b = x[2 * i + 1];\n\t\t\tfloat c = (h[2 * i]);\n\t\t\tfloat d = (h[2 * i + 1]);\n\n\t\t\ty[2 * i] = a*c - b*d;\n\t\t\ty[2 * i + 1] = a*d + b*c;\n\t\t}\n\t}//ComplexMultiplicaton\n\n\t//Get the IFFT of the output signal\n\tvoid CFconvolver::GetIFFT_Output(const std::vector<float>& inputBuffer_frequency, std::vector<float>& outputBuffer_time, int delayDifference)\n\t{\n\t\tASSERT(inputBuffer_frequency.size() == FFTBufferSize, RESULT_ERROR_BADSIZE, \"Incorrect size of input buffer when computing inverse FFT in frequency convolver\", \"\");\n\n\t\t//Convert to double\n\t\tstd::vector<double> outBuffer_temp(inputBuffer_frequency.begin(), inputBuffer_frequency.end());\n\n\t\t//Prepare the FFT\t\t\t\t\t\t\n\t\tstd::vector<int> ip(ip_size);\t//Define the auxiliary array ip \n\t\tstd::vector<double> w(w_size);\t//Define the auxiliary array w\t\t\t\n\t\tip[0] = 0;\t\t\t\t\t\t//w[],ip[] are initialized if ip[0] == 0.\n\n\t\t//Make the FFT-1\n\t\tcdft(FFTBufferSize, -1, outBuffer_temp.data(), ip.data(), w.data());\n\t\t//Get the audio output buffer\n\t\tCalculateOutputBuffer_OverlapAddMethod(outBuffer_temp, outputBuffer_time, delayDifference);\n\t}//GetIFFT\n\t\n\t /////////////////////\n\t// Private methods //\n\t/////////////////////\n\n\t//This method copies the input vector into an array and insert the imaginary part.\n\tvoid CFconvolver::AddImaginaryPart(const std::vector<float>& input, std::vector<double>& output)\n\t{\n\t\t//Initialize the vector of doubles with zeros\n\t\tstd::fill(output.begin(), output.end(), 0);\n\n\t\tASSERT(output.size() >= 2 * input.size(), RESULT_ERROR_BADSIZE, \"Output buffer size must be at least twice the input buffer size when adding imaginary part in frequency convolver\", \"\");\n\n\t\tfor (int i = 0; i < input.size(); i++)\n\t\t{\n\t\t\toutput[2 * i] = static_cast<double> (input[i]);\n\t\t\t//output[2 * i + 1] = 0;\n\t\t}\n\t}//AddImaginaryPart\n\n\t //This method copy the FFT-1 output array into the storage vector, remove the imaginary part and normalize the output.\t\n\t// input_ConvResultBuffer contain the result of the convolution (it is a complex number vector)\n\tbool CFconvolver::CalculateOutputBuffer_OverlapAddMethod(std::vector<double>& input_ConvResultBuffer, std::vector<float>& outBuffer, int delay)\n\t{\t\t\t\t\n\t\t//Prepare the outbuffer\n\t\tif (outBuffer.size() < inputSize)\n\t\t{\n\t\t\toutBuffer.resize(inputSize);\n\t\t}\t\t\n\t\t//Check buffer sizes\t\n\t\tASSERT(outBuffer.size() == inputSize, RESULT_ERROR_BADSIZE, \"OutBuffer size has to be zero or equal to the input size indicated by the setup method\", \"\");\t\t\n\t\t\t\t\n\t\tint outBufferSize = inputSize;\t//Locar var to move throught the outbuffer\n\t\t\n\t\t//Check delays to insert or remove samples\n\t\tif (delay > 0) {\n\t\t\t//Inset Zeros at the begging of the conv result buffer\t\t\t\n\t\t\tstd::vector<double> vectorDelay(delay * 2, 0.0f);\t\t\t\n\t\t\tinput_ConvResultBuffer.insert(input_ConvResultBuffer.begin(), vectorDelay.begin(), vectorDelay.end());\n\t\t}\n\t\telse if(delay < 0)\n\t\t{\n\t\t\t//Remove samples at the begging of the conv result buffer\t\t\t\n\t\t\tinput_ConvResultBuffer.erase(input_ConvResultBuffer.begin(), input_ConvResultBuffer.begin() + (-2 * delay));\t\t\t\n\t\t}\t\t\n\t\t//Fill out the output signal buffer\n\t\tfor (int i = 0; i < outBufferSize; i++)\n\t\t{\t\t\t\n\t\t\tif (i < storageBuffer.size()) {\n\t\t\t\toutBuffer[i] = static_cast<float>(storageBuffer[i] + CloseToZero(input_ConvResultBuffer[2 * i] * normalizeCoef));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toutBuffer[i] = static_cast<float>(CloseToZero(input_ConvResultBuffer[2 * i] * normalizeCoef));\n\t\t\t}\n\t\t}\n\t\t//Fill out the storage buffer to be used in the next call\n\t\tstd::vector<double> temp;\n\t\ttemp.reserve(0.5f * input_ConvResultBuffer.size()- outBufferSize);\n\t\tint inputConvResult_size = 0.5f * input_ConvResultBuffer.size();\t//Locar var to move to the end of the input_ConvResultBuffer\n\t\tfor (int i= outBufferSize; i < inputConvResult_size; i++)\n\t\t{\n\t\t\tif (i<storageBuffer.size())\n\t\t\t{\n\t\t\t\ttemp.push_back(storageBuffer[i] + CloseToZero(input_ConvResultBuffer[2 * i] * normalizeCoef));\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\ttemp.push_back(CloseToZero(input_ConvResultBuffer[2 * i] * normalizeCoef));\n\t\t\t}\n\t\t}\t\t\n\t\t//storageBuffer.swap(temp);\t\t\t\t//To use in C++03\n\t\tstorageBuffer=std::move(temp);\t\t\t//To use in C++11\n\t\treturn true;\n\t}//CalculateOutputBuffer_OverlapAddMethod\n\n\t\t\n\t //This method rounds to zero a value that is very close to zero.\n\tdouble CFconvolver::CloseToZero(double number)\n\t{\n\n\t\tif (std::abs(number) < THRESHOLD)\n\t\t{\n\t\t\treturn 0.0f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn number;\n\t\t}\n\t}//CloseToZero\n\n\t//This method check if a number is a power of 2\n\tbool CFconvolver::IsPowerOfTwo(int x)\n\t{\n\t\treturn (x != 0) && ((x & (x - 1)) == 0);\n\t}//IsPowerOfTwo\n\n\t//This method Round up to the next highest power of 2 \n\tint CFconvolver::NextPowerOfTwo(int v)\n\t{\n\t\tv--;\n\t\tv |= v >> 1;\n\t\tv |= v >> 2;\n\t\tv |= v >> 4;\n\t\tv |= v >> 8;\n\t\tv |= v >> 16;\n\t\tv++;\n\t\treturn v;\n\t}//NextPowerOfTwo\n}","/*\n* \\class CFiltersChain\n*\n* \\brief Definition of FiltersChain class.\n*\n* Class to handle a set of cascade digital filters\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: February 2016\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n\n#include <Common/FiltersChain.h>\n#include <Common/Debugger.h>\n\n//////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\nCFiltersChain::CFiltersChain()\n{\t\t\n}\n\n//////////////////////////////////////////////\nshared_ptr<CBiquadFilter> CFiltersChain::AddFilter()\n{\n\ttry\n\t{\n\t\tshared_ptr<CBiquadFilter> newFilter(new CBiquadFilter());\n\t\tfilters.push_back(newFilter);\n\n\t\tSET_RESULT(RESULT_OK, \"Filter added to filter chain succesfully\");\n\t\treturn newFilter;\n\t}\n\tcatch (std::bad_alloc& ba)\n\t{\n\t\t//SET_RESULT(RESULT_ERROR_BADALLOC, ba.what());\n\t\tASSERT(false, RESULT_ERROR_BADALLOC, ba.what(), \"\");\n\t\treturn nullptr;\n\t}\n}\n\n//////////////////////////////////////////////\n\nshared_ptr<CBiquadFilter> CFiltersChain::GetFilter(int index)\n{\n\tif (index < 0 || filters.size() <= index)\n\t{\n\t\tSET_RESULT(RESULT_ERROR_OUTOFRANGE, \"Attempt to get a filter from filter chain outside chain size\" );\n\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\tSET_RESULT(RESULT_OK, \"Succesfully got filter from filter chain\");\n\t\treturn filters[index];\n\t}\n}\n\n//////////////////////////////////////////////\nvoid CFiltersChain::RemovesFilters()\n{\n\tfilters.clear();\n\n\tSET_RESULT(RESULT_OK, \"All filters succesfully removed from filter chain\");\n}\n\n//////////////////////////////////////////////\nvoid CFiltersChain::Process(CStereoBuffer<float> & buffer, TargetSamples target )\n{\n\t//SET_RESULT(RESULT_OK, \"\");\n\tfor (std::size_t c = 0; c < filters.size(); c++)\n\t{\n\t\tshared_ptr<CBiquadFilter> f = filters[c];\n\t\tif (f != NULL)\n\t\t\tf->Process( buffer, target );\n\t}\t\t\n}\n\n//////////////////////////////////////////////\nvoid CFiltersChain::Process(CMonoBuffer <float> & buffer)\n{\n\t//SET_RESULT(RESULT_OK, \"\");\n\tfor (std::size_t c = 0; c < filters.size(); c++)\n\t{\n\t\tshared_ptr<CBiquadFilter> f = filters[c];\n\t\tif (f != NULL)\n\t\t\tf->Process(buffer);\n\t}\n}\n\t\n\n//////////////////////////////////////////////\nint CFiltersChain::GetNumFilters()\n{\t\t\n\treturn filters.size();\n}","/*\n\t* \\class CMagnitudes\n\t*\n\t* \\brief Definition of a class for handling physical magnitudes.\n\t*\n\t* This class define the vars and methods for handling physical magnitudes.\n\t*\n\t* \\version $Alpha 1.0$\n\t*\n\t* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n\t*\n\t* Contact: areyes@uma.es\n\t*\n\t* Created on: Jan 2016\n\t*\n\t* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n\t*\n\t* Module: 3DTI Toolkit/Core\n\t*/\n#include <Common/Magnitudes.h>\n#include <Common/Debugger.h>\n\n#include <math.h>\n\n////////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\n\tCMagnitudes::CMagnitudes()\n\t{\n\t\tSetAnechoicDistanceAttenuation(DEFAULT_ANECHOIC_ATTENUATION_DB);\n\t\tSetReverbDistanceAttenuation(DEFAULT_REVERB_ATTENUATION_DB);\n\t\tSetSoundSpeed(DEFAULT_SOUND_SPEED);\n\t}\n\n////////////////////////////////////////////////\n// GET/SET METHODS\t\n\n\t// Set sound speed in m/s\n\tvoid CMagnitudes::SetSoundSpeed(float _soundSpeed)\n\t{\n\t\tif (_soundSpeed < 0.0f)\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_PHYSICS, \"Sound speed must be a positive value\");\n\t\t\treturn;\n\t\t}\n\n\t\tsoundSpeed = _soundSpeed;\n\n\t\t//SET_RESULT(RESULT_OK, \"Sound speed succesfully set\");\n\n\t}\n\n////////////////////////////////////////////////\n\n\t// Get sound speed in m/s\n\tfloat CMagnitudes::GetSoundSpeed() const\n\t{\n\t\treturn soundSpeed;\n\t}\n\n////////////////////////////////////////////////\n\n\t// Set distance attenuation constant for anechoic process \n\tvoid CMagnitudes::SetAnechoicDistanceAttenuation(float _anechoicAttenuationDB)\n\t{\n\t\t//SetAttenuation(anechoicAttenuation, anechoicAttenuationDB, anechoicAttenuationGAIN, units);\n\t\tif (_anechoicAttenuationDB > 0.0f)\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_PHYSICS, \"Attenuation constant in decibels must be a negative value\");\n\t\t\treturn;\n\t\t}\n\t\tanechoicAttenuationDB = _anechoicAttenuationDB;\n\n\t\t//SET_RESULT(RESULT_OK, \"Anechoic distance attenuation succesfully set\");\n\t}\n\n////////////////////////////////////////////////\n\n\t// Set distance attenuation constant for reverb process \n\tvoid CMagnitudes::SetReverbDistanceAttenuation(float _reverbAttenuationDB)\t\n\t{\n\t\t//SetAttenuation(reverbAttenuation, reverbAttenuationDB, reverbAttenuationGAIN, units);\n\t\tif (_reverbAttenuationDB > 0.0f)\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_PHYSICS, \"Attenuation constant in decibels must be a negative value\");\n\t\t\treturn;\n\t\t}\n\t\treverbAttenuationDB = _reverbAttenuationDB;\n\n\t\t//SET_RESULT(RESULT_OK, \"Reverb distance attenuation succesfully set\");\n\t}\n\n////////////////////////////////////////////////\n\n\t// Get distance attenuation constant for anechoic process\n\t//float CMagnitudes::GetAnechoicDistanceAttenuation(TUnits units)\n\tfloat CMagnitudes::GetAnechoicDistanceAttenuation() const\t\n\t{\n\t\treturn anechoicAttenuationDB;\n\t}\n\n////////////////////////////////////////////////\n\n\t// Get distance attenuation constant for anechoic process \t\n\t//float CMagnitudes::GetReverbDistanceAttenuation(TUnits units)\t\n\tfloat CMagnitudes::GetReverbDistanceAttenuation() const\t\n\t{\n\t\treturn reverbAttenuationDB;\n\t}\n\n","/*\n\t* \\class CQuaternion\n\t*\n\t* \\brief Definition of Quaternions (representation of orientation).\n\t*\n\t* This class define the necessary algorithms and vars for Quaternions (representation of orientation).\n\t*\n\t* \\version $Alpha 1.0$\n\t*\n\t* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n\t*\n\t* Contact: areyes@uma.es\n\t*\n\t* Created on: Jan 2016\n\t*\n\t* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n\t*\n\t* Module: 3DTI Toolkit/Core\n\t*/\n\n\t// ToDo: + Take into account conventions for circular motion\n#include <Common/Quaternion.h>\n#include <Common/Debugger.h>\n#include <math.h>\n\n//////////////////////////////////////////////\n// BASIC PREDEFINED QUATERNIONS\n\n\tconst CQuaternion CQuaternion::ZERO(0.0f, 0.0f, 0.0f, 0.0f);\n\tconst CQuaternion CQuaternion::UNIT(1.0f, 0.0f, 0.0f, 0.0f);\n\t\n//////////////////////////////////////////////\n// CONSTRUCTORS/DESTRUCTORS\n\n\t// Default: unit quaternion\n\tCQuaternion::CQuaternion()\n\t{\n\t\tCQuaternion::UNIT;\n\t}\n\n//////////////////////////////////////////////\n\n\tCQuaternion::CQuaternion(float _w, float _x, float _y, float _z)\n\t{\n\t\tw = _w;\n\t\tx = _x;\n\t\ty = _y;\n\t\tz = _z;\n\t}\n\n//////////////////////////////////////////////\n\n\t// From a vector (quaternion without scalar component)\n\tCQuaternion::CQuaternion(CVector3 _vector)\n\t{\n\t\tw = 0.0f;\n\t\tx = _vector.x;\n\t\ty = _vector.y;\n\t\tz = _vector.z;\n\t}\n\n//////////////////////////////////////////////\n\n\t// From a scalar (quaternion without vectorial component)\n\tCQuaternion::CQuaternion(float _scalar)\n\t{\n\t\tw = _scalar;\n\t\tx = y = z = 0.0f;\n\t}\n\t\n//////////////////////////////////////////////\n// BASIC OPERATIONS\n\n\t// Rotate a quaternion with another quaternion\n\tvoid CQuaternion::Rotate(CQuaternion _rightHand)\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Quaternion rotated succesfully\");\n\n\t\tCQuaternion thisCopy = *this;\n\t\t*this = _rightHand*thisCopy;\n\t}\n\n//////////////////////////////////////////////\n\n\t// Rotate a vector with this quaternion\n\tconst CVector3 CQuaternion::RotateVector(CVector3 _vector) const\n\t{\n\t\t// Debugger:\n\t\t// Trust in Inverse for setting result\n\n\t\t// Convert vector into quaternion, forcing quaternion axis convention\n\t\tCQuaternion vectorQuaternion = CQuaternion(_vector);\n\n\t\t// Left product\n\t\tCQuaternion leftProduct = *this*vectorQuaternion;\n\n\t\t// Right product\n\t\tCQuaternion rightProduct = leftProduct*Inverse();\n\n\t\t// Convert result quaternion into vector\n\t\tCVector3 result = CVector3(rightProduct.x, rightProduct.y, rightProduct.z);\n\n\t\treturn result;\n\t}\n\n//////////////////////////////////////////////\n// CONVERSIONS\n\n\t// Get a quaternion from axis and angle\n\tCQuaternion CQuaternion::FromAxisAngle(CVector3 _axis, float _angle)\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Conversion from axis-angle to quaternion was succesfull\");\n\n\t\tfloat newW, newX, newY, newZ;\n\n\t\tfloat halfAngle = _angle*0.5f;\n\t\tfloat halfSin = sin(halfAngle);\n\t\tfloat halfCos = cos(halfAngle);\n\t\t\n\t\tnewW = halfCos;\n\t\tnewX = halfSin*_axis.x;\n\t\tnewY = halfSin*_axis.y;\n\t\tnewZ = halfSin*_axis.z;\n\n\t\treturn CQuaternion(newW, newX, newY, newZ);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Get axis and angle from a quaternion\n\tvoid CQuaternion::ToAxisAngle(CVector3& _axis, float& _angle)\n\t{\n\t\tfloat sqrLength = x*x + y*y + z*z;\n\t\tif (sqrLength > 0.0f)\n\t\t{\n\t\t\t// Debugger:\n\t\t\t//SET_RESULT(RESULT_OK, \"Conversion from quaternion to axis-angle was succesfull\");\n\n\t\t\tfloat invLength = 1.0f/sqrt(sqrLength);\n\t\t\t_axis.SetCoordinates(x*invLength, y*invLength, z*invLength);\n\t\t\t_angle = 2.0f*acos(w);\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\t// Debugger:\n\t\t\tSET_RESULT(RESULT_WARNING, \"Converting to axis/angle from zero quaternion returns an arbitrary axis\");\n\n\t\t\t_axis.SetCoordinates(1.0f, 0.0f, 0.0f); // Any axis is valid for a 0 angle\n\t\t\t_angle = 0.0f;\n\t\t}\n\t}\n\n//////////////////////////////////////////////\n// OPERANDS\n\n\t// Quaternion product (not commutative). Use this for rotating!\n\tconst CQuaternion CQuaternion::operator* (const CQuaternion _rightHand) const\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Quaternion product operation succesfull.\");\n\n\t\tfloat newW = w*_rightHand.w - x*_rightHand.x - y*_rightHand.y - z*_rightHand.z;\n\t\tfloat newX = w*_rightHand.x + x*_rightHand.w + y*_rightHand.z - z*_rightHand.y;\n\t\tfloat newY = w*_rightHand.y + y*_rightHand.w + z*_rightHand.x - x*_rightHand.z;\n\t\tfloat newZ = w*_rightHand.z + z*_rightHand.w + x*_rightHand.y - y*_rightHand.x;\n\t\treturn CQuaternion(newW, newX, newY, newZ);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Get the inverse of this quaternion\n\tconst CQuaternion CQuaternion::Inverse() const\n\t{\t\t\t\t\n\t\t// Debugger:\n\t\tfloat norm = SqrNorm();\t\t// Not completely sure that we can use SqrNorm instead of Norm...\n\t\tif (norm == 0.0f)\n\t\t{\n\t\t\tSET_RESULT(RESULT_WARNING, \"Computing inverse of quaternion with zero norm (returns ZERO quaternion)\");\n\t\t\treturn CQuaternion::ZERO;\n\t\t}\n\t\t//else\t\t\n\t\t//\tSET_RESULT(RESULT_OK, \"Inverse of quaternion was computed succesfully\");\n\t\t\n\t\tfloat invNorm = 1.0f / norm;\n\n\t\tfloat newW = w*invNorm;\n\t\tfloat newX = -x*invNorm;\n\t\tfloat newY = -y*invNorm;\n\t\tfloat newZ = -z*invNorm;\n\n\t\treturn CQuaternion(newW, newX, newY, newZ);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Get the norm of this quaternion\n\tfloat CQuaternion::Norm()\n\t{\n\t\t// Debugger: \n\t\t// Trust in SqrNorm for setting result\n\n\t\treturn sqrt(SqrNorm());\n\t}\n\n//////////////////////////////////////////////\n\n\t// Get the squared norm\n\tconst float CQuaternion::SqrNorm() const\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Norm computed succesfully for quaternion\");\n\n\t\treturn w*w + x*x + y*y + z*z;\n\t}\n\n","/*\n\t* \\class CTransform\n\t*\n\t* \\brief Definition of rigid transformations (position and orientation).\n\t*\n\t* This class define the necessary algorithms for rigid transformations (position and orientation).\n\t*\n\t* \\version $Alpha 1.0$\n\t*\n\t* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n\t*\n\t* Contact: areyes@uma.es\n\t*\n\t* Created on: Jan 2016\n\t*\n\t* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n\t*\n\t* Module: 3DTI Toolkit/Core\n\t*/\n\t\n#include <Common/Transform.h>\n#include <Common/Debugger.h>\n\n//////////////////////////////////////////////\n// CONSTRUCTORS/DESTRUCTORS\n\n\tCTransform::CTransform()\n\t{\n\t\tposition = CVector3::ZERO;\n\t\torientation = CQuaternion::UNIT;\n\t}\n\n//////////////////////////////////////////////\n// GET METHODS\n\t\n\t// Returns a vector from \"this\" to target in \"this\" reference frame \n\tconst CVector3 CTransform::GetVectorTo(CTransform target) const\n\t{\t\t\n\t\t// Debugger:\n\t\t// Trust in RotateVector for setting result\n\n\t\t// Get position of target in global reference frame\n\t\tCVector3 targetPositionGlobal = target.GetPosition();\n\n\t\t// Translate target until \"this\" reference frame has its origin in the global origin\n\t\ttargetPositionGlobal = targetPositionGlobal - position;\n\n\t\t// Find new coordinates in \"this\" frame (rotated with respect to global)\n\t\tCVector3 targetPositionThis = orientation.RotateVector(targetPositionGlobal);\n\t\t\n\t\treturn targetPositionThis;\n\t}\n\n//////////////////////////////////////////////\n\n\tCVector3 CTransform::GetPosition()\n\t{\n\t\treturn position;\n\t}\n\n//////////////////////////////////////////////\n\n\tCQuaternion CTransform::GetOrientation()\n\t{\n\t\treturn orientation;\n\t}\n\n//////////////////////////////////////////////\n// SET METHODS\n\t\n\tvoid CTransform::SetPosition(CVector3 _position)\n\t{\n\t\tposition = _position;\n\t}\n\n//////////////////////////////////////////////\n\n\tvoid CTransform::SetOrientation(CQuaternion _orientation)\n\t{\n\t\torientation = _orientation;\n\t}\n\n//////////////////////////////////////////////\n// TRANSFORM METHODS\n\t\n\tvoid CTransform::Translate(CVector3 _translation)\n\t{\n\t\tposition = position + _translation;\n\t}\n\n//////////////////////////////////////////////\n\n\t// Rotate from axis and angle. This method can be overloaded depending on needs\n\tvoid CTransform::Rotate(CVector3 _axis, float _angle)\n\t{\n\t\t// Debugger:\n\t\t// Trust in FromAxisAngle and Rotate for setting result\n\n\t\tCQuaternion rotation = CQuaternion::FromAxisAngle(_axis, _angle);\n\t\torientation.Rotate(rotation);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Returns a new transform with a local translation applied to the position\n\tconst CTransform CTransform::GetLocalTranslation(CVector3 _translation) const\n\t{\n\t\t// Debugger: trust in called methods for setting result\n\n\t\tCTransform result;\n\t\tCVector3 newGlobalPosition = orientation.RotateVector(_translation) + position;\n\t\tresult.SetPosition(newGlobalPosition);\n\t\tresult.SetOrientation(orientation);\n\t\treturn result;\n\t}\n","////////////////////////////////////////////////\n// Project: 3D-Tune-In\n// Package: 3DTI Toolkit\n/*\n\t* \\class CVector3\n\t*\n\t* \\brief Definition of a class for 3D Vectors.\n\t*\n\t* This class define the vars and methods for 3D Vectors.\n\t*\n\t* \\version $Alpha 1.0$\n\t*\n\t* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n\t*\n\t* Contact: areyes@uma.es\n\t*\n\t* Created on: Jan 2016\n\t*\n\t* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n\t*\n\t* Module: 3DTI Toolkit/Core\n\t*/\n\n\t// ToDo:\n//\t\t+ Make sure conventions are taken into account\n//\t\t+ Simplify implementation of predefined rotation axis!!!\n\n\n#include <Common/Vector3.h>\n#define _USE_MATH_DEFINES // TODO: Test in windows! Might also be problematic for other platforms??\n#include <math.h>\n#include <Common/Debugger.h>\n#include <Common/Conventions.h>\n\nconstexpr float _2PI = 2.0f*M_PI;\n\n//////////////////////////////////////////////\n// BASIC PREDEFINED VECTORS\n\n\tconst CVector3 CVector3::ZERO(0.0f, 0.0f, 0.0f);\n\n//////////////////////////////////////////////\n// Predefined rotation axis for rotating in basic directions, using angle-axis rotation\n\n#if AZIMUTH_MOTION == ANTICLOCKWISE\n\t#if UP_AXIS == AXIS_Y\n\t\t//const CVector3 CVector3::TO_LEFT(0.0f, 1.0f, 0.0f);\n\t\t//const CVector3 CVector3::TO_RIGHT(0.0f, -1.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_LEFT(0.0f, -1.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_RIGHT(0.0f, 1.0f, 0.0f);\n\t#elif UP_AXIS == AXIS_X\n\t\tconst CVector3 CVector3::TO_LEFT(1.0f, 0.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_RIGHT(-1.0f, 0.0f, 0.0f);\n\t#elif UP_AXIS == AXIS_Z\n\t\tconst CVector3 CVector3::TO_LEFT(0.0f, 0.0f, 1.0f);\n\t\tconst CVector3 CVector3::TO_RIGHT(0.0f, 0.0f, -1.0f);\n\t#endif\n#elif AZIMUTH_MOTION == CLOCKWISE\n\t#if UP_AXIS == AXIS_Y\n\t\tconst CVector3 CVector3::TO_LEFT(0.0f, -1.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_RIGHT(0.0f, 1.0f, 0.0f);\n\t#elif UP_AXIS == AXIS_X\n\t\tconst CVector3 CVector3::TO_LEFT(-1.0f, 0.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_RIGHT(1.0f, 0.0f, 0.0f);\n\t#elif UP_AXIS == AXIS_Z\n\t\tconst CVector3 CVector3::TO_LEFT(0.0f, 0.0f, -1.0f);\n\t\tconst CVector3 CVector3::TO_RIGHT(0.0f, 0.0f, 1.0f);\n\t#endif\n#endif\n\n#if ELEVATION_MOTION == ANTICLOCKWISE\n#if RIGHT_AXIS == AXIS_X\n\t\tconst CVector3 CVector3::TO_UP(1.0f, 0.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_DOWN(-1.0f, 0.0f, 0.0f);\n#elif RIGHT_AXIS == AXIS_Y\n\t\tconst CVector3 CVector3::TO_UP(0.0f, 1.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_DOWN(0.0f, -1.0f, 0.0f);\n#elif RIGHT_AXIS == AXIS_Z\n\t\tconst CVector3 CVector3::TO_UP(0.0f, 0.0f, 1.0f);\n\t\tconst CVector3 CVector3::TO_DOWN(0.0f, 0.0f, -1.0f);\n#endif\n#elif ELEVATION_MOTION == CLOCKWISE\n#if RIGHT_AXIS == AXIS_X\n\t\tconst CVector3 CVector3::TO_UP(-1.0f, 0.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_DOWN(1.0f, 0.0f, 0.0f);\n#elif RIGHT_AXIS == AXIS_Y\n\t\tconst CVector3 CVector3::TO_UP(0.0f, -1.0f, 0.0f);\n\t\tconst CVector3 CVector3::TO_DOWN(0.0f, 1.0f, 0.0f);\n#elif RIGHT_AXIS == AXIS_Z\n\t\tconst CVector3 CVector3::TO_UP(0.0f, 0.0f, -1.0f);\n\t\tconst CVector3 CVector3::TO_DOWN(0.0f, 0.0f, 1.0f);\n#endif\n#endif\n\ndouble SafeAcos(double x)\n{\n\tif      (x < -1.0) x = -1.0;\n\telse if (x > 1.0 ) x = 1.0;\n\treturn acos(x);\n}\n\n//////////////////////////////////////////////\n// CONSTRUCTORS/DESTRUCTORS\n\n\tCVector3::CVector3()\n\t{\n\t\tCVector3::ZERO;\n\t}\n\n////////////////////////////////////////////////\n\n\tCVector3::CVector3(float _xyzArray [3])\n\t{\n\t\tx = _xyzArray[0];\n\t\ty = _xyzArray[1];\n\t\tz = _xyzArray[2];\t\t\n\t}\n\n////////////////////////////////////////////////\n\n\tCVector3::CVector3(float _x, float _y, float _z)\n\t{\n\t\tx = _x;\n\t\ty = _y;\n\t\tz = _z;\t\t\n\t}\n\n//////////////////////////////////////////////\n// GET METHODS\n\t\n\t// Get distance (vector modulus) in whatever units you are using\n\tconst float CVector3::GetDistance() const\n\t{\n\t\t// Debugger: trust in GetSqrDistance\n\t\t// Sqrt may set errno if the argument is negative, but we have full control on this argument and we know that it can never be negative\t\t\n\t\treturn sqrt(GetSqrDistance());\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get square of distance (avoid computing square roots)\n\tconst float CVector3::GetSqrDistance() const\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Distance computed succesfully.\");\n\n\t\t//return (x*x + y*y + z*z);\n\t\treturn (x*x + y*y + z*z);\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get elevation in radians, according to the selected axis convention. Currently uses LISTEN database convention for elevation angles: full circle starting with 0 in front towards up. \n\tconst float CVector3::GetElevationRadians() const\n\t{\n\t\t// Debugger:\n\t\tfloat distance = GetDistance();\n\t\tif (distance == 0.0f)\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_DIVBYZERO, \"Distance from source to listener is zero\");\n\t\t\treturn 0.0f;\n\t\t}\n\t\t//else\n\t\t//\tSET_RESULT(RESULT_OK, \"Elevation computed from vector succesfully\");\t// No more possible errors. \n\n\t\t// 0=front; 90=up; -90=down\n\t\t//float cosAngle = *upAxis / GetDistance(); // Error check: division by zero\n\t\t//float angle = SafeAcos(cosAngle);\n\t\t//return (M_PI / 2.0f) - angle;\n\t\t\n\t\t// 0=front; 90=up; 270=down (LISTEN)\n\t\tfloat cosAngle = GetAxis(UP_AXIS) / distance;\n\t\tfloat angle = SafeAcos(cosAngle);\n\t\tfloat adjustedAngle = (M_PI * 2.5f) - angle;\n\n\t\t// Check limits (always return 0 instead of 2PI)\n\t\tif (adjustedAngle >= _2PI)\n\t\t\tadjustedAngle = fmod(adjustedAngle, (float)_2PI);\n\n\t\treturn adjustedAngle;\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get azimuth in radians, according to the selected axis convention. Currently uses LISTEN database convention for azimuth angles: anti-clockwise full circle starting with 0 in front.\n\tconst float CVector3::GetAzimuthRadians() const\n\t{\n\t\t// Debugger:\n\t\tfloat rightAxis = GetAxis(RIGHT_AXIS);\n\t\tfloat forwardAxis = GetAxis(FORWARD_AXIS);\n\t\tif ((rightAxis == 0.0f) && (forwardAxis == 0.0f))\n\t\t\tASSERT(false, RESULT_ERROR_DIVBYZERO, \"Axes are not correctly set. Please, check axis conventions\", \"Azimuth computed from vector succesfully\");\n\n\t\t// front=0; left=-90; right=90\n\t\t//return atan2(*rightAxis, *forwardAxis);\t\t\n\n\t\t//front=0; left=90; right=270 (LISTEN)\n\t\tfloat angle = atan2(GetAxis(RIGHT_AXIS), GetAxis(FORWARD_AXIS));\n\t\tfloat adjustedAngle = fmod((float)(_2PI - angle), (float)_2PI);\n\n\t\t// Check limits (always return 0 instead of 2PI)\n\t\tif (adjustedAngle >= _2PI)\n\t\t\tadjustedAngle = fmod(adjustedAngle, (float)_2PI);\n\n\t\treturn adjustedAngle;\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get elevation in degrees, according to the selected axis convention. Currently uses LISTEN database convention for elevation angles: full circle starting with 0 in front towards up. \n\tconst float CVector3::GetElevationDegrees() const\n\t{\n\t\t// Debugger:\n\t\t// Trust in GetElevationRadians for setting result\n\n\t\treturn GetElevationRadians() * (180.0f / M_PI);\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get azimuth in degress, according to the selected axis convention. Currently uses LISTEN database convention for azimuth angles: anti-clockwise full circle starting with 0 in front. \n\tconst float CVector3::GetAzimuthDegrees() const\n\t{\n\t\t// Debugger:\n\t\t// Trust in GetAzimuthRadians for setting result\n\n\t\treturn GetAzimuthRadians() * (180.0f / M_PI);\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Set the x,y,z coordinates from azimuth, elevation and distance. Currently uses LISTEN database convention for azimuth angles : anti - clockwise full circle starting with 0 in front.\n\tvoid CVector3::SetFromAED(float azimuth, float elevation, float distance)\n\t{\n\t\tazimuth   = azimuth   * (M_PI / 180.0f);\n\t\televation = elevation * (M_PI / 180.0f);\n\n\t\tfloat up = sin( elevation );\n\n\t\tfloat pd = cos(elevation); // pd -> projected distance (on the horizontal plane).\n\n\t\tfloat right   = -pd * sin(azimuth);   // minus sign to fit the LISTEN database convention\n\t\tfloat forward =  pd * cos(azimuth);\n\n\t\tSetAxis( UP_AXIS     , up      * distance );\n\t\tSetAxis( RIGHT_AXIS  , right   * distance );\n\t\tSetAxis( FORWARD_AXIS, forward * distance );  \n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get the interaural azimut angle in radians, according to the selected axis convention. Currently uses LISTEN database convention for elevation angles: full circle starting with 0 in front towards up.  \n\tconst float CVector3::GetInterauralAzimuthRadians() const\n\t{\n\t\tfloat distance = GetDistance();\n\t\tif (distance == 0.0f)\n\t\t{\n\t\t\tSET_RESULT( RESULT_ERROR_DIVBYZERO, \"Distance from source to listener is zero\");\n\t\t\treturn 0.0f;\n\t\t}\n\t\t//else\n\t\t//\tSET_RESULT(RESULT_OK, \"Interaural azimuth computed from vector succesfully\");\t// No more possible errors. \n\n\t\tfloat f = GetAxis( FORWARD_AXIS );\n\t\tfloat u = GetAxis( UP_AXIS      );\n\t\tfloat r = GetAxis( RIGHT_AXIS   );\n\t\tfloat angle = SafeAcos(sqrt(f*f + u*u) / distance);\n\n\t\treturn r > 0 ? angle : -angle;\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get the interaural elevation angle in radians, according to the selected axis convention. Currently uses LISTEN database convention for elevation angles: full circle starting with 0 in front towards up.  \n\tconst float CVector3::GetInterauralElevationRadians() const\n\t{\n\t\tfloat distance = GetDistance();\n\t\tif (distance == 0.0f)\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_DIVBYZERO, \"Distance from source to listener is zero\");\n\t\t\treturn 0.0f;\n\t\t}\n\t\t//else\n\t\t//\tSET_RESULT(RESULT_OK, \"Interaural elevation computed from vector succesfully\");\t// No more possible errors. \n\n\t\tfloat angle = atan2(GetAxis(UP_AXIS), GetAxis(FORWARD_AXIS));\n\t\treturn angle >= 0 ? angle : angle + 2.0 * M_PI;\n\t}\n\t//////////////////////////////////////////////\n\tconst float CVector3::GetInterauralAzimuthDegrees() const\n\t{\n\t\t// Debugger:\n\t\t// Trust in GetInterauralAzimutRadians for setting result\n\t\treturn GetInterauralAzimuthRadians() * (180.0f / M_PI);\n\t}\n\t//////////////////////////////////////////////\n\tconst float CVector3::GetInterauralElevationDegrees() const \n\t{\n\t\t// Debugger:\n\t\t// Trust in GetInterauralElevationRadians for setting result\n\t\treturn GetInterauralElevationRadians() * (180.0f / M_PI);\n\t}\n\n//////////////////////////////////////////////\n// SET METHODS\n\t\n\tvoid CVector3::SetCoordinates(float _x, float _y, float _z)\n\t{\n\t\tx = _x;\n\t\ty = _y;\n\t\tz = _z;\n\t}\n\n//////////////////////////////////////////////\n\n\t//void CVector3::SetAxisConvention(CAxisConvention _axisConvention)\n\t//{\n\t//\taxisConvention = _axisConvention;\n\t//}\n\n//////////////////////////////////////////////\n\n\tconst float CVector3::GetAxis(TAxis _axis) const\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Succesfully got axis from convention.\");\n\n\t\tswitch (_axis)\n\t\t{\n\t\t\tcase AXIS_X: return x; break;\n\t\t\tcase AXIS_Y: return y; break;\n\t\t\tcase AXIS_Z: return z; break;\n\t\t\tcase AXIS_MINUS_X: return -x; break;\n\t\t\tcase AXIS_MINUS_Y: return -y; break;\n\t\t\tcase AXIS_MINUS_Z: return -z; break;\n\t\t\tdefault: SET_RESULT(RESULT_ERROR_CASENOTDEFINED, \"Trying to get an axis which name is not defined\");  return 0.0f;\n\t\t}\n\t}\n\n//////////////////////////////////////////////\n\n\tvoid CVector3::SetAxis(TAxis _axis, float value)\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Succesfully set axis from convention.\");\n\n\t\tswitch (_axis)\n\t\t{\n\t\t\tcase AXIS_X: x = value; break;\n\t\t\tcase AXIS_Y: y = value; break;\n\t\t\tcase AXIS_Z: z = value; break;\n\t\t\tcase AXIS_MINUS_X: x = -value;\tbreak;\n\t\t\tcase AXIS_MINUS_Y: y = -value;\tbreak;\n\t\t\tcase AXIS_MINUS_Z: z = -value;\tbreak;\n\t\t\tdefault: SET_RESULT(RESULT_ERROR_CASENOTDEFINED, \"Trying to set an axis which name is not defined\");  \n\t\t}\n\t}\n\n//////////////////////////////////////////////\n// BASIC VECTOR OPERANDS\n\t\n\tCVector3 CVector3::operator-(CVector3 const _rightHand)\n\t{\n\t\treturn CVector3(x - _rightHand.x, y - _rightHand.y, z - _rightHand.z);\n\t}\n\n//////////////////////////////////////////////\n\n\tconst CVector3 CVector3::operator+(CVector3 const _rightHand) const\n\t{\n\t\treturn CVector3(x + _rightHand.x, y + _rightHand.y, z + _rightHand.z);\n\t}\n\n//////////////////////////////////////////////\n\n\tfloat CVector3::DotProduct(CVector3 _rightHand)\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Dot product computed succesfully\");\n\n\t\treturn (x*_rightHand.x + y*_rightHand.y + z*_rightHand.z);\n\t}\n\n//////////////////////////////////////////////\n\t\n\tCVector3 CVector3::CrossProduct(CVector3 _rightHand)\n\t{\n\t\t// Debugger:\n\t\t//SET_RESULT(RESULT_OK, \"Cross product computed sucessfully\");\n\n\t\tCVector3 result;\n\t\t\n\t\tresult.x = y*_rightHand.z - z*_rightHand.y;\n\t\tresult.y = z*_rightHand.x - x*_rightHand.z;\n\t\tresult.x = x*_rightHand.y - y*_rightHand.x;\t\t\n\n\t\treturn result;\n\t}\n","#include <Common/fftsg.h>\n\n//#define USE_CDFT_PTHREADS\n//#define USE_CDFT_WINTHREADS\n\n/*\nGeneral Purpose FFT(Fast Fourier / Cosine / Sine Transform) Package\n\nCopyright:\nCopyright(C) 1996-2001 Takuya OOURA\nemail: ooura@mmm.t.u-tokyo.ac.jp\ndownload: http://momonga.t.u-tokyo.ac.jp/~ooura/fft.html\nYou may use, copy, modify this code for any purpose and\nwithout fee. You may distribute this ORIGINAL package.\n*/\n\nvoid cdft(int n, int isgn, double *a, int *ip, double *w)\n{\n\tint nw;\n\n\tnw = ip[0];\n\tif (n > (nw << 2)) {\n\t\tnw = n >> 2;\n\t\tmakewt(nw, ip, w);\n\t}\n\tif (isgn >= 0) {\n\t\tcftfsub(n, a, ip, nw, w);\n\t}\n\telse {\n\t\tcftbsub(n, a, ip, nw, w);\n\t}\n}\n\n\nvoid rdft(int n, int isgn, double *a, int *ip, double *w)\n{\n\n\tint nw, nc;\n\tdouble xi;\n\n\tnw = ip[0];\n\tif (n > (nw << 2)) {\n\t\tnw = n >> 2;\n\t\tmakewt(nw, ip, w);\n\t}\n\tnc = ip[1];\n\tif (n > (nc << 2)) {\n\t\tnc = n >> 2;\n\t\tmakect(nc, ip, w + nw);\n\t}\n\tif (isgn >= 0) {\n\t\tif (n > 4) {\n\t\t\tcftfsub(n, a, ip, nw, w);\n\t\t\trftfsub(n, a, nc, w + nw);\n\t\t}\n\t\telse if (n == 4) {\n\t\t\tcftfsub(n, a, ip, nw, w);\n\t\t}\n\t\txi = a[0] - a[1];\n\t\ta[0] += a[1];\n\t\ta[1] = xi;\n\t}\n\telse {\n\t\ta[1] = 0.5 * (a[0] - a[1]);\n\t\ta[0] -= a[1];\n\t\tif (n > 4) {\n\t\t\trftbsub(n, a, nc, w + nw);\n\t\t\tcftbsub(n, a, ip, nw, w);\n\t\t}\n\t\telse if (n == 4) {\n\t\t\tcftbsub(n, a, ip, nw, w);\n\t\t}\n\t}\n}\n\n\nvoid ddct(int n, int isgn, double *a, int *ip, double *w)\n{\n\n\tint j, nw, nc;\n\tdouble xr;\n\n\tnw = ip[0];\n\tif (n > (nw << 2)) {\n\t\tnw = n >> 2;\n\t\tmakewt(nw, ip, w);\n\t}\n\tnc = ip[1];\n\tif (n > nc) {\n\t\tnc = n;\n\t\tmakect(nc, ip, w + nw);\n\t}\n\tif (isgn < 0) {\n\t\txr = a[n - 1];\n\t\tfor (j = n - 2; j >= 2; j -= 2) {\n\t\t\ta[j + 1] = a[j] - a[j - 1];\n\t\t\ta[j] += a[j - 1];\n\t\t}\n\t\ta[1] = a[0] - xr;\n\t\ta[0] += xr;\n\t\tif (n > 4) {\n\t\t\trftbsub(n, a, nc, w + nw);\n\t\t\tcftbsub(n, a, ip, nw, w);\n\t\t}\n\t\telse if (n == 4) {\n\t\t\tcftbsub(n, a, ip, nw, w);\n\t\t}\n\t}\n\tdctsub(n, a, nc, w + nw);\n\tif (isgn >= 0) {\n\t\tif (n > 4) {\n\t\t\tcftfsub(n, a, ip, nw, w);\n\t\t\trftfsub(n, a, nc, w + nw);\n\t\t}\n\t\telse if (n == 4) {\n\t\t\tcftfsub(n, a, ip, nw, w);\n\t\t}\n\t\txr = a[0] - a[1];\n\t\ta[0] += a[1];\n\t\tfor (j = 2; j < n; j += 2) {\n\t\t\ta[j - 1] = a[j] - a[j + 1];\n\t\t\ta[j] += a[j + 1];\n\t\t}\n\t\ta[n - 1] = xr;\n\t}\n}\n\n\nvoid ddst(int n, int isgn, double *a, int *ip, double *w)\n{\n\n\tint j, nw, nc;\n\tdouble xr;\n\n\tnw = ip[0];\n\tif (n > (nw << 2)) {\n\t\tnw = n >> 2;\n\t\tmakewt(nw, ip, w);\n\t}\n\tnc = ip[1];\n\tif (n > nc) {\n\t\tnc = n;\n\t\tmakect(nc, ip, w + nw);\n\t}\n\tif (isgn < 0) {\n\t\txr = a[n - 1];\n\t\tfor (j = n - 2; j >= 2; j -= 2) {\n\t\t\ta[j + 1] = -a[j] - a[j - 1];\n\t\t\ta[j] -= a[j - 1];\n\t\t}\n\t\ta[1] = a[0] + xr;\n\t\ta[0] -= xr;\n\t\tif (n > 4) {\n\t\t\trftbsub(n, a, nc, w + nw);\n\t\t\tcftbsub(n, a, ip, nw, w);\n\t\t}\n\t\telse if (n == 4) {\n\t\t\tcftbsub(n, a, ip, nw, w);\n\t\t}\n\t}\n\tdstsub(n, a, nc, w + nw);\n\tif (isgn >= 0) {\n\t\tif (n > 4) {\n\t\t\tcftfsub(n, a, ip, nw, w);\n\t\t\trftfsub(n, a, nc, w + nw);\n\t\t}\n\t\telse if (n == 4) {\n\t\t\tcftfsub(n, a, ip, nw, w);\n\t\t}\n\t\txr = a[0] - a[1];\n\t\ta[0] += a[1];\n\t\tfor (j = 2; j < n; j += 2) {\n\t\t\ta[j - 1] = -a[j] - a[j + 1];\n\t\t\ta[j] -= a[j + 1];\n\t\t}\n\t\ta[n - 1] = -xr;\n\t}\n}\n\n\nvoid dfct(int n, double *a, double *t, int *ip, double *w)\n{\n\n\tint j, k, l, m, mh, nw, nc;\n\tdouble xr, xi, yr, yi;\n\n\tnw = ip[0];\n\tif (n > (nw << 3)) {\n\t\tnw = n >> 3;\n\t\tmakewt(nw, ip, w);\n\t}\n\tnc = ip[1];\n\tif (n > (nc << 1)) {\n\t\tnc = n >> 1;\n\t\tmakect(nc, ip, w + nw);\n\t}\n\tm = n >> 1;\n\tyi = a[m];\n\txi = a[0] + a[n];\n\ta[0] -= a[n];\n\tt[0] = xi - yi;\n\tt[m] = xi + yi;\n\tif (n > 2) {\n\t\tmh = m >> 1;\n\t\tfor (j = 1; j < mh; j++) {\n\t\t\tk = m - j;\n\t\t\txr = a[j] - a[n - j];\n\t\t\txi = a[j] + a[n - j];\n\t\t\tyr = a[k] - a[n - k];\n\t\t\tyi = a[k] + a[n - k];\n\t\t\ta[j] = xr;\n\t\t\ta[k] = yr;\n\t\t\tt[j] = xi - yi;\n\t\t\tt[k] = xi + yi;\n\t\t}\n\t\tt[mh] = a[mh] + a[n - mh];\n\t\ta[mh] -= a[n - mh];\n\t\tdctsub(m, a, nc, w + nw);\n\t\tif (m > 4) {\n\t\t\tcftfsub(m, a, ip, nw, w);\n\t\t\trftfsub(m, a, nc, w + nw);\n\t\t}\n\t\telse if (m == 4) {\n\t\t\tcftfsub(m, a, ip, nw, w);\n\t\t}\n\t\ta[n - 1] = a[0] - a[1];\n\t\ta[1] = a[0] + a[1];\n\t\tfor (j = m - 2; j >= 2; j -= 2) {\n\t\t\ta[2 * j + 1] = a[j] + a[j + 1];\n\t\t\ta[2 * j - 1] = a[j] - a[j + 1];\n\t\t}\n\t\tl = 2;\n\t\tm = mh;\n\t\twhile (m >= 2) {\n\t\t\tdctsub(m, t, nc, w + nw);\n\t\t\tif (m > 4) {\n\t\t\t\tcftfsub(m, t, ip, nw, w);\n\t\t\t\trftfsub(m, t, nc, w + nw);\n\t\t\t}\n\t\t\telse if (m == 4) {\n\t\t\t\tcftfsub(m, t, ip, nw, w);\n\t\t\t}\n\t\t\ta[n - l] = t[0] - t[1];\n\t\t\ta[l] = t[0] + t[1];\n\t\t\tk = 0;\n\t\t\tfor (j = 2; j < m; j += 2) {\n\t\t\t\tk += l << 2;\n\t\t\t\ta[k - l] = t[j] - t[j + 1];\n\t\t\t\ta[k + l] = t[j] + t[j + 1];\n\t\t\t}\n\t\t\tl <<= 1;\n\t\t\tmh = m >> 1;\n\t\t\tfor (j = 0; j < mh; j++) {\n\t\t\t\tk = m - j;\n\t\t\t\tt[j] = t[m + k] - t[m + j];\n\t\t\t\tt[k] = t[m + k] + t[m + j];\n\t\t\t}\n\t\t\tt[mh] = t[m + mh];\n\t\t\tm = mh;\n\t\t}\n\t\ta[l] = t[0];\n\t\ta[n] = t[2] - t[1];\n\t\ta[0] = t[2] + t[1];\n\t}\n\telse {\n\t\ta[1] = a[0];\n\t\ta[2] = t[0];\n\t\ta[0] = t[1];\n\t}\n}\n\n\nvoid dfst(int n, double *a, double *t, int *ip, double *w)\n{\n\n\tint j, k, l, m, mh, nw, nc;\n\tdouble xr, xi, yr, yi;\n\n\tnw = ip[0];\n\tif (n > (nw << 3)) {\n\t\tnw = n >> 3;\n\t\tmakewt(nw, ip, w);\n\t}\n\tnc = ip[1];\n\tif (n > (nc << 1)) {\n\t\tnc = n >> 1;\n\t\tmakect(nc, ip, w + nw);\n\t}\n\tif (n > 2) {\n\t\tm = n >> 1;\n\t\tmh = m >> 1;\n\t\tfor (j = 1; j < mh; j++) {\n\t\t\tk = m - j;\n\t\t\txr = a[j] + a[n - j];\n\t\t\txi = a[j] - a[n - j];\n\t\t\tyr = a[k] + a[n - k];\n\t\t\tyi = a[k] - a[n - k];\n\t\t\ta[j] = xr;\n\t\t\ta[k] = yr;\n\t\t\tt[j] = xi + yi;\n\t\t\tt[k] = xi - yi;\n\t\t}\n\t\tt[0] = a[mh] - a[n - mh];\n\t\ta[mh] += a[n - mh];\n\t\ta[0] = a[m];\n\t\tdstsub(m, a, nc, w + nw);\n\t\tif (m > 4) {\n\t\t\tcftfsub(m, a, ip, nw, w);\n\t\t\trftfsub(m, a, nc, w + nw);\n\t\t}\n\t\telse if (m == 4) {\n\t\t\tcftfsub(m, a, ip, nw, w);\n\t\t}\n\t\ta[n - 1] = a[1] - a[0];\n\t\ta[1] = a[0] + a[1];\n\t\tfor (j = m - 2; j >= 2; j -= 2) {\n\t\t\ta[2 * j + 1] = a[j] - a[j + 1];\n\t\t\ta[2 * j - 1] = -a[j] - a[j + 1];\n\t\t}\n\t\tl = 2;\n\t\tm = mh;\n\t\twhile (m >= 2) {\n\t\t\tdstsub(m, t, nc, w + nw);\n\t\t\tif (m > 4) {\n\t\t\t\tcftfsub(m, t, ip, nw, w);\n\t\t\t\trftfsub(m, t, nc, w + nw);\n\t\t\t}\n\t\t\telse if (m == 4) {\n\t\t\t\tcftfsub(m, t, ip, nw, w);\n\t\t\t}\n\t\t\ta[n - l] = t[1] - t[0];\n\t\t\ta[l] = t[0] + t[1];\n\t\t\tk = 0;\n\t\t\tfor (j = 2; j < m; j += 2) {\n\t\t\t\tk += l << 2;\n\t\t\t\ta[k - l] = -t[j] - t[j + 1];\n\t\t\t\ta[k + l] = t[j] - t[j + 1];\n\t\t\t}\n\t\t\tl <<= 1;\n\t\t\tmh = m >> 1;\n\t\t\tfor (j = 1; j < mh; j++) {\n\t\t\t\tk = m - j;\n\t\t\t\tt[j] = t[m + k] + t[m + j];\n\t\t\t\tt[k] = t[m + k] - t[m + j];\n\t\t\t}\n\t\t\tt[0] = t[m + mh];\n\t\t\tm = mh;\n\t\t}\n\t\ta[l] = t[0];\n\t}\n\ta[0] = 0;\n}\n\n\n/* -------- initializing routines -------- */\nvoid makewt(int nw, int *ip, double *w)\n{\n\tint j, nwh, nw0, nw1;\n\tdouble delta, wn4r, wk1r, wk1i, wk3r, wk3i;\n\n\tip[0] = nw;\n\tip[1] = 1;\n\tif (nw > 2) {\n\t\tnwh = nw >> 1;\n\t\tdelta = atan(1.0) / nwh;\n\t\twn4r = cos(delta * nwh);\n\t\tw[0] = 1;\n\t\tw[1] = wn4r;\n\t\tif (nwh == 4) {\n\t\t\tw[2] = cos(delta * 2);\n\t\t\tw[3] = sin(delta * 2);\n\t\t}\n\t\telse if (nwh > 4) {\n\t\t\tmakeipt(nw, ip);\n\t\t\tw[2] = 0.5 / cos(delta * 2);\n\t\t\tw[3] = 0.5 / cos(delta * 6);\n\t\t\tfor (j = 4; j < nwh; j += 4) {\n\t\t\t\tw[j] = cos(delta * j);\n\t\t\t\tw[j + 1] = sin(delta * j);\n\t\t\t\tw[j + 2] = cos(3 * delta * j);\n\t\t\t\tw[j + 3] = -sin(3 * delta * j);\n\t\t\t}\n\t\t}\n\t\tnw0 = 0;\n\t\twhile (nwh > 2) {\n\t\t\tnw1 = nw0 + nwh;\n\t\t\tnwh >>= 1;\n\t\t\tw[nw1] = 1;\n\t\t\tw[nw1 + 1] = wn4r;\n\t\t\tif (nwh == 4) {\n\t\t\t\twk1r = w[nw0 + 4];\n\t\t\t\twk1i = w[nw0 + 5];\n\t\t\t\tw[nw1 + 2] = wk1r;\n\t\t\t\tw[nw1 + 3] = wk1i;\n\t\t\t}\n\t\t\telse if (nwh > 4) {\n\t\t\t\twk1r = w[nw0 + 4];\n\t\t\t\twk3r = w[nw0 + 6];\n\t\t\t\tw[nw1 + 2] = 0.5 / wk1r;\n\t\t\t\tw[nw1 + 3] = 0.5 / wk3r;\n\t\t\t\tfor (j = 4; j < nwh; j += 4) {\n\t\t\t\t\twk1r = w[nw0 + 2 * j];\n\t\t\t\t\twk1i = w[nw0 + 2 * j + 1];\n\t\t\t\t\twk3r = w[nw0 + 2 * j + 2];\n\t\t\t\t\twk3i = w[nw0 + 2 * j + 3];\n\t\t\t\t\tw[nw1 + j] = wk1r;\n\t\t\t\t\tw[nw1 + j + 1] = wk1i;\n\t\t\t\t\tw[nw1 + j + 2] = wk3r;\n\t\t\t\t\tw[nw1 + j + 3] = wk3i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnw0 = nw1;\n\t\t}\n\t}\n}\n\n\nvoid makeipt(int nw, int *ip)\n{\n\tint j, l, m, m2, p, q;\n\n\tip[2] = 0;\n\tip[3] = 16;\n\tm = 2;\n\tfor (l = nw; l > 32; l >>= 2) {\n\t\tm2 = m << 1;\n\t\tq = m2 << 3;\n\t\tfor (j = m; j < m2; j++) {\n\t\t\tp = ip[j] << 2;\n\t\t\tip[m + j] = p;\n\t\t\tip[m2 + j] = p + q;\n\t\t}\n\t\tm = m2;\n\t}\n}\n\n\nvoid makect(int nc, int *ip, double *c)\n{\n\tint j, nch;\n\tdouble delta;\n\n\tip[1] = nc;\n\tif (nc > 1) {\n\t\tnch = nc >> 1;\n\t\tdelta = atan(1.0) / nch;\n\t\tc[0] = cos(delta * nch);\n\t\tc[nch] = 0.5 * c[0];\n\t\tfor (j = 1; j < nch; j++) {\n\t\t\tc[j] = 0.5 * cos(delta * j);\n\t\t\tc[nc - j] = 0.5 * sin(delta * j);\n\t\t}\n\t}\n}\n\n\n/* -------- child routines -------- */\n\n\n#ifdef USE_CDFT_PTHREADS\n#define USE_CDFT_THREADS\n#ifndef CDFT_THREADS_BEGIN_N\n#define CDFT_THREADS_BEGIN_N 8192\n#endif\n#ifndef CDFT_4THREADS_BEGIN_N\n#define CDFT_4THREADS_BEGIN_N 65536\n#endif\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define cdft_thread_t pthread_t\n#define cdft_thread_create(thp,func,argp) { \\\n    if (pthread_create(thp, NULL, func, (void *) argp) != 0) { \\\n        fprintf(stderr, \"cdft thread error\\n\"); \\\n        exit(1); \\\n    } \\\n}\n#define cdft_thread_wait(th) { \\\n    if (pthread_join(th, NULL) != 0) { \\\n        fprintf(stderr, \"cdft thread error\\n\"); \\\n        exit(1); \\\n    } \\\n}\n#endif /* USE_CDFT_PTHREADS */\n\n\n#ifdef USE_CDFT_WINTHREADS\n#define USE_CDFT_THREADS\n#ifndef CDFT_THREADS_BEGIN_N\n#define CDFT_THREADS_BEGIN_N 32768\n#endif\n#ifndef CDFT_4THREADS_BEGIN_N\n#define CDFT_4THREADS_BEGIN_N 524288\n#endif\n#include <windows.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define cdft_thread_t HANDLE\n#define cdft_thread_create(thp,func,argp) { \\\n    DWORD thid; \\\n    *(thp) = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) func, (LPVOID) argp, 0, &thid); \\\n    if (*(thp) == 0) { \\\n        fprintf(stderr, \"cdft thread error\\n\"); \\\n        exit(1); \\\n    } \\\n}\n#define cdft_thread_wait(th) { \\\n    WaitForSingleObject(th, INFINITE); \\\n    CloseHandle(th); \\\n}\n#endif /* USE_CDFT_WINTHREADS */\n\n\nvoid cftfsub(int n, double *a, int *ip, int nw, double *w)\n{\n\n#ifdef USE_CDFT_THREADS\n\tvoid cftrec4_th(int n, double *a, int nw, double *w);\n#endif /* USE_CDFT_THREADS */\n\n\tif (n > 8) {\n\t\tif (n > 32) {\n\t\t\tcftf1st(n, a, &w[nw - (n >> 2)]);\n#ifdef USE_CDFT_THREADS\n\t\t\tif (n > CDFT_THREADS_BEGIN_N) {\n\t\t\t\tcftrec4_th(n, a, nw, w);\n\t\t\t}\n\t\t\telse\n#endif /* USE_CDFT_THREADS */\n\t\t\t\tif (n > 512) {\n\t\t\t\t\tcftrec4(n, a, nw, w);\n\t\t\t\t}\n\t\t\t\telse if (n > 128) {\n\t\t\t\t\tcftleaf(n, 1, a, nw, w);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcftfx41(n, a, nw, w);\n\t\t\t\t}\n\t\t\t\tbitrv2(n, ip, a);\n\t\t}\n\t\telse if (n == 32) {\n\t\t\tcftf161(a, &w[nw - 8]);\n\t\t\tbitrv216(a);\n\t\t}\n\t\telse {\n\t\t\tcftf081(a, w);\n\t\t\tbitrv208(a);\n\t\t}\n\t}\n\telse if (n == 8) {\n\t\tcftf040(a);\n\t}\n\telse if (n == 4) {\n\t\tcftx020(a);\n\t}\n}\n\n\nvoid cftbsub(int n, double *a, int *ip, int nw, double *w)\n{\n\n#ifdef USE_CDFT_THREADS\n\tvoid cftrec4_th(int n, double *a, int nw, double *w);\n#endif /* USE_CDFT_THREADS */\n\n\tif (n > 8) {\n\t\tif (n > 32) {\n\t\t\tcftb1st(n, a, &w[nw - (n >> 2)]);\n#ifdef USE_CDFT_THREADS\n\t\t\tif (n > CDFT_THREADS_BEGIN_N) {\n\t\t\t\tcftrec4_th(n, a, nw, w);\n\t\t\t}\n\t\t\telse\n#endif /* USE_CDFT_THREADS */\n\t\t\t\tif (n > 512) {\n\t\t\t\t\tcftrec4(n, a, nw, w);\n\t\t\t\t}\n\t\t\t\telse if (n > 128) {\n\t\t\t\t\tcftleaf(n, 1, a, nw, w);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcftfx41(n, a, nw, w);\n\t\t\t\t}\n\t\t\t\tbitrv2conj(n, ip, a);\n\t\t}\n\t\telse if (n == 32) {\n\t\t\tcftf161(a, &w[nw - 8]);\n\t\t\tbitrv216neg(a);\n\t\t}\n\t\telse {\n\t\t\tcftf081(a, w);\n\t\t\tbitrv208neg(a);\n\t\t}\n\t}\n\telse if (n == 8) {\n\t\tcftb040(a);\n\t}\n\telse if (n == 4) {\n\t\tcftx020(a);\n\t}\n}\n\n\nvoid bitrv2(int n, int *ip, double *a)\n{\n\tint j, j1, k, k1, l, m, nh, nm;\n\tdouble xr, xi, yr, yi;\n\n\tm = 1;\n\tfor (l = n >> 2; l > 8; l >>= 2) {\n\t\tm <<= 1;\n\t}\n\tnh = n >> 1;\n\tnm = 4 * m;\n\tif (l == 8) {\n\t\tfor (k = 0; k < m; k++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tj1 = 4 * j + 2 * ip[m + k];\n\t\t\t\tk1 = 4 * k + 2 * ip[m + j];\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nh;\n\t\t\t\tk1 += 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += 2;\n\t\t\t\tk1 += nh;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nh;\n\t\t\t\tk1 -= 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t}\n\t\t\tk1 = 4 * k + 2 * ip[m + k];\n\t\t\tj1 = k1 + 2;\n\t\t\tk1 += nh;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 += nm;\n\t\t\tk1 += 2 * nm;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 += nm;\n\t\t\tk1 -= nm;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 -= 2;\n\t\t\tk1 -= nh;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 += nh + 2;\n\t\t\tk1 += nh + 2;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 -= nh - nm;\n\t\t\tk1 += 2 * nm - 2;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t}\n\t}\n\telse {\n\t\tfor (k = 0; k < m; k++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tj1 = 4 * j + ip[m + k];\n\t\t\t\tk1 = 4 * k + ip[m + j];\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nh;\n\t\t\t\tk1 += 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += 2;\n\t\t\t\tk1 += nh;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nh;\n\t\t\t\tk1 -= 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t}\n\t\t\tk1 = 4 * k + ip[m + k];\n\t\t\tj1 = k1 + 2;\n\t\t\tk1 += nh;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 += nm;\n\t\t\tk1 += nm;\n\t\t\txr = a[j1];\n\t\t\txi = a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t}\n\t}\n}\n\n\nvoid bitrv2conj(int n, int *ip, double *a)\n{\n\tint j, j1, k, k1, l, m, nh, nm;\n\tdouble xr, xi, yr, yi;\n\n\tm = 1;\n\tfor (l = n >> 2; l > 8; l >>= 2) {\n\t\tm <<= 1;\n\t}\n\tnh = n >> 1;\n\tnm = 4 * m;\n\tif (l == 8) {\n\t\tfor (k = 0; k < m; k++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tj1 = 4 * j + 2 * ip[m + k];\n\t\t\t\tk1 = 4 * k + 2 * ip[m + j];\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nh;\n\t\t\t\tk1 += 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += 2;\n\t\t\t\tk1 += nh;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nh;\n\t\t\t\tk1 -= 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= 2 * nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t}\n\t\t\tk1 = 4 * k + 2 * ip[m + k];\n\t\t\tj1 = k1 + 2;\n\t\t\tk1 += nh;\n\t\t\ta[j1 - 1] = -a[j1 - 1];\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\ta[k1 + 3] = -a[k1 + 3];\n\t\t\tj1 += nm;\n\t\t\tk1 += 2 * nm;\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 += nm;\n\t\t\tk1 -= nm;\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 -= 2;\n\t\t\tk1 -= nh;\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 += nh + 2;\n\t\t\tk1 += nh + 2;\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\tj1 -= nh - nm;\n\t\t\tk1 += 2 * nm - 2;\n\t\t\ta[j1 - 1] = -a[j1 - 1];\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\ta[k1 + 3] = -a[k1 + 3];\n\t\t}\n\t}\n\telse {\n\t\tfor (k = 0; k < m; k++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tj1 = 4 * j + ip[m + k];\n\t\t\t\tk1 = 4 * k + ip[m + j];\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nh;\n\t\t\t\tk1 += 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += 2;\n\t\t\t\tk1 += nh;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 += nm;\n\t\t\t\tk1 += nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nh;\n\t\t\t\tk1 -= 2;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t\tj1 -= nm;\n\t\t\t\tk1 -= nm;\n\t\t\t\txr = a[j1];\n\t\t\t\txi = -a[j1 + 1];\n\t\t\t\tyr = a[k1];\n\t\t\t\tyi = -a[k1 + 1];\n\t\t\t\ta[j1] = yr;\n\t\t\t\ta[j1 + 1] = yi;\n\t\t\t\ta[k1] = xr;\n\t\t\t\ta[k1 + 1] = xi;\n\t\t\t}\n\t\t\tk1 = 4 * k + ip[m + k];\n\t\t\tj1 = k1 + 2;\n\t\t\tk1 += nh;\n\t\t\ta[j1 - 1] = -a[j1 - 1];\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\ta[k1 + 3] = -a[k1 + 3];\n\t\t\tj1 += nm;\n\t\t\tk1 += nm;\n\t\t\ta[j1 - 1] = -a[j1 - 1];\n\t\t\txr = a[j1];\n\t\t\txi = -a[j1 + 1];\n\t\t\tyr = a[k1];\n\t\t\tyi = -a[k1 + 1];\n\t\t\ta[j1] = yr;\n\t\t\ta[j1 + 1] = yi;\n\t\t\ta[k1] = xr;\n\t\t\ta[k1 + 1] = xi;\n\t\t\ta[k1 + 3] = -a[k1 + 3];\n\t\t}\n\t}\n}\n\n\nvoid bitrv216(double *a)\n{\n\tdouble x1r, x1i, x2r, x2i, x3r, x3i, x4r, x4i,\n\t\tx5r, x5i, x7r, x7i, x8r, x8i, x10r, x10i,\n\t\tx11r, x11i, x12r, x12i, x13r, x13i, x14r, x14i;\n\n\tx1r = a[2];\n\tx1i = a[3];\n\tx2r = a[4];\n\tx2i = a[5];\n\tx3r = a[6];\n\tx3i = a[7];\n\tx4r = a[8];\n\tx4i = a[9];\n\tx5r = a[10];\n\tx5i = a[11];\n\tx7r = a[14];\n\tx7i = a[15];\n\tx8r = a[16];\n\tx8i = a[17];\n\tx10r = a[20];\n\tx10i = a[21];\n\tx11r = a[22];\n\tx11i = a[23];\n\tx12r = a[24];\n\tx12i = a[25];\n\tx13r = a[26];\n\tx13i = a[27];\n\tx14r = a[28];\n\tx14i = a[29];\n\ta[2] = x8r;\n\ta[3] = x8i;\n\ta[4] = x4r;\n\ta[5] = x4i;\n\ta[6] = x12r;\n\ta[7] = x12i;\n\ta[8] = x2r;\n\ta[9] = x2i;\n\ta[10] = x10r;\n\ta[11] = x10i;\n\ta[14] = x14r;\n\ta[15] = x14i;\n\ta[16] = x1r;\n\ta[17] = x1i;\n\ta[20] = x5r;\n\ta[21] = x5i;\n\ta[22] = x13r;\n\ta[23] = x13i;\n\ta[24] = x3r;\n\ta[25] = x3i;\n\ta[26] = x11r;\n\ta[27] = x11i;\n\ta[28] = x7r;\n\ta[29] = x7i;\n}\n\n\nvoid bitrv216neg(double *a)\n{\n\tdouble x1r, x1i, x2r, x2i, x3r, x3i, x4r, x4i,\n\t\tx5r, x5i, x6r, x6i, x7r, x7i, x8r, x8i,\n\t\tx9r, x9i, x10r, x10i, x11r, x11i, x12r, x12i,\n\t\tx13r, x13i, x14r, x14i, x15r, x15i;\n\n\tx1r = a[2];\n\tx1i = a[3];\n\tx2r = a[4];\n\tx2i = a[5];\n\tx3r = a[6];\n\tx3i = a[7];\n\tx4r = a[8];\n\tx4i = a[9];\n\tx5r = a[10];\n\tx5i = a[11];\n\tx6r = a[12];\n\tx6i = a[13];\n\tx7r = a[14];\n\tx7i = a[15];\n\tx8r = a[16];\n\tx8i = a[17];\n\tx9r = a[18];\n\tx9i = a[19];\n\tx10r = a[20];\n\tx10i = a[21];\n\tx11r = a[22];\n\tx11i = a[23];\n\tx12r = a[24];\n\tx12i = a[25];\n\tx13r = a[26];\n\tx13i = a[27];\n\tx14r = a[28];\n\tx14i = a[29];\n\tx15r = a[30];\n\tx15i = a[31];\n\ta[2] = x15r;\n\ta[3] = x15i;\n\ta[4] = x7r;\n\ta[5] = x7i;\n\ta[6] = x11r;\n\ta[7] = x11i;\n\ta[8] = x3r;\n\ta[9] = x3i;\n\ta[10] = x13r;\n\ta[11] = x13i;\n\ta[12] = x5r;\n\ta[13] = x5i;\n\ta[14] = x9r;\n\ta[15] = x9i;\n\ta[16] = x1r;\n\ta[17] = x1i;\n\ta[18] = x14r;\n\ta[19] = x14i;\n\ta[20] = x6r;\n\ta[21] = x6i;\n\ta[22] = x10r;\n\ta[23] = x10i;\n\ta[24] = x2r;\n\ta[25] = x2i;\n\ta[26] = x12r;\n\ta[27] = x12i;\n\ta[28] = x4r;\n\ta[29] = x4i;\n\ta[30] = x8r;\n\ta[31] = x8i;\n}\n\n\nvoid bitrv208(double *a)\n{\n\tdouble x1r, x1i, x3r, x3i, x4r, x4i, x6r, x6i;\n\n\tx1r = a[2];\n\tx1i = a[3];\n\tx3r = a[6];\n\tx3i = a[7];\n\tx4r = a[8];\n\tx4i = a[9];\n\tx6r = a[12];\n\tx6i = a[13];\n\ta[2] = x4r;\n\ta[3] = x4i;\n\ta[6] = x6r;\n\ta[7] = x6i;\n\ta[8] = x1r;\n\ta[9] = x1i;\n\ta[12] = x3r;\n\ta[13] = x3i;\n}\n\n\nvoid bitrv208neg(double *a)\n{\n\tdouble x1r, x1i, x2r, x2i, x3r, x3i, x4r, x4i,\n\t\tx5r, x5i, x6r, x6i, x7r, x7i;\n\n\tx1r = a[2];\n\tx1i = a[3];\n\tx2r = a[4];\n\tx2i = a[5];\n\tx3r = a[6];\n\tx3i = a[7];\n\tx4r = a[8];\n\tx4i = a[9];\n\tx5r = a[10];\n\tx5i = a[11];\n\tx6r = a[12];\n\tx6i = a[13];\n\tx7r = a[14];\n\tx7i = a[15];\n\ta[2] = x7r;\n\ta[3] = x7i;\n\ta[4] = x3r;\n\ta[5] = x3i;\n\ta[6] = x5r;\n\ta[7] = x5i;\n\ta[8] = x1r;\n\ta[9] = x1i;\n\ta[10] = x6r;\n\ta[11] = x6i;\n\ta[12] = x2r;\n\ta[13] = x2i;\n\ta[14] = x4r;\n\ta[15] = x4i;\n}\n\n\nvoid cftf1st(int n, double *a, double *w)\n{\n\tint j, j0, j1, j2, j3, k, m, mh;\n\tdouble wn4r, csc1, csc3, wk1r, wk1i, wk3r, wk3i,\n\t\twd1r, wd1i, wd3r, wd3i;\n\tdouble x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i,\n\t\ty0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i;\n\n\tmh = n >> 3;\n\tm = 2 * mh;\n\tj1 = m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[0] + a[j2];\n\tx0i = a[1] + a[j2 + 1];\n\tx1r = a[0] - a[j2];\n\tx1i = a[1] - a[j2 + 1];\n\tx2r = a[j1] + a[j3];\n\tx2i = a[j1 + 1] + a[j3 + 1];\n\tx3r = a[j1] - a[j3];\n\tx3i = a[j1 + 1] - a[j3 + 1];\n\ta[0] = x0r + x2r;\n\ta[1] = x0i + x2i;\n\ta[j1] = x0r - x2r;\n\ta[j1 + 1] = x0i - x2i;\n\ta[j2] = x1r - x3i;\n\ta[j2 + 1] = x1i + x3r;\n\ta[j3] = x1r + x3i;\n\ta[j3 + 1] = x1i - x3r;\n\twn4r = w[1];\n\tcsc1 = w[2];\n\tcsc3 = w[3];\n\twd1r = 1;\n\twd1i = 0;\n\twd3r = 1;\n\twd3i = 0;\n\tk = 0;\n\tfor (j = 2; j < mh - 2; j += 4) {\n\t\tk += 4;\n\t\twk1r = csc1 * (wd1r + w[k]);\n\t\twk1i = csc1 * (wd1i + w[k + 1]);\n\t\twk3r = csc3 * (wd3r + w[k + 2]);\n\t\twk3i = csc3 * (wd3i + w[k + 3]);\n\t\twd1r = w[k];\n\t\twd1i = w[k + 1];\n\t\twd3r = w[k + 2];\n\t\twd3i = w[k + 3];\n\t\tj1 = j + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j] + a[j2];\n\t\tx0i = a[j + 1] + a[j2 + 1];\n\t\tx1r = a[j] - a[j2];\n\t\tx1i = a[j + 1] - a[j2 + 1];\n\t\ty0r = a[j + 2] + a[j2 + 2];\n\t\ty0i = a[j + 3] + a[j2 + 3];\n\t\ty1r = a[j + 2] - a[j2 + 2];\n\t\ty1i = a[j + 3] - a[j2 + 3];\n\t\tx2r = a[j1] + a[j3];\n\t\tx2i = a[j1 + 1] + a[j3 + 1];\n\t\tx3r = a[j1] - a[j3];\n\t\tx3i = a[j1 + 1] - a[j3 + 1];\n\t\ty2r = a[j1 + 2] + a[j3 + 2];\n\t\ty2i = a[j1 + 3] + a[j3 + 3];\n\t\ty3r = a[j1 + 2] - a[j3 + 2];\n\t\ty3i = a[j1 + 3] - a[j3 + 3];\n\t\ta[j] = x0r + x2r;\n\t\ta[j + 1] = x0i + x2i;\n\t\ta[j + 2] = y0r + y2r;\n\t\ta[j + 3] = y0i + y2i;\n\t\ta[j1] = x0r - x2r;\n\t\ta[j1 + 1] = x0i - x2i;\n\t\ta[j1 + 2] = y0r - y2r;\n\t\ta[j1 + 3] = y0i - y2i;\n\t\tx0r = x1r - x3i;\n\t\tx0i = x1i + x3r;\n\t\ta[j2] = wk1r * x0r - wk1i * x0i;\n\t\ta[j2 + 1] = wk1r * x0i + wk1i * x0r;\n\t\tx0r = y1r - y3i;\n\t\tx0i = y1i + y3r;\n\t\ta[j2 + 2] = wd1r * x0r - wd1i * x0i;\n\t\ta[j2 + 3] = wd1r * x0i + wd1i * x0r;\n\t\tx0r = x1r + x3i;\n\t\tx0i = x1i - x3r;\n\t\ta[j3] = wk3r * x0r + wk3i * x0i;\n\t\ta[j3 + 1] = wk3r * x0i - wk3i * x0r;\n\t\tx0r = y1r + y3i;\n\t\tx0i = y1i - y3r;\n\t\ta[j3 + 2] = wd3r * x0r + wd3i * x0i;\n\t\ta[j3 + 3] = wd3r * x0i - wd3i * x0r;\n\t\tj0 = m - j;\n\t\tj1 = j0 + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j0] + a[j2];\n\t\tx0i = a[j0 + 1] + a[j2 + 1];\n\t\tx1r = a[j0] - a[j2];\n\t\tx1i = a[j0 + 1] - a[j2 + 1];\n\t\ty0r = a[j0 - 2] + a[j2 - 2];\n\t\ty0i = a[j0 - 1] + a[j2 - 1];\n\t\ty1r = a[j0 - 2] - a[j2 - 2];\n\t\ty1i = a[j0 - 1] - a[j2 - 1];\n\t\tx2r = a[j1] + a[j3];\n\t\tx2i = a[j1 + 1] + a[j3 + 1];\n\t\tx3r = a[j1] - a[j3];\n\t\tx3i = a[j1 + 1] - a[j3 + 1];\n\t\ty2r = a[j1 - 2] + a[j3 - 2];\n\t\ty2i = a[j1 - 1] + a[j3 - 1];\n\t\ty3r = a[j1 - 2] - a[j3 - 2];\n\t\ty3i = a[j1 - 1] - a[j3 - 1];\n\t\ta[j0] = x0r + x2r;\n\t\ta[j0 + 1] = x0i + x2i;\n\t\ta[j0 - 2] = y0r + y2r;\n\t\ta[j0 - 1] = y0i + y2i;\n\t\ta[j1] = x0r - x2r;\n\t\ta[j1 + 1] = x0i - x2i;\n\t\ta[j1 - 2] = y0r - y2r;\n\t\ta[j1 - 1] = y0i - y2i;\n\t\tx0r = x1r - x3i;\n\t\tx0i = x1i + x3r;\n\t\ta[j2] = wk1i * x0r - wk1r * x0i;\n\t\ta[j2 + 1] = wk1i * x0i + wk1r * x0r;\n\t\tx0r = y1r - y3i;\n\t\tx0i = y1i + y3r;\n\t\ta[j2 - 2] = wd1i * x0r - wd1r * x0i;\n\t\ta[j2 - 1] = wd1i * x0i + wd1r * x0r;\n\t\tx0r = x1r + x3i;\n\t\tx0i = x1i - x3r;\n\t\ta[j3] = wk3i * x0r + wk3r * x0i;\n\t\ta[j3 + 1] = wk3i * x0i - wk3r * x0r;\n\t\tx0r = y1r + y3i;\n\t\tx0i = y1i - y3r;\n\t\ta[j3 - 2] = wd3i * x0r + wd3r * x0i;\n\t\ta[j3 - 1] = wd3i * x0i - wd3r * x0r;\n\t}\n\twk1r = csc1 * (wd1r + wn4r);\n\twk1i = csc1 * (wd1i + wn4r);\n\twk3r = csc3 * (wd3r - wn4r);\n\twk3i = csc3 * (wd3i - wn4r);\n\tj0 = mh;\n\tj1 = j0 + m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[j0 - 2] + a[j2 - 2];\n\tx0i = a[j0 - 1] + a[j2 - 1];\n\tx1r = a[j0 - 2] - a[j2 - 2];\n\tx1i = a[j0 - 1] - a[j2 - 1];\n\tx2r = a[j1 - 2] + a[j3 - 2];\n\tx2i = a[j1 - 1] + a[j3 - 1];\n\tx3r = a[j1 - 2] - a[j3 - 2];\n\tx3i = a[j1 - 1] - a[j3 - 1];\n\ta[j0 - 2] = x0r + x2r;\n\ta[j0 - 1] = x0i + x2i;\n\ta[j1 - 2] = x0r - x2r;\n\ta[j1 - 1] = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ta[j2 - 2] = wk1r * x0r - wk1i * x0i;\n\ta[j2 - 1] = wk1r * x0i + wk1i * x0r;\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ta[j3 - 2] = wk3r * x0r + wk3i * x0i;\n\ta[j3 - 1] = wk3r * x0i - wk3i * x0r;\n\tx0r = a[j0] + a[j2];\n\tx0i = a[j0 + 1] + a[j2 + 1];\n\tx1r = a[j0] - a[j2];\n\tx1i = a[j0 + 1] - a[j2 + 1];\n\tx2r = a[j1] + a[j3];\n\tx2i = a[j1 + 1] + a[j3 + 1];\n\tx3r = a[j1] - a[j3];\n\tx3i = a[j1 + 1] - a[j3 + 1];\n\ta[j0] = x0r + x2r;\n\ta[j0 + 1] = x0i + x2i;\n\ta[j1] = x0r - x2r;\n\ta[j1 + 1] = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ta[j2] = wn4r * (x0r - x0i);\n\ta[j2 + 1] = wn4r * (x0i + x0r);\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ta[j3] = -wn4r * (x0r + x0i);\n\ta[j3 + 1] = -wn4r * (x0i - x0r);\n\tx0r = a[j0 + 2] + a[j2 + 2];\n\tx0i = a[j0 + 3] + a[j2 + 3];\n\tx1r = a[j0 + 2] - a[j2 + 2];\n\tx1i = a[j0 + 3] - a[j2 + 3];\n\tx2r = a[j1 + 2] + a[j3 + 2];\n\tx2i = a[j1 + 3] + a[j3 + 3];\n\tx3r = a[j1 + 2] - a[j3 + 2];\n\tx3i = a[j1 + 3] - a[j3 + 3];\n\ta[j0 + 2] = x0r + x2r;\n\ta[j0 + 3] = x0i + x2i;\n\ta[j1 + 2] = x0r - x2r;\n\ta[j1 + 3] = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ta[j2 + 2] = wk1i * x0r - wk1r * x0i;\n\ta[j2 + 3] = wk1i * x0i + wk1r * x0r;\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ta[j3 + 2] = wk3i * x0r + wk3r * x0i;\n\ta[j3 + 3] = wk3i * x0i - wk3r * x0r;\n}\n\n\nvoid cftb1st(int n, double *a, double *w)\n{\n\tint j, j0, j1, j2, j3, k, m, mh;\n\tdouble wn4r, csc1, csc3, wk1r, wk1i, wk3r, wk3i,\n\t\twd1r, wd1i, wd3r, wd3i;\n\tdouble x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i,\n\t\ty0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i;\n\n\tmh = n >> 3;\n\tm = 2 * mh;\n\tj1 = m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[0] + a[j2];\n\tx0i = -a[1] - a[j2 + 1];\n\tx1r = a[0] - a[j2];\n\tx1i = -a[1] + a[j2 + 1];\n\tx2r = a[j1] + a[j3];\n\tx2i = a[j1 + 1] + a[j3 + 1];\n\tx3r = a[j1] - a[j3];\n\tx3i = a[j1 + 1] - a[j3 + 1];\n\ta[0] = x0r + x2r;\n\ta[1] = x0i - x2i;\n\ta[j1] = x0r - x2r;\n\ta[j1 + 1] = x0i + x2i;\n\ta[j2] = x1r + x3i;\n\ta[j2 + 1] = x1i + x3r;\n\ta[j3] = x1r - x3i;\n\ta[j3 + 1] = x1i - x3r;\n\twn4r = w[1];\n\tcsc1 = w[2];\n\tcsc3 = w[3];\n\twd1r = 1;\n\twd1i = 0;\n\twd3r = 1;\n\twd3i = 0;\n\tk = 0;\n\tfor (j = 2; j < mh - 2; j += 4) {\n\t\tk += 4;\n\t\twk1r = csc1 * (wd1r + w[k]);\n\t\twk1i = csc1 * (wd1i + w[k + 1]);\n\t\twk3r = csc3 * (wd3r + w[k + 2]);\n\t\twk3i = csc3 * (wd3i + w[k + 3]);\n\t\twd1r = w[k];\n\t\twd1i = w[k + 1];\n\t\twd3r = w[k + 2];\n\t\twd3i = w[k + 3];\n\t\tj1 = j + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j] + a[j2];\n\t\tx0i = -a[j + 1] - a[j2 + 1];\n\t\tx1r = a[j] - a[j2];\n\t\tx1i = -a[j + 1] + a[j2 + 1];\n\t\ty0r = a[j + 2] + a[j2 + 2];\n\t\ty0i = -a[j + 3] - a[j2 + 3];\n\t\ty1r = a[j + 2] - a[j2 + 2];\n\t\ty1i = -a[j + 3] + a[j2 + 3];\n\t\tx2r = a[j1] + a[j3];\n\t\tx2i = a[j1 + 1] + a[j3 + 1];\n\t\tx3r = a[j1] - a[j3];\n\t\tx3i = a[j1 + 1] - a[j3 + 1];\n\t\ty2r = a[j1 + 2] + a[j3 + 2];\n\t\ty2i = a[j1 + 3] + a[j3 + 3];\n\t\ty3r = a[j1 + 2] - a[j3 + 2];\n\t\ty3i = a[j1 + 3] - a[j3 + 3];\n\t\ta[j] = x0r + x2r;\n\t\ta[j + 1] = x0i - x2i;\n\t\ta[j + 2] = y0r + y2r;\n\t\ta[j + 3] = y0i - y2i;\n\t\ta[j1] = x0r - x2r;\n\t\ta[j1 + 1] = x0i + x2i;\n\t\ta[j1 + 2] = y0r - y2r;\n\t\ta[j1 + 3] = y0i + y2i;\n\t\tx0r = x1r + x3i;\n\t\tx0i = x1i + x3r;\n\t\ta[j2] = wk1r * x0r - wk1i * x0i;\n\t\ta[j2 + 1] = wk1r * x0i + wk1i * x0r;\n\t\tx0r = y1r + y3i;\n\t\tx0i = y1i + y3r;\n\t\ta[j2 + 2] = wd1r * x0r - wd1i * x0i;\n\t\ta[j2 + 3] = wd1r * x0i + wd1i * x0r;\n\t\tx0r = x1r - x3i;\n\t\tx0i = x1i - x3r;\n\t\ta[j3] = wk3r * x0r + wk3i * x0i;\n\t\ta[j3 + 1] = wk3r * x0i - wk3i * x0r;\n\t\tx0r = y1r - y3i;\n\t\tx0i = y1i - y3r;\n\t\ta[j3 + 2] = wd3r * x0r + wd3i * x0i;\n\t\ta[j3 + 3] = wd3r * x0i - wd3i * x0r;\n\t\tj0 = m - j;\n\t\tj1 = j0 + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j0] + a[j2];\n\t\tx0i = -a[j0 + 1] - a[j2 + 1];\n\t\tx1r = a[j0] - a[j2];\n\t\tx1i = -a[j0 + 1] + a[j2 + 1];\n\t\ty0r = a[j0 - 2] + a[j2 - 2];\n\t\ty0i = -a[j0 - 1] - a[j2 - 1];\n\t\ty1r = a[j0 - 2] - a[j2 - 2];\n\t\ty1i = -a[j0 - 1] + a[j2 - 1];\n\t\tx2r = a[j1] + a[j3];\n\t\tx2i = a[j1 + 1] + a[j3 + 1];\n\t\tx3r = a[j1] - a[j3];\n\t\tx3i = a[j1 + 1] - a[j3 + 1];\n\t\ty2r = a[j1 - 2] + a[j3 - 2];\n\t\ty2i = a[j1 - 1] + a[j3 - 1];\n\t\ty3r = a[j1 - 2] - a[j3 - 2];\n\t\ty3i = a[j1 - 1] - a[j3 - 1];\n\t\ta[j0] = x0r + x2r;\n\t\ta[j0 + 1] = x0i - x2i;\n\t\ta[j0 - 2] = y0r + y2r;\n\t\ta[j0 - 1] = y0i - y2i;\n\t\ta[j1] = x0r - x2r;\n\t\ta[j1 + 1] = x0i + x2i;\n\t\ta[j1 - 2] = y0r - y2r;\n\t\ta[j1 - 1] = y0i + y2i;\n\t\tx0r = x1r + x3i;\n\t\tx0i = x1i + x3r;\n\t\ta[j2] = wk1i * x0r - wk1r * x0i;\n\t\ta[j2 + 1] = wk1i * x0i + wk1r * x0r;\n\t\tx0r = y1r + y3i;\n\t\tx0i = y1i + y3r;\n\t\ta[j2 - 2] = wd1i * x0r - wd1r * x0i;\n\t\ta[j2 - 1] = wd1i * x0i + wd1r * x0r;\n\t\tx0r = x1r - x3i;\n\t\tx0i = x1i - x3r;\n\t\ta[j3] = wk3i * x0r + wk3r * x0i;\n\t\ta[j3 + 1] = wk3i * x0i - wk3r * x0r;\n\t\tx0r = y1r - y3i;\n\t\tx0i = y1i - y3r;\n\t\ta[j3 - 2] = wd3i * x0r + wd3r * x0i;\n\t\ta[j3 - 1] = wd3i * x0i - wd3r * x0r;\n\t}\n\twk1r = csc1 * (wd1r + wn4r);\n\twk1i = csc1 * (wd1i + wn4r);\n\twk3r = csc3 * (wd3r - wn4r);\n\twk3i = csc3 * (wd3i - wn4r);\n\tj0 = mh;\n\tj1 = j0 + m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[j0 - 2] + a[j2 - 2];\n\tx0i = -a[j0 - 1] - a[j2 - 1];\n\tx1r = a[j0 - 2] - a[j2 - 2];\n\tx1i = -a[j0 - 1] + a[j2 - 1];\n\tx2r = a[j1 - 2] + a[j3 - 2];\n\tx2i = a[j1 - 1] + a[j3 - 1];\n\tx3r = a[j1 - 2] - a[j3 - 2];\n\tx3i = a[j1 - 1] - a[j3 - 1];\n\ta[j0 - 2] = x0r + x2r;\n\ta[j0 - 1] = x0i - x2i;\n\ta[j1 - 2] = x0r - x2r;\n\ta[j1 - 1] = x0i + x2i;\n\tx0r = x1r + x3i;\n\tx0i = x1i + x3r;\n\ta[j2 - 2] = wk1r * x0r - wk1i * x0i;\n\ta[j2 - 1] = wk1r * x0i + wk1i * x0r;\n\tx0r = x1r - x3i;\n\tx0i = x1i - x3r;\n\ta[j3 - 2] = wk3r * x0r + wk3i * x0i;\n\ta[j3 - 1] = wk3r * x0i - wk3i * x0r;\n\tx0r = a[j0] + a[j2];\n\tx0i = -a[j0 + 1] - a[j2 + 1];\n\tx1r = a[j0] - a[j2];\n\tx1i = -a[j0 + 1] + a[j2 + 1];\n\tx2r = a[j1] + a[j3];\n\tx2i = a[j1 + 1] + a[j3 + 1];\n\tx3r = a[j1] - a[j3];\n\tx3i = a[j1 + 1] - a[j3 + 1];\n\ta[j0] = x0r + x2r;\n\ta[j0 + 1] = x0i - x2i;\n\ta[j1] = x0r - x2r;\n\ta[j1 + 1] = x0i + x2i;\n\tx0r = x1r + x3i;\n\tx0i = x1i + x3r;\n\ta[j2] = wn4r * (x0r - x0i);\n\ta[j2 + 1] = wn4r * (x0i + x0r);\n\tx0r = x1r - x3i;\n\tx0i = x1i - x3r;\n\ta[j3] = -wn4r * (x0r + x0i);\n\ta[j3 + 1] = -wn4r * (x0i - x0r);\n\tx0r = a[j0 + 2] + a[j2 + 2];\n\tx0i = -a[j0 + 3] - a[j2 + 3];\n\tx1r = a[j0 + 2] - a[j2 + 2];\n\tx1i = -a[j0 + 3] + a[j2 + 3];\n\tx2r = a[j1 + 2] + a[j3 + 2];\n\tx2i = a[j1 + 3] + a[j3 + 3];\n\tx3r = a[j1 + 2] - a[j3 + 2];\n\tx3i = a[j1 + 3] - a[j3 + 3];\n\ta[j0 + 2] = x0r + x2r;\n\ta[j0 + 3] = x0i - x2i;\n\ta[j1 + 2] = x0r - x2r;\n\ta[j1 + 3] = x0i + x2i;\n\tx0r = x1r + x3i;\n\tx0i = x1i + x3r;\n\ta[j2 + 2] = wk1i * x0r - wk1r * x0i;\n\ta[j2 + 3] = wk1i * x0i + wk1r * x0r;\n\tx0r = x1r - x3i;\n\tx0i = x1i - x3r;\n\ta[j3 + 2] = wk3i * x0r + wk3r * x0i;\n\ta[j3 + 3] = wk3i * x0i - wk3r * x0r;\n}\n\n\n#ifdef USE_CDFT_THREADS\nstruct cdft_arg_st {\n\tint n0;\n\tint n;\n\tdouble *a;\n\tint nw;\n\tdouble *w;\n};\ntypedef struct cdft_arg_st cdft_arg_t;\n\n\nvoid cftrec4_th(int n, double *a, int nw, double *w)\n{\n\tvoid *cftrec1_th(void *p);\n\tvoid *cftrec2_th(void *p);\n\tint i, idiv4, m, nthread;\n\tcdft_thread_t th[4];\n\tcdft_arg_t ag[4];\n\n\tnthread = 2;\n\tidiv4 = 0;\n\tm = n >> 1;\n\tif (n > CDFT_4THREADS_BEGIN_N) {\n\t\tnthread = 4;\n\t\tidiv4 = 1;\n\t\tm >>= 1;\n\t}\n\tfor (i = 0; i < nthread; i++) {\n\t\tag[i].n0 = n;\n\t\tag[i].n = m;\n\t\tag[i].a = &a[i * m];\n\t\tag[i].nw = nw;\n\t\tag[i].w = w;\n\t\tif (i != idiv4) {\n\t\t\tcdft_thread_create(&th[i], cftrec1_th, &ag[i]);\n\t\t}\n\t\telse {\n\t\t\tcdft_thread_create(&th[i], cftrec2_th, &ag[i]);\n\t\t}\n\t}\n\tfor (i = 0; i < nthread; i++) {\n\t\tcdft_thread_wait(th[i]);\n\t}\n}\n\n\nvoid *cftrec1_th(void *p)\n{\n\tint cfttree(int n, int j, int k, double *a, int nw, double *w);\n\tvoid cftleaf(int n, int isplt, double *a, int nw, double *w);\n\tvoid cftmdl1(int n, double *a, double *w);\n\tint isplt, j, k, m, n, n0, nw;\n\tdouble *a, *w;\n\n\tn0 = ((cdft_arg_t *)p)->n0;\n\tn = ((cdft_arg_t *)p)->n;\n\ta = ((cdft_arg_t *)p)->a;\n\tnw = ((cdft_arg_t *)p)->nw;\n\tw = ((cdft_arg_t *)p)->w;\n\tm = n0;\n\twhile (m > 512) {\n\t\tm >>= 2;\n\t\tcftmdl1(m, &a[n - m], &w[nw - (m >> 1)]);\n\t}\n\tcftleaf(m, 1, &a[n - m], nw, w);\n\tk = 0;\n\tfor (j = n - m; j > 0; j -= m) {\n\t\tk++;\n\t\tisplt = cfttree(m, j, k, a, nw, w);\n\t\tcftleaf(m, isplt, &a[j - m], nw, w);\n\t}\n\treturn (void *)0;\n}\n\n\nvoid *cftrec2_th(void *p)\n{\n\tint cfttree(int n, int j, int k, double *a, int nw, double *w);\n\tvoid cftleaf(int n, int isplt, double *a, int nw, double *w);\n\tvoid cftmdl2(int n, double *a, double *w);\n\tint isplt, j, k, m, n, n0, nw;\n\tdouble *a, *w;\n\n\tn0 = ((cdft_arg_t *)p)->n0;\n\tn = ((cdft_arg_t *)p)->n;\n\ta = ((cdft_arg_t *)p)->a;\n\tnw = ((cdft_arg_t *)p)->nw;\n\tw = ((cdft_arg_t *)p)->w;\n\tk = 1;\n\tm = n0;\n\twhile (m > 512) {\n\t\tm >>= 2;\n\t\tk <<= 2;\n\t\tcftmdl2(m, &a[n - m], &w[nw - m]);\n\t}\n\tcftleaf(m, 0, &a[n - m], nw, w);\n\tk >>= 1;\n\tfor (j = n - m; j > 0; j -= m) {\n\t\tk++;\n\t\tisplt = cfttree(m, j, k, a, nw, w);\n\t\tcftleaf(m, isplt, &a[j - m], nw, w);\n\t}\n\treturn (void *)0;\n}\n#endif /* USE_CDFT_THREADS */\n\n\nvoid cftrec4(int n, double *a, int nw, double *w)\n{\n\t\n\tint isplt, j, k, m;\n\n\tm = n;\n\twhile (m > 512) {\n\t\tm >>= 2;\n\t\tcftmdl1(m, &a[n - m], &w[nw - (m >> 1)]);\n\t}\n\tcftleaf(m, 1, &a[n - m], nw, w);\n\tk = 0;\n\tfor (j = n - m; j > 0; j -= m) {\n\t\tk++;\n\t\tisplt = cfttree(m, j, k, a, nw, w);\n\t\tcftleaf(m, isplt, &a[j - m], nw, w);\n\t}\n}\n\n\nint cfttree(int n, int j, int k, double *a, int nw, double *w)\n{\n\n\tint i, isplt, m;\n\n\tif ((k & 3) != 0) {\n\t\tisplt = k & 1;\n\t\tif (isplt != 0) {\n\t\t\tcftmdl1(n, &a[j - n], &w[nw - (n >> 1)]);\n\t\t}\n\t\telse {\n\t\t\tcftmdl2(n, &a[j - n], &w[nw - n]);\n\t\t}\n\t}\n\telse {\n\t\tm = n;\n\t\tfor (i = k; (i & 3) == 0; i >>= 2) {\n\t\t\tm <<= 2;\n\t\t}\n\t\tisplt = i & 1;\n\t\tif (isplt != 0) {\n\t\t\twhile (m > 128) {\n\t\t\t\tcftmdl1(m, &a[j - m], &w[nw - (m >> 1)]);\n\t\t\t\tm >>= 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (m > 128) {\n\t\t\t\tcftmdl2(m, &a[j - m], &w[nw - m]);\n\t\t\t\tm >>= 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn isplt;\n}\n\n\nvoid cftleaf(int n, int isplt, double *a, int nw, double *w)\n{\n\n\n\tif (n == 512) {\n\t\tcftmdl1(128, a, &w[nw - 64]);\n\t\tcftf161(a, &w[nw - 8]);\n\t\tcftf162(&a[32], &w[nw - 32]);\n\t\tcftf161(&a[64], &w[nw - 8]);\n\t\tcftf161(&a[96], &w[nw - 8]);\n\t\tcftmdl2(128, &a[128], &w[nw - 128]);\n\t\tcftf161(&a[128], &w[nw - 8]);\n\t\tcftf162(&a[160], &w[nw - 32]);\n\t\tcftf161(&a[192], &w[nw - 8]);\n\t\tcftf162(&a[224], &w[nw - 32]);\n\t\tcftmdl1(128, &a[256], &w[nw - 64]);\n\t\tcftf161(&a[256], &w[nw - 8]);\n\t\tcftf162(&a[288], &w[nw - 32]);\n\t\tcftf161(&a[320], &w[nw - 8]);\n\t\tcftf161(&a[352], &w[nw - 8]);\n\t\tif (isplt != 0) {\n\t\t\tcftmdl1(128, &a[384], &w[nw - 64]);\n\t\t\tcftf161(&a[480], &w[nw - 8]);\n\t\t}\n\t\telse {\n\t\t\tcftmdl2(128, &a[384], &w[nw - 128]);\n\t\t\tcftf162(&a[480], &w[nw - 32]);\n\t\t}\n\t\tcftf161(&a[384], &w[nw - 8]);\n\t\tcftf162(&a[416], &w[nw - 32]);\n\t\tcftf161(&a[448], &w[nw - 8]);\n\t}\n\telse {\n\t\tcftmdl1(64, a, &w[nw - 32]);\n\t\tcftf081(a, &w[nw - 8]);\n\t\tcftf082(&a[16], &w[nw - 8]);\n\t\tcftf081(&a[32], &w[nw - 8]);\n\t\tcftf081(&a[48], &w[nw - 8]);\n\t\tcftmdl2(64, &a[64], &w[nw - 64]);\n\t\tcftf081(&a[64], &w[nw - 8]);\n\t\tcftf082(&a[80], &w[nw - 8]);\n\t\tcftf081(&a[96], &w[nw - 8]);\n\t\tcftf082(&a[112], &w[nw - 8]);\n\t\tcftmdl1(64, &a[128], &w[nw - 32]);\n\t\tcftf081(&a[128], &w[nw - 8]);\n\t\tcftf082(&a[144], &w[nw - 8]);\n\t\tcftf081(&a[160], &w[nw - 8]);\n\t\tcftf081(&a[176], &w[nw - 8]);\n\t\tif (isplt != 0) {\n\t\t\tcftmdl1(64, &a[192], &w[nw - 32]);\n\t\t\tcftf081(&a[240], &w[nw - 8]);\n\t\t}\n\t\telse {\n\t\t\tcftmdl2(64, &a[192], &w[nw - 64]);\n\t\t\tcftf082(&a[240], &w[nw - 8]);\n\t\t}\n\t\tcftf081(&a[192], &w[nw - 8]);\n\t\tcftf082(&a[208], &w[nw - 8]);\n\t\tcftf081(&a[224], &w[nw - 8]);\n\t}\n}\n\n\nvoid cftmdl1(int n, double *a, double *w)\n{\n\tint j, j0, j1, j2, j3, k, m, mh;\n\tdouble wn4r, wk1r, wk1i, wk3r, wk3i;\n\tdouble x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;\n\n\tmh = n >> 3;\n\tm = 2 * mh;\n\tj1 = m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[0] + a[j2];\n\tx0i = a[1] + a[j2 + 1];\n\tx1r = a[0] - a[j2];\n\tx1i = a[1] - a[j2 + 1];\n\tx2r = a[j1] + a[j3];\n\tx2i = a[j1 + 1] + a[j3 + 1];\n\tx3r = a[j1] - a[j3];\n\tx3i = a[j1 + 1] - a[j3 + 1];\n\ta[0] = x0r + x2r;\n\ta[1] = x0i + x2i;\n\ta[j1] = x0r - x2r;\n\ta[j1 + 1] = x0i - x2i;\n\ta[j2] = x1r - x3i;\n\ta[j2 + 1] = x1i + x3r;\n\ta[j3] = x1r + x3i;\n\ta[j3 + 1] = x1i - x3r;\n\twn4r = w[1];\n\tk = 0;\n\tfor (j = 2; j < mh; j += 2) {\n\t\tk += 4;\n\t\twk1r = w[k];\n\t\twk1i = w[k + 1];\n\t\twk3r = w[k + 2];\n\t\twk3i = w[k + 3];\n\t\tj1 = j + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j] + a[j2];\n\t\tx0i = a[j + 1] + a[j2 + 1];\n\t\tx1r = a[j] - a[j2];\n\t\tx1i = a[j + 1] - a[j2 + 1];\n\t\tx2r = a[j1] + a[j3];\n\t\tx2i = a[j1 + 1] + a[j3 + 1];\n\t\tx3r = a[j1] - a[j3];\n\t\tx3i = a[j1 + 1] - a[j3 + 1];\n\t\ta[j] = x0r + x2r;\n\t\ta[j + 1] = x0i + x2i;\n\t\ta[j1] = x0r - x2r;\n\t\ta[j1 + 1] = x0i - x2i;\n\t\tx0r = x1r - x3i;\n\t\tx0i = x1i + x3r;\n\t\ta[j2] = wk1r * x0r - wk1i * x0i;\n\t\ta[j2 + 1] = wk1r * x0i + wk1i * x0r;\n\t\tx0r = x1r + x3i;\n\t\tx0i = x1i - x3r;\n\t\ta[j3] = wk3r * x0r + wk3i * x0i;\n\t\ta[j3 + 1] = wk3r * x0i - wk3i * x0r;\n\t\tj0 = m - j;\n\t\tj1 = j0 + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j0] + a[j2];\n\t\tx0i = a[j0 + 1] + a[j2 + 1];\n\t\tx1r = a[j0] - a[j2];\n\t\tx1i = a[j0 + 1] - a[j2 + 1];\n\t\tx2r = a[j1] + a[j3];\n\t\tx2i = a[j1 + 1] + a[j3 + 1];\n\t\tx3r = a[j1] - a[j3];\n\t\tx3i = a[j1 + 1] - a[j3 + 1];\n\t\ta[j0] = x0r + x2r;\n\t\ta[j0 + 1] = x0i + x2i;\n\t\ta[j1] = x0r - x2r;\n\t\ta[j1 + 1] = x0i - x2i;\n\t\tx0r = x1r - x3i;\n\t\tx0i = x1i + x3r;\n\t\ta[j2] = wk1i * x0r - wk1r * x0i;\n\t\ta[j2 + 1] = wk1i * x0i + wk1r * x0r;\n\t\tx0r = x1r + x3i;\n\t\tx0i = x1i - x3r;\n\t\ta[j3] = wk3i * x0r + wk3r * x0i;\n\t\ta[j3 + 1] = wk3i * x0i - wk3r * x0r;\n\t}\n\tj0 = mh;\n\tj1 = j0 + m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[j0] + a[j2];\n\tx0i = a[j0 + 1] + a[j2 + 1];\n\tx1r = a[j0] - a[j2];\n\tx1i = a[j0 + 1] - a[j2 + 1];\n\tx2r = a[j1] + a[j3];\n\tx2i = a[j1 + 1] + a[j3 + 1];\n\tx3r = a[j1] - a[j3];\n\tx3i = a[j1 + 1] - a[j3 + 1];\n\ta[j0] = x0r + x2r;\n\ta[j0 + 1] = x0i + x2i;\n\ta[j1] = x0r - x2r;\n\ta[j1 + 1] = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ta[j2] = wn4r * (x0r - x0i);\n\ta[j2 + 1] = wn4r * (x0i + x0r);\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ta[j3] = -wn4r * (x0r + x0i);\n\ta[j3 + 1] = -wn4r * (x0i - x0r);\n}\n\n\nvoid cftmdl2(int n, double *a, double *w)\n{\n\tint j, j0, j1, j2, j3, k, kr, m, mh;\n\tdouble wn4r, wk1r, wk1i, wk3r, wk3i, wd1r, wd1i, wd3r, wd3i;\n\tdouble x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i, y0r, y0i, y2r, y2i;\n\n\tmh = n >> 3;\n\tm = 2 * mh;\n\twn4r = w[1];\n\tj1 = m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[0] - a[j2 + 1];\n\tx0i = a[1] + a[j2];\n\tx1r = a[0] + a[j2 + 1];\n\tx1i = a[1] - a[j2];\n\tx2r = a[j1] - a[j3 + 1];\n\tx2i = a[j1 + 1] + a[j3];\n\tx3r = a[j1] + a[j3 + 1];\n\tx3i = a[j1 + 1] - a[j3];\n\ty0r = wn4r * (x2r - x2i);\n\ty0i = wn4r * (x2i + x2r);\n\ta[0] = x0r + y0r;\n\ta[1] = x0i + y0i;\n\ta[j1] = x0r - y0r;\n\ta[j1 + 1] = x0i - y0i;\n\ty0r = wn4r * (x3r - x3i);\n\ty0i = wn4r * (x3i + x3r);\n\ta[j2] = x1r - y0i;\n\ta[j2 + 1] = x1i + y0r;\n\ta[j3] = x1r + y0i;\n\ta[j3 + 1] = x1i - y0r;\n\tk = 0;\n\tkr = 2 * m;\n\tfor (j = 2; j < mh; j += 2) {\n\t\tk += 4;\n\t\twk1r = w[k];\n\t\twk1i = w[k + 1];\n\t\twk3r = w[k + 2];\n\t\twk3i = w[k + 3];\n\t\tkr -= 4;\n\t\twd1i = w[kr];\n\t\twd1r = w[kr + 1];\n\t\twd3i = w[kr + 2];\n\t\twd3r = w[kr + 3];\n\t\tj1 = j + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j] - a[j2 + 1];\n\t\tx0i = a[j + 1] + a[j2];\n\t\tx1r = a[j] + a[j2 + 1];\n\t\tx1i = a[j + 1] - a[j2];\n\t\tx2r = a[j1] - a[j3 + 1];\n\t\tx2i = a[j1 + 1] + a[j3];\n\t\tx3r = a[j1] + a[j3 + 1];\n\t\tx3i = a[j1 + 1] - a[j3];\n\t\ty0r = wk1r * x0r - wk1i * x0i;\n\t\ty0i = wk1r * x0i + wk1i * x0r;\n\t\ty2r = wd1r * x2r - wd1i * x2i;\n\t\ty2i = wd1r * x2i + wd1i * x2r;\n\t\ta[j] = y0r + y2r;\n\t\ta[j + 1] = y0i + y2i;\n\t\ta[j1] = y0r - y2r;\n\t\ta[j1 + 1] = y0i - y2i;\n\t\ty0r = wk3r * x1r + wk3i * x1i;\n\t\ty0i = wk3r * x1i - wk3i * x1r;\n\t\ty2r = wd3r * x3r + wd3i * x3i;\n\t\ty2i = wd3r * x3i - wd3i * x3r;\n\t\ta[j2] = y0r + y2r;\n\t\ta[j2 + 1] = y0i + y2i;\n\t\ta[j3] = y0r - y2r;\n\t\ta[j3 + 1] = y0i - y2i;\n\t\tj0 = m - j;\n\t\tj1 = j0 + m;\n\t\tj2 = j1 + m;\n\t\tj3 = j2 + m;\n\t\tx0r = a[j0] - a[j2 + 1];\n\t\tx0i = a[j0 + 1] + a[j2];\n\t\tx1r = a[j0] + a[j2 + 1];\n\t\tx1i = a[j0 + 1] - a[j2];\n\t\tx2r = a[j1] - a[j3 + 1];\n\t\tx2i = a[j1 + 1] + a[j3];\n\t\tx3r = a[j1] + a[j3 + 1];\n\t\tx3i = a[j1 + 1] - a[j3];\n\t\ty0r = wd1i * x0r - wd1r * x0i;\n\t\ty0i = wd1i * x0i + wd1r * x0r;\n\t\ty2r = wk1i * x2r - wk1r * x2i;\n\t\ty2i = wk1i * x2i + wk1r * x2r;\n\t\ta[j0] = y0r + y2r;\n\t\ta[j0 + 1] = y0i + y2i;\n\t\ta[j1] = y0r - y2r;\n\t\ta[j1 + 1] = y0i - y2i;\n\t\ty0r = wd3i * x1r + wd3r * x1i;\n\t\ty0i = wd3i * x1i - wd3r * x1r;\n\t\ty2r = wk3i * x3r + wk3r * x3i;\n\t\ty2i = wk3i * x3i - wk3r * x3r;\n\t\ta[j2] = y0r + y2r;\n\t\ta[j2 + 1] = y0i + y2i;\n\t\ta[j3] = y0r - y2r;\n\t\ta[j3 + 1] = y0i - y2i;\n\t}\n\twk1r = w[m];\n\twk1i = w[m + 1];\n\tj0 = mh;\n\tj1 = j0 + m;\n\tj2 = j1 + m;\n\tj3 = j2 + m;\n\tx0r = a[j0] - a[j2 + 1];\n\tx0i = a[j0 + 1] + a[j2];\n\tx1r = a[j0] + a[j2 + 1];\n\tx1i = a[j0 + 1] - a[j2];\n\tx2r = a[j1] - a[j3 + 1];\n\tx2i = a[j1 + 1] + a[j3];\n\tx3r = a[j1] + a[j3 + 1];\n\tx3i = a[j1 + 1] - a[j3];\n\ty0r = wk1r * x0r - wk1i * x0i;\n\ty0i = wk1r * x0i + wk1i * x0r;\n\ty2r = wk1i * x2r - wk1r * x2i;\n\ty2i = wk1i * x2i + wk1r * x2r;\n\ta[j0] = y0r + y2r;\n\ta[j0 + 1] = y0i + y2i;\n\ta[j1] = y0r - y2r;\n\ta[j1 + 1] = y0i - y2i;\n\ty0r = wk1i * x1r - wk1r * x1i;\n\ty0i = wk1i * x1i + wk1r * x1r;\n\ty2r = wk1r * x3r - wk1i * x3i;\n\ty2i = wk1r * x3i + wk1i * x3r;\n\ta[j2] = y0r - y2r;\n\ta[j2 + 1] = y0i - y2i;\n\ta[j3] = y0r + y2r;\n\ta[j3 + 1] = y0i + y2i;\n}\n\n\nvoid cftfx41(int n, double *a, int nw, double *w)\n{\n\n\n\tif (n == 128) {\n\t\tcftf161(a, &w[nw - 8]);\n\t\tcftf162(&a[32], &w[nw - 32]);\n\t\tcftf161(&a[64], &w[nw - 8]);\n\t\tcftf161(&a[96], &w[nw - 8]);\n\t}\n\telse {\n\t\tcftf081(a, &w[nw - 8]);\n\t\tcftf082(&a[16], &w[nw - 8]);\n\t\tcftf081(&a[32], &w[nw - 8]);\n\t\tcftf081(&a[48], &w[nw - 8]);\n\t}\n}\n\n\nvoid cftf161(double *a, double *w)\n{\n\tdouble wn4r, wk1r, wk1i,\n\t\tx0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i,\n\t\ty0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i,\n\t\ty4r, y4i, y5r, y5i, y6r, y6i, y7r, y7i,\n\t\ty8r, y8i, y9r, y9i, y10r, y10i, y11r, y11i,\n\t\ty12r, y12i, y13r, y13i, y14r, y14i, y15r, y15i;\n\n\twn4r = w[1];\n\twk1r = w[2];\n\twk1i = w[3];\n\tx0r = a[0] + a[16];\n\tx0i = a[1] + a[17];\n\tx1r = a[0] - a[16];\n\tx1i = a[1] - a[17];\n\tx2r = a[8] + a[24];\n\tx2i = a[9] + a[25];\n\tx3r = a[8] - a[24];\n\tx3i = a[9] - a[25];\n\ty0r = x0r + x2r;\n\ty0i = x0i + x2i;\n\ty4r = x0r - x2r;\n\ty4i = x0i - x2i;\n\ty8r = x1r - x3i;\n\ty8i = x1i + x3r;\n\ty12r = x1r + x3i;\n\ty12i = x1i - x3r;\n\tx0r = a[2] + a[18];\n\tx0i = a[3] + a[19];\n\tx1r = a[2] - a[18];\n\tx1i = a[3] - a[19];\n\tx2r = a[10] + a[26];\n\tx2i = a[11] + a[27];\n\tx3r = a[10] - a[26];\n\tx3i = a[11] - a[27];\n\ty1r = x0r + x2r;\n\ty1i = x0i + x2i;\n\ty5r = x0r - x2r;\n\ty5i = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ty9r = wk1r * x0r - wk1i * x0i;\n\ty9i = wk1r * x0i + wk1i * x0r;\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ty13r = wk1i * x0r - wk1r * x0i;\n\ty13i = wk1i * x0i + wk1r * x0r;\n\tx0r = a[4] + a[20];\n\tx0i = a[5] + a[21];\n\tx1r = a[4] - a[20];\n\tx1i = a[5] - a[21];\n\tx2r = a[12] + a[28];\n\tx2i = a[13] + a[29];\n\tx3r = a[12] - a[28];\n\tx3i = a[13] - a[29];\n\ty2r = x0r + x2r;\n\ty2i = x0i + x2i;\n\ty6r = x0r - x2r;\n\ty6i = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ty10r = wn4r * (x0r - x0i);\n\ty10i = wn4r * (x0i + x0r);\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ty14r = wn4r * (x0r + x0i);\n\ty14i = wn4r * (x0i - x0r);\n\tx0r = a[6] + a[22];\n\tx0i = a[7] + a[23];\n\tx1r = a[6] - a[22];\n\tx1i = a[7] - a[23];\n\tx2r = a[14] + a[30];\n\tx2i = a[15] + a[31];\n\tx3r = a[14] - a[30];\n\tx3i = a[15] - a[31];\n\ty3r = x0r + x2r;\n\ty3i = x0i + x2i;\n\ty7r = x0r - x2r;\n\ty7i = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\ty11r = wk1i * x0r - wk1r * x0i;\n\ty11i = wk1i * x0i + wk1r * x0r;\n\tx0r = x1r + x3i;\n\tx0i = x1i - x3r;\n\ty15r = wk1r * x0r - wk1i * x0i;\n\ty15i = wk1r * x0i + wk1i * x0r;\n\tx0r = y12r - y14r;\n\tx0i = y12i - y14i;\n\tx1r = y12r + y14r;\n\tx1i = y12i + y14i;\n\tx2r = y13r - y15r;\n\tx2i = y13i - y15i;\n\tx3r = y13r + y15r;\n\tx3i = y13i + y15i;\n\ta[24] = x0r + x2r;\n\ta[25] = x0i + x2i;\n\ta[26] = x0r - x2r;\n\ta[27] = x0i - x2i;\n\ta[28] = x1r - x3i;\n\ta[29] = x1i + x3r;\n\ta[30] = x1r + x3i;\n\ta[31] = x1i - x3r;\n\tx0r = y8r + y10r;\n\tx0i = y8i + y10i;\n\tx1r = y8r - y10r;\n\tx1i = y8i - y10i;\n\tx2r = y9r + y11r;\n\tx2i = y9i + y11i;\n\tx3r = y9r - y11r;\n\tx3i = y9i - y11i;\n\ta[16] = x0r + x2r;\n\ta[17] = x0i + x2i;\n\ta[18] = x0r - x2r;\n\ta[19] = x0i - x2i;\n\ta[20] = x1r - x3i;\n\ta[21] = x1i + x3r;\n\ta[22] = x1r + x3i;\n\ta[23] = x1i - x3r;\n\tx0r = y5r - y7i;\n\tx0i = y5i + y7r;\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\tx0r = y5r + y7i;\n\tx0i = y5i - y7r;\n\tx3r = wn4r * (x0r - x0i);\n\tx3i = wn4r * (x0i + x0r);\n\tx0r = y4r - y6i;\n\tx0i = y4i + y6r;\n\tx1r = y4r + y6i;\n\tx1i = y4i - y6r;\n\ta[8] = x0r + x2r;\n\ta[9] = x0i + x2i;\n\ta[10] = x0r - x2r;\n\ta[11] = x0i - x2i;\n\ta[12] = x1r - x3i;\n\ta[13] = x1i + x3r;\n\ta[14] = x1r + x3i;\n\ta[15] = x1i - x3r;\n\tx0r = y0r + y2r;\n\tx0i = y0i + y2i;\n\tx1r = y0r - y2r;\n\tx1i = y0i - y2i;\n\tx2r = y1r + y3r;\n\tx2i = y1i + y3i;\n\tx3r = y1r - y3r;\n\tx3i = y1i - y3i;\n\ta[0] = x0r + x2r;\n\ta[1] = x0i + x2i;\n\ta[2] = x0r - x2r;\n\ta[3] = x0i - x2i;\n\ta[4] = x1r - x3i;\n\ta[5] = x1i + x3r;\n\ta[6] = x1r + x3i;\n\ta[7] = x1i - x3r;\n}\n\n\nvoid cftf162(double *a, double *w)\n{\n\tdouble wn4r, wk1r, wk1i, wk2r, wk2i, wk3r, wk3i,\n\t\tx0r, x0i, x1r, x1i, x2r, x2i,\n\t\ty0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i,\n\t\ty4r, y4i, y5r, y5i, y6r, y6i, y7r, y7i,\n\t\ty8r, y8i, y9r, y9i, y10r, y10i, y11r, y11i,\n\t\ty12r, y12i, y13r, y13i, y14r, y14i, y15r, y15i;\n\n\twn4r = w[1];\n\twk1r = w[4];\n\twk1i = w[5];\n\twk3r = w[6];\n\twk3i = -w[7];\n\twk2r = w[8];\n\twk2i = w[9];\n\tx1r = a[0] - a[17];\n\tx1i = a[1] + a[16];\n\tx0r = a[8] - a[25];\n\tx0i = a[9] + a[24];\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\ty0r = x1r + x2r;\n\ty0i = x1i + x2i;\n\ty4r = x1r - x2r;\n\ty4i = x1i - x2i;\n\tx1r = a[0] + a[17];\n\tx1i = a[1] - a[16];\n\tx0r = a[8] + a[25];\n\tx0i = a[9] - a[24];\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\ty8r = x1r - x2i;\n\ty8i = x1i + x2r;\n\ty12r = x1r + x2i;\n\ty12i = x1i - x2r;\n\tx0r = a[2] - a[19];\n\tx0i = a[3] + a[18];\n\tx1r = wk1r * x0r - wk1i * x0i;\n\tx1i = wk1r * x0i + wk1i * x0r;\n\tx0r = a[10] - a[27];\n\tx0i = a[11] + a[26];\n\tx2r = wk3i * x0r - wk3r * x0i;\n\tx2i = wk3i * x0i + wk3r * x0r;\n\ty1r = x1r + x2r;\n\ty1i = x1i + x2i;\n\ty5r = x1r - x2r;\n\ty5i = x1i - x2i;\n\tx0r = a[2] + a[19];\n\tx0i = a[3] - a[18];\n\tx1r = wk3r * x0r - wk3i * x0i;\n\tx1i = wk3r * x0i + wk3i * x0r;\n\tx0r = a[10] + a[27];\n\tx0i = a[11] - a[26];\n\tx2r = wk1r * x0r + wk1i * x0i;\n\tx2i = wk1r * x0i - wk1i * x0r;\n\ty9r = x1r - x2r;\n\ty9i = x1i - x2i;\n\ty13r = x1r + x2r;\n\ty13i = x1i + x2i;\n\tx0r = a[4] - a[21];\n\tx0i = a[5] + a[20];\n\tx1r = wk2r * x0r - wk2i * x0i;\n\tx1i = wk2r * x0i + wk2i * x0r;\n\tx0r = a[12] - a[29];\n\tx0i = a[13] + a[28];\n\tx2r = wk2i * x0r - wk2r * x0i;\n\tx2i = wk2i * x0i + wk2r * x0r;\n\ty2r = x1r + x2r;\n\ty2i = x1i + x2i;\n\ty6r = x1r - x2r;\n\ty6i = x1i - x2i;\n\tx0r = a[4] + a[21];\n\tx0i = a[5] - a[20];\n\tx1r = wk2i * x0r - wk2r * x0i;\n\tx1i = wk2i * x0i + wk2r * x0r;\n\tx0r = a[12] + a[29];\n\tx0i = a[13] - a[28];\n\tx2r = wk2r * x0r - wk2i * x0i;\n\tx2i = wk2r * x0i + wk2i * x0r;\n\ty10r = x1r - x2r;\n\ty10i = x1i - x2i;\n\ty14r = x1r + x2r;\n\ty14i = x1i + x2i;\n\tx0r = a[6] - a[23];\n\tx0i = a[7] + a[22];\n\tx1r = wk3r * x0r - wk3i * x0i;\n\tx1i = wk3r * x0i + wk3i * x0r;\n\tx0r = a[14] - a[31];\n\tx0i = a[15] + a[30];\n\tx2r = wk1i * x0r - wk1r * x0i;\n\tx2i = wk1i * x0i + wk1r * x0r;\n\ty3r = x1r + x2r;\n\ty3i = x1i + x2i;\n\ty7r = x1r - x2r;\n\ty7i = x1i - x2i;\n\tx0r = a[6] + a[23];\n\tx0i = a[7] - a[22];\n\tx1r = wk1i * x0r + wk1r * x0i;\n\tx1i = wk1i * x0i - wk1r * x0r;\n\tx0r = a[14] + a[31];\n\tx0i = a[15] - a[30];\n\tx2r = wk3i * x0r - wk3r * x0i;\n\tx2i = wk3i * x0i + wk3r * x0r;\n\ty11r = x1r + x2r;\n\ty11i = x1i + x2i;\n\ty15r = x1r - x2r;\n\ty15i = x1i - x2i;\n\tx1r = y0r + y2r;\n\tx1i = y0i + y2i;\n\tx2r = y1r + y3r;\n\tx2i = y1i + y3i;\n\ta[0] = x1r + x2r;\n\ta[1] = x1i + x2i;\n\ta[2] = x1r - x2r;\n\ta[3] = x1i - x2i;\n\tx1r = y0r - y2r;\n\tx1i = y0i - y2i;\n\tx2r = y1r - y3r;\n\tx2i = y1i - y3i;\n\ta[4] = x1r - x2i;\n\ta[5] = x1i + x2r;\n\ta[6] = x1r + x2i;\n\ta[7] = x1i - x2r;\n\tx1r = y4r - y6i;\n\tx1i = y4i + y6r;\n\tx0r = y5r - y7i;\n\tx0i = y5i + y7r;\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\ta[8] = x1r + x2r;\n\ta[9] = x1i + x2i;\n\ta[10] = x1r - x2r;\n\ta[11] = x1i - x2i;\n\tx1r = y4r + y6i;\n\tx1i = y4i - y6r;\n\tx0r = y5r + y7i;\n\tx0i = y5i - y7r;\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\ta[12] = x1r - x2i;\n\ta[13] = x1i + x2r;\n\ta[14] = x1r + x2i;\n\ta[15] = x1i - x2r;\n\tx1r = y8r + y10r;\n\tx1i = y8i + y10i;\n\tx2r = y9r - y11r;\n\tx2i = y9i - y11i;\n\ta[16] = x1r + x2r;\n\ta[17] = x1i + x2i;\n\ta[18] = x1r - x2r;\n\ta[19] = x1i - x2i;\n\tx1r = y8r - y10r;\n\tx1i = y8i - y10i;\n\tx2r = y9r + y11r;\n\tx2i = y9i + y11i;\n\ta[20] = x1r - x2i;\n\ta[21] = x1i + x2r;\n\ta[22] = x1r + x2i;\n\ta[23] = x1i - x2r;\n\tx1r = y12r - y14i;\n\tx1i = y12i + y14r;\n\tx0r = y13r + y15i;\n\tx0i = y13i - y15r;\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\ta[24] = x1r + x2r;\n\ta[25] = x1i + x2i;\n\ta[26] = x1r - x2r;\n\ta[27] = x1i - x2i;\n\tx1r = y12r + y14i;\n\tx1i = y12i - y14r;\n\tx0r = y13r - y15i;\n\tx0i = y13i + y15r;\n\tx2r = wn4r * (x0r - x0i);\n\tx2i = wn4r * (x0i + x0r);\n\ta[28] = x1r - x2i;\n\ta[29] = x1i + x2r;\n\ta[30] = x1r + x2i;\n\ta[31] = x1i - x2r;\n}\n\n\nvoid cftf081(double *a, double *w)\n{\n\tdouble wn4r, x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i,\n\t\ty0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i,\n\t\ty4r, y4i, y5r, y5i, y6r, y6i, y7r, y7i;\n\n\twn4r = w[1];\n\tx0r = a[0] + a[8];\n\tx0i = a[1] + a[9];\n\tx1r = a[0] - a[8];\n\tx1i = a[1] - a[9];\n\tx2r = a[4] + a[12];\n\tx2i = a[5] + a[13];\n\tx3r = a[4] - a[12];\n\tx3i = a[5] - a[13];\n\ty0r = x0r + x2r;\n\ty0i = x0i + x2i;\n\ty2r = x0r - x2r;\n\ty2i = x0i - x2i;\n\ty1r = x1r - x3i;\n\ty1i = x1i + x3r;\n\ty3r = x1r + x3i;\n\ty3i = x1i - x3r;\n\tx0r = a[2] + a[10];\n\tx0i = a[3] + a[11];\n\tx1r = a[2] - a[10];\n\tx1i = a[3] - a[11];\n\tx2r = a[6] + a[14];\n\tx2i = a[7] + a[15];\n\tx3r = a[6] - a[14];\n\tx3i = a[7] - a[15];\n\ty4r = x0r + x2r;\n\ty4i = x0i + x2i;\n\ty6r = x0r - x2r;\n\ty6i = x0i - x2i;\n\tx0r = x1r - x3i;\n\tx0i = x1i + x3r;\n\tx2r = x1r + x3i;\n\tx2i = x1i - x3r;\n\ty5r = wn4r * (x0r - x0i);\n\ty5i = wn4r * (x0r + x0i);\n\ty7r = wn4r * (x2r - x2i);\n\ty7i = wn4r * (x2r + x2i);\n\ta[8] = y1r + y5r;\n\ta[9] = y1i + y5i;\n\ta[10] = y1r - y5r;\n\ta[11] = y1i - y5i;\n\ta[12] = y3r - y7i;\n\ta[13] = y3i + y7r;\n\ta[14] = y3r + y7i;\n\ta[15] = y3i - y7r;\n\ta[0] = y0r + y4r;\n\ta[1] = y0i + y4i;\n\ta[2] = y0r - y4r;\n\ta[3] = y0i - y4i;\n\ta[4] = y2r - y6i;\n\ta[5] = y2i + y6r;\n\ta[6] = y2r + y6i;\n\ta[7] = y2i - y6r;\n}\n\n\nvoid cftf082(double *a, double *w)\n{\n\tdouble wn4r, wk1r, wk1i, x0r, x0i, x1r, x1i,\n\t\ty0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i,\n\t\ty4r, y4i, y5r, y5i, y6r, y6i, y7r, y7i;\n\n\twn4r = w[1];\n\twk1r = w[2];\n\twk1i = w[3];\n\ty0r = a[0] - a[9];\n\ty0i = a[1] + a[8];\n\ty1r = a[0] + a[9];\n\ty1i = a[1] - a[8];\n\tx0r = a[4] - a[13];\n\tx0i = a[5] + a[12];\n\ty2r = wn4r * (x0r - x0i);\n\ty2i = wn4r * (x0i + x0r);\n\tx0r = a[4] + a[13];\n\tx0i = a[5] - a[12];\n\ty3r = wn4r * (x0r - x0i);\n\ty3i = wn4r * (x0i + x0r);\n\tx0r = a[2] - a[11];\n\tx0i = a[3] + a[10];\n\ty4r = wk1r * x0r - wk1i * x0i;\n\ty4i = wk1r * x0i + wk1i * x0r;\n\tx0r = a[2] + a[11];\n\tx0i = a[3] - a[10];\n\ty5r = wk1i * x0r - wk1r * x0i;\n\ty5i = wk1i * x0i + wk1r * x0r;\n\tx0r = a[6] - a[15];\n\tx0i = a[7] + a[14];\n\ty6r = wk1i * x0r - wk1r * x0i;\n\ty6i = wk1i * x0i + wk1r * x0r;\n\tx0r = a[6] + a[15];\n\tx0i = a[7] - a[14];\n\ty7r = wk1r * x0r - wk1i * x0i;\n\ty7i = wk1r * x0i + wk1i * x0r;\n\tx0r = y0r + y2r;\n\tx0i = y0i + y2i;\n\tx1r = y4r + y6r;\n\tx1i = y4i + y6i;\n\ta[0] = x0r + x1r;\n\ta[1] = x0i + x1i;\n\ta[2] = x0r - x1r;\n\ta[3] = x0i - x1i;\n\tx0r = y0r - y2r;\n\tx0i = y0i - y2i;\n\tx1r = y4r - y6r;\n\tx1i = y4i - y6i;\n\ta[4] = x0r - x1i;\n\ta[5] = x0i + x1r;\n\ta[6] = x0r + x1i;\n\ta[7] = x0i - x1r;\n\tx0r = y1r - y3i;\n\tx0i = y1i + y3r;\n\tx1r = y5r - y7r;\n\tx1i = y5i - y7i;\n\ta[8] = x0r + x1r;\n\ta[9] = x0i + x1i;\n\ta[10] = x0r - x1r;\n\ta[11] = x0i - x1i;\n\tx0r = y1r + y3i;\n\tx0i = y1i - y3r;\n\tx1r = y5r + y7r;\n\tx1i = y5i + y7i;\n\ta[12] = x0r - x1i;\n\ta[13] = x0i + x1r;\n\ta[14] = x0r + x1i;\n\ta[15] = x0i - x1r;\n}\n\n\nvoid cftf040(double *a)\n{\n\tdouble x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;\n\n\tx0r = a[0] + a[4];\n\tx0i = a[1] + a[5];\n\tx1r = a[0] - a[4];\n\tx1i = a[1] - a[5];\n\tx2r = a[2] + a[6];\n\tx2i = a[3] + a[7];\n\tx3r = a[2] - a[6];\n\tx3i = a[3] - a[7];\n\ta[0] = x0r + x2r;\n\ta[1] = x0i + x2i;\n\ta[2] = x1r - x3i;\n\ta[3] = x1i + x3r;\n\ta[4] = x0r - x2r;\n\ta[5] = x0i - x2i;\n\ta[6] = x1r + x3i;\n\ta[7] = x1i - x3r;\n}\n\n\nvoid cftb040(double *a)\n{\n\tdouble x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;\n\n\tx0r = a[0] + a[4];\n\tx0i = a[1] + a[5];\n\tx1r = a[0] - a[4];\n\tx1i = a[1] - a[5];\n\tx2r = a[2] + a[6];\n\tx2i = a[3] + a[7];\n\tx3r = a[2] - a[6];\n\tx3i = a[3] - a[7];\n\ta[0] = x0r + x2r;\n\ta[1] = x0i + x2i;\n\ta[2] = x1r + x3i;\n\ta[3] = x1i - x3r;\n\ta[4] = x0r - x2r;\n\ta[5] = x0i - x2i;\n\ta[6] = x1r - x3i;\n\ta[7] = x1i + x3r;\n}\n\n\nvoid cftx020(double *a)\n{\n\tdouble x0r, x0i;\n\n\tx0r = a[0] - a[2];\n\tx0i = a[1] - a[3];\n\ta[0] += a[2];\n\ta[1] += a[3];\n\ta[2] = x0r;\n\ta[3] = x0i;\n}\n\n\nvoid rftfsub(int n, double *a, int nc, double *c)\n{\n\tint j, k, kk, ks, m;\n\tdouble wkr, wki, xr, xi, yr, yi;\n\n\tm = n >> 1;\n\tks = 2 * nc / m;\n\tkk = 0;\n\tfor (j = 2; j < m; j += 2) {\n\t\tk = n - j;\n\t\tkk += ks;\n\t\twkr = 0.5 - c[nc - kk];\n\t\twki = c[kk];\n\t\txr = a[j] - a[k];\n\t\txi = a[j + 1] + a[k + 1];\n\t\tyr = wkr * xr - wki * xi;\n\t\tyi = wkr * xi + wki * xr;\n\t\ta[j] -= yr;\n\t\ta[j + 1] -= yi;\n\t\ta[k] += yr;\n\t\ta[k + 1] -= yi;\n\t}\n}\n\n\nvoid rftbsub(int n, double *a, int nc, double *c)\n{\n\tint j, k, kk, ks, m;\n\tdouble wkr, wki, xr, xi, yr, yi;\n\n\tm = n >> 1;\n\tks = 2 * nc / m;\n\tkk = 0;\n\tfor (j = 2; j < m; j += 2) {\n\t\tk = n - j;\n\t\tkk += ks;\n\t\twkr = 0.5 - c[nc - kk];\n\t\twki = c[kk];\n\t\txr = a[j] - a[k];\n\t\txi = a[j + 1] + a[k + 1];\n\t\tyr = wkr * xr + wki * xi;\n\t\tyi = wkr * xi - wki * xr;\n\t\ta[j] -= yr;\n\t\ta[j + 1] -= yi;\n\t\ta[k] += yr;\n\t\ta[k + 1] -= yi;\n\t}\n}\n\n\nvoid dctsub(int n, double *a, int nc, double *c)\n{\n\tint j, k, kk, ks, m;\n\tdouble wkr, wki, xr;\n\n\tm = n >> 1;\n\tks = nc / n;\n\tkk = 0;\n\tfor (j = 1; j < m; j++) {\n\t\tk = n - j;\n\t\tkk += ks;\n\t\twkr = c[kk] - c[nc - kk];\n\t\twki = c[kk] + c[nc - kk];\n\t\txr = wki * a[j] - wkr * a[k];\n\t\ta[j] = wkr * a[j] + wki * a[k];\n\t\ta[k] = xr;\n\t}\n\ta[m] *= c[0];\n}\n\n\nvoid dstsub(int n, double *a, int nc, double *c)\n{\n\tint j, k, kk, ks, m;\n\tdouble wkr, wki, xr;\n\n\tm = n >> 1;\n\tks = nc / n;\n\tkk = 0;\n\tfor (j = 1; j < m; j++) {\n\t\tk = n - j;\n\t\tkk += ks;\n\t\twkr = c[kk] - c[nc - kk];\n\t\twki = c[kk] + c[nc - kk];\n\t\txr = wki * a[k] - wkr * a[j];\n\t\ta[k] = wkr * a[k] + wki * a[j];\n\t\ta[j] = xr;\n\t}\n\ta[m] *= c[0];\n}\n","/*\n* \\class CConvolver\n*\n* \\brief Definition of CConvolver class.\n*\n* This class implements the necessary algorithms to do the convolution between signal and HRIR.\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: Nov 24 2015\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n\n#ifndef PLATFORM_DEFINED\n#if defined(__ANDROID_API__)\n#define PLATFORM_ANDROID\n#endif\n#define PLATFORM_DEFINED\n#endif\n\n#include <BinauralSpatializer/Convolver.h>\n\n\tCConvolver::CConvolver() {\n\t\tfirstTime = true;\n\t}\n\n\t// Set h[n] or HRIR and prepare a buffer with same length that HRIR. This allocates memory!!\n\tvoid CConvolver::SetHRIR(const CMonoBuffer<float> & _h, int frameSize)\n\t{\n        h = _h;\n\t\tif (firstTime) {\n\t\t\tfirstTime = false;\n\t\t\tif (_h.size() > frameSize) { SetBuffer(_h.size()); }\n\t\t\telse { SetBuffer(frameSize); }\n\t\t}\t\n\t}//End SetHRIR\n\t\t\n\t // Allocate memory space for the buffer required to store previously computed convolutions\n\tvoid CConvolver::SetBuffer(int bufferSize)\n\t{\n\t\tbuffer.resize(bufferSize);\n\t\tbuffer.assign(bufferSize, 0.0f);\n\t}\n\t\n\t// Do the convolution between the input and the HRIR stored. The output will have the same lenght that the input.\n\tvoid CConvolver::Process(const CMonoBuffer<float> & _input, CStereoBuffer<float> & _output, int channelNumber)\n\t{\t\t\t\t\t\n\t\tASSERT(h.size() > 0, RESULT_ERROR_NOTSET, \"HRIR must be set for convolver\", \"\");\n\t\tASSERT(buffer.size() > 0, RESULT_ERROR_NOTSET, \"Buffer must be set for convolver\", \"\");\n\t\tASSERT(h.size() == buffer.size(), RESULT_ERROR_BADSIZE, \"Buffer and HRIR size must agree for time-domain convolver\", \"\");\n\n#ifndef PLATFORM_ANDROID\n\n\t\t//Call the convolver\t\t\n\t\tSimpleTimeConvolver(const_cast<float*>(&_input[0]), \n\t\t\t\t\t\t\tconst_cast<float*>(&h[0]),\n\t\t\t\t\t\t\tconst_cast<float*>(&_output[0]),\n\t\t\t\t\t\t\tconst_cast<float*>(&buffer[0]),\n\t\t\t\t\t\t\t_input.size(), \n\t\t\t\t\t\t\th.size(), \n\t\t\t\t\t\t\tbuffer.size(), \n\t\t\t\t\t\t\t2, \n\t\t\t\t\t\t\tchannelNumber);\t\t\t\t//FIXME: the number of channels is hardcode at the moment\n\n#else\n\t\t// QUICK AND DIRTY SOLUTION FOR RUNNING BENCHMARK\n\t\tfloat inputArray[512];\n\t\tfloat outputArray[512];\n\t\tfloat hArray[512];\n\t\tfloat bufferArray[512];\n\t\tfor (int i = 0; i < 512; i++)\n\t\t{\n\t\t\tinputArray[i] = _input[i];\n\t\t\toutputArray[i] = 0.0f;\n\t\t\thArray[i] = h[i];\n\t\t\tbufferArray[i] = buffer[i];\n\t\t}\n\t\tSimpleTimeConvolver(inputArray, hArray, outputArray, bufferArray,\n\t\t\t_input.size(),\n\t\t\th.size(),\n\t\t\tbuffer.size(),\n\t\t\t2,\n\t\t\tchannelNumber);\t\t\t\t//FIXME: the number of channels is hardcode at the moment\n#endif\n\t}\n\n////////////////////////////\n//\tPrivate Methods       //\n////////////////////////////\n\n\tvoid CConvolver::SimpleTimeConvolver(float *input, float *h, float *output, float *buffer, const unsigned inputLength, const unsigned hLength, const unsigned bufferLength, int numberOfChannels, int channelNumber)\n\t{\n\n\t\tfloat yn; //accumulator\n\t\tint t, tt;\n\n\t\t//Convolution\t\n\t\tfor (int n = 0; n < inputLength; n++){\t\t\t\n\t\t\t//y[n] = h[k] * x[n-k]\n\t\t\tyn = 0.f;\n\t\t\tfor (int k = 0; k < hLength; k++){\n\t\t\t\tt = n - k;\n\t\t\t\tif (t > -1){\n\t\t\t\t\t//we are operating with the input\n\t\t\t\t\tif (t < inputLength)\n\t\t\t\t\t\tyn += h[k] * input[t];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//we are operating with the buffer\n\t\t\t\t\ttt = t + bufferLength;\n\t\t\t\t\tif (tt > -1)\n\t\t\t\t\t\tyn += h[k] * buffer[tt];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Save the result in the output. The ouput has the different channels interlaced.\n\t\t\t//TODO: Check that numberOfChannels >= channelNumber;\n\t\t\tif (channelNumber == 1)\n\t\t\t{\n\t\t\t\t//Channel 1 --> left -> [0, 2, 4, 6, 8]\n\t\t\t\toutput[numberOfChannels*n] = yn;\n\t\t\t}\n\t\t\telse if (channelNumber == 2){\n\t\t\t\t//Channel 2 --> right -> [1, 3, 5, 7, 9]\n\t\t\t\toutput[numberOfChannels*n + 1] = yn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//TODO: Do for more channels\n\t\t\t}\n\t\t}\n\t\t//Update the Buffer\n\t\t//Shift left the buffer \"inputLength\" positions\t\n\t\tShiftLeft(buffer, bufferLength, inputLength);\n\t\t//Copy the input into the right part of the buffer \n\t\tfor (int i = bufferLength - inputLength; i < bufferLength; i++){\n\t\t\tbuffer[i] = input[i - bufferLength + inputLength];\n\t\t}\n\t}//SimpleConvolveProcess\n\n/////////////////////////\n//\tAuxiliar Algorithms  //\n/////////////////////////\n\n\tvoid CConvolver::ShiftLeft(float *myarray, int size, int shiftBy)\n\t{\n\t\tif (shiftBy > size)\n\t\t{\n\t\t\tshiftBy = shiftBy - size;\n\t\t}\n\n\t\tif (size == 1)\n\t\t{\n\t\t\t//do nothing\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < size - shiftBy; i++)\n\t\t\t{\n\t\t\t\tmyarray[i] = myarray[i + shiftBy];\t\t//myarray[0] == myarray[2]\t\t\t\n\t\t\t}\n\t\t}\n\t}//shiftLeft\n","/*\n* \\class CCore\n*\n* \\brief Definition of CCore class.\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: November 2015\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n\n#include <BinauralSpatializer/Core.h>\n#include <BinauralSpatializer/Listener.h>\n#include <BinauralSpatializer/Environment.h>\n#include <Common/Debugger.h>\n#include <string>\n\n\nnamespace Binaural {\n\n\n//////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\n\tCCore::CCore(AudioState_Struct _audioState)\n\t\t:audioState{_audioState}\t{\n\t}\n\n    // Default constructor calls normal one with default values\n\tCCore::CCore()\n\t\t:CCore{ { 44100,512 }, // AudioState with default values: 44100 Hz sampleRate  & 512 bufferSize  \n\t\t\t  }\n\t{}\n//////////////////////////////////////////////\n// GENERAL PURPOSE METHODS\n\n\n\t// Set global audio state parameters\n\tvoid CCore::SetAudioState(AudioState_Struct _audioState)\n\t{\n        audioState = _audioState;\n    }\n\n\n\t// Get global audio state parameters\n\tAudioState_Struct CCore::GetAudioState() const\n\t{\n\t\t// FIXME: How does this depend on Core state?\n\t\treturn audioState;\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Get physical magnitudes\n\tCMagnitudes CCore::GetMagnitudes() const\n\t{\n\t\treturn magnitudes;\n\t}\n\n\t//////////////////////////////////////////////\n\n\t// Set new physical magnitudes\n\tvoid CCore::SetMagnitudes(CMagnitudes _magnitudes)\n\t{\n\t\tmagnitudes = _magnitudes;\n\t}\n\n//////////////////////////////////////////////\n// LISTENER METHODS\n\n    \n    // Create a new listener\n    shared_ptr<CListener> CCore::CreateListener(float listenerRadius)\n    {\n        // Create new source and add it to this core sources\n        try\n        {\n            shared_ptr<CListener> newSource(new CListener(this, listenerRadius));\n            listeners.push_back(newSource);\n            \n            SET_RESULT(RESULT_OK, \"Listener created succesfully\");\n            return newSource;\n        }\n        catch (std::bad_alloc& ba)\n        {\n            //SET_RESULT(RESULT_ERROR_BADALLOC, ba.what());\n            ASSERT(false, RESULT_ERROR_BADALLOC, ba.what(), \"\");\n            return nullptr;\n        }\n    }\n\n    \n    // Stateless privately called version\n    void CCore::RemoveListener(shared_ptr<CListener> listener)\n    {\n        if (listener == nullptr)\n        {\n            SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Pointer is NULL when attempting to remove single source DSP\");\n            return;\n        }\n        \n        bool found = false;\n        for( auto it = listeners.begin(); it != listeners.end(); ++it )\n        {\n            if (*it == listener )\n            {\n                listeners.erase(it);\n                found = true;\n                break;\n            }\n        }\n        \n        if(found)\n            SET_RESULT(RESULT_OK, \"Listener removed succesfully\");\n        else\n            SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Listener was not found when attempting to remove\");\n    }\n    \n    \n//////////////////////////////////////////////\n// ROOM METHODS\n\n    // Create a new audio source for spatialization\n    shared_ptr<CEnvironment> CCore::CreateEnvironment()\n    {\n        // Create new source and add it to this core sources\n        try\n        {\n            shared_ptr<CEnvironment> newSource(new CEnvironment(this));\n            environments.push_back(newSource);\n            \n            SET_RESULT(RESULT_OK, \"Single source DSP created succesfully\");\n            return newSource;\n        }\n        catch (std::bad_alloc& ba)\n        {\n            //SET_RESULT(RESULT_ERROR_BADALLOC, ba.what());\n            ASSERT(false, RESULT_ERROR_BADALLOC, ba.what(), \"\");\n            return nullptr;\n        }\n    }\n\n    \n    // Stateless privately called version\n    void CCore::RemoveEnvironment(shared_ptr<CEnvironment> environment)\n    {\n        if (environment == nullptr)\n        {\n            SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Pointer is NULL when attempting to remove single source DSP\");\n            return;\n        }\n        \n        bool found = false;\n        for( auto it = environments.begin(); it != environments.end(); ++it )\n        {\n            if (*it == environment )\n            {\n                environments.erase(it);\n                found = true;\n                break;\n            }\n        }\n        \n        if(found)\n            SET_RESULT(RESULT_OK, \"Environment removed succesfully\");\n        else\n            SET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Environment was not found when attempting to remove\");\n    }\n\n\n\n//////////////////////////////////////////////\n// AUDIO SOURCE METHODS\n\n\t// Create a new audio source for spatialization\n\tshared_ptr<CSingleSourceDSP> CCore::CreateSingleSourceDSP()\n\t{\n\t\t// Create new source and add it to this core sources\n\t\ttry\n\t\t{\n\t\t\tshared_ptr<CSingleSourceDSP> newSource(new CSingleSourceDSP(this));\n\t\t\taudioSources.push_back(newSource);\n            //newSource->SetupAnechoicConvolvers(audioState.bufferSize);\n\n\t\t\tSET_RESULT(RESULT_OK, \"Single source DSP created succesfully\");\n\t\t\treturn newSource;\n\t\t}\n\t\tcatch (std::bad_alloc& ba)\n\t\t{\n\t\t\t//SET_RESULT(RESULT_ERROR_BADALLOC, ba.what());\n\t\t\tASSERT(false, RESULT_ERROR_BADALLOC, ba.what(), \"\");\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\n\n\n\t// Stateless privately called version\n\tvoid CCore::RemoveSingleSourceDSP( shared_ptr<CSingleSourceDSP> source)\n\t{\n\t\tif (source == nullptr)\n\t\t{\n\t\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Pointer is NULL when attempting to remove single source DSP\");\n\t\t\treturn;\n\t\t}\n\n\t\tbool found = false;\n\t\tfor( auto it = audioSources.begin(); it != audioSources.end(); ++it )\n\t\t{\n\t\t\tif (*it == source )\n\t\t\t{\n\t\t\t\taudioSources.erase(it);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(found)\n\t\t\tSET_RESULT(RESULT_OK, \"Single source DSP removed succesfully\");\n\t\telse\n\t\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Single Source DSP was not found when attempting to remove\");\n\t}\n\t\n}\n","/**\n* \\class CHRTF\n*\n* \\brief Declaration of CHRTF class interface\n* \\details This class gets HRTF database LISTEN files, stores the data and implements algorithms to  get the HRIR functions using different interpolation methods.\n* \\version Alpha 1.0\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions:\n*\n* \\b Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement:\n*\n* \\b Licence:\n*\n*/\n\n\n#include <BinauralSpatializer/HRTF.h>\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <fstream>\n#include <ctime>\n#include <list>\n\n\n/*\t\\brief Start a new HRTF configuration.\n*\t\\param _HRIRlength, integer that indicates the HRIR length\n*\n* When this method is called: (1) Reset the previous HRTF, (2) Block the spatialization algorithm\n*/\nvoid CHRTF::BeginSetup(int32_t _HRIRlength, int32_t _bufferSize, int32_t _sampleRate){\n\n\tSET_RESULT(RESULT_OK, \"HRTF Setup started\");\n\n\tHRIRlength = _HRIRlength;\n\tbufferSize = _bufferSize;\n\tsampleRate = _sampleRate;\n\n\t//Clear every table\n\tt_HRTF_DataBase.clear();\n\tt_HRTF_ResampleInterpolationMethod.clear();\n\n\tsetupInProgress = true;\n}\n\n/* \\brief Set a new HRIR in the HRTF matrix\n*\t\\param azimuth\n*\t\\param elevation\n*\t\\param newHrir\n*/\nvoid CHRTF::AddHRIR (float azimuth, float elevation, HRIR_struct && newHRIR)\n{\n\tint iAzimuth = (int)round(azimuth / azimuthStep) * azimuthStep;\n\tint iElevation = (int)round(elevation / elevationStep) * elevationStep;\n\n  printf(\"CHRTF::AddHRIR()\\n\");\n  printf(\"iAzimuth = %i \\n\", iAzimuth);\n  printf(\"iElevation = %i \\n\", iElevation);\n  printf(\"newHRIR.leftDelay = %llu \\n\", newHRIR.leftDelay);\n  printf(\"newHRIR.rightDelay = %llu \\n\", newHRIR.rightDelay);\n  printf(\"newHRIR.leftHRIR.size() = %u \\n\", newHRIR.leftHRIR.size());\n  printf(\"newHRIR.rightHRIR.size() = %u \\n\", newHRIR.rightHRIR.size());\n\n\tauto returnValue = t_HRTF_DataBase.emplace(orientation(iAzimuth, iElevation), std::forward<HRIR_struct>(newHRIR));\n\tif (returnValue.second) {\n    printf(\"HRIR emplaced into t_HRTF_DataBase succesfully \\n\");\n\t\tSET_RESULT(RESULT_OK, \"HRIR emplaced into t_HRTF_DataBase succesfully\");\n\t}\n\telse\n\t{\n    printf(\"Error emplacing HRIR in t_HRTF_DataBase map\\n\");\n\t\tSET_RESULT(RESULT_WARNING, \"Error emplacing HRIR in t_HRTF_DataBase map\");\n\t}\n}\n\n/* \\brief Set a new HRIR in the HRTF matrix\n*\t\\param newTable\n*/\nvoid CHRTF::AddHRTFTable(HRTFTable_type && newTable)\n{\n\tt_HRTF_DataBase = newTable;\n}\n\n/* \\brief Stop the HRTF configuration and resample the HRTF matrix\n*   \\return boolean that is true when the process finish correctly\n*\n* When this method is called: (1) Delete the common delay of every HRIR of the DataBase table,\n* (2) Calculate resamplse tables performing different algorithms,\n* (3) Unblock the spatialization algoritms.\n*/\nbool CHRTF::EndSetup(){\n\n\t// If you want to show this message, do it in your app before calling this method:\n\t//std::cout << std::endl << \"Resampling HRTF Matrix...\" << std::endl;\n\t// The same for the OK result...\n\n\tif (!t_HRTF_DataBase.empty())\n\t{\n\t\t//Delete the common delay of every HRIR functions of the DataBase Table\n\t\tDeleteCommonDelay_HRTFDataBaseTable();\n\n\t\t//HRTF Resampling methdos\n\t\tFillOut_HRTFDatabaseTableInPoles();\t//Specific method for LISTEN DataBase\n\t\t//Resample_HRTFTable_NearestMethod(resampleStep);\n\t\tResample_HRTFTable_InterpolationMethod(resampleStep);\n\n\t\tsetupInProgress = false;\n\n\t\tSET_RESULT(RESULT_OK, \"HRTF Matrix resample completed succesfully\");\n\t}\n\telse\n\t{\n\t\t// TO DO: Should be ASSERT?\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"The t_HRTF_DataBase map has not been set\");\n\t}\n\treturn !setupInProgress;\n}\n\n\n/*-----  GET METHODS  ----------------------------------------------------------------------------------------------------------------------*/\n\nconst HRTFTable_type & CHRTF::GetRawHRTFTable() const\n{\n\treturn t_HRTF_DataBase;\n}\n\nconst HRIRbothEars_type CHRTF::GetHRIR(float azimuth, float elevation, bool runTimeInterpolation) const\n{\n\toneEarHRIR_struct s_leftHRIR, s_rightHRIR;\n\tCMonoBuffer<float> newLeftHRIR, newRightHRIR;\n\tHRIRbothEars_type newHRIR;\n\n\tif (!setupInProgress) {\n\t\t// TODO: STUDY the orientation round\n\t\tint iazimuth = static_cast<int>(round(azimuth));\n\t\tint ielevation = static_cast<int>(round(elevation));\n\t\t//FIXME!!\n\t\tif (iazimuth == 360) { iazimuth = 0; }\n\t\tif (ielevation == 360) { ielevation = 0; }\n\t\tif (ielevation == 90.0f) { iazimuth = 0; } // The HRIR with elevation 90 degrees is the same for every azimuth (north pole point)\n\t\tif (ielevation == 270.0f) { iazimuth = 0; } // The HRIR with elevation 270 degrees is the same for every azimuth (south pole point)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//END TODO & FIXME\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t//Run time interpolation ON\n\t\tif (runTimeInterpolation)\n\t\t{\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod.find(orientation(iazimuth, ielevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod.end()) {\n\t\t\t\t//Left Ear\n\t\t\t\ts_leftHRIR.delay = it->second.leftDelay;\n\t\t\t\ts_leftHRIR.HRIR = it->second.leftHRIR;\n\t\t\t\tnewHRIR.first = AddDelayToHRIR(LEFT, s_leftHRIR, azimuth, elevation);\n\t\t\t\t//Right Ear\n\t\t\t\ts_rightHRIR.delay = it->second.rightDelay;\n\t\t\t\ts_rightHRIR.HRIR = it->second.rightHRIR;\n\t\t\t\tnewHRIR.second = AddDelayToHRIR(RIGHT, s_rightHRIR, azimuth, elevation);\n\n\t\t\t\treturn newHRIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Left Ear\n\t\t\t\ts_leftHRIR = CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(LEFT, iazimuth, ielevation);\n\t\t\t\tnewHRIR.first = AddDelayToHRIR(LEFT, s_leftHRIR, azimuth, elevation);\n\t\t\t\t//Right Ear\n\t\t\t\ts_rightHRIR = CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(RIGHT, iazimuth, ielevation);\n\t\t\t\tnewHRIR.second = AddDelayToHRIR(RIGHT, s_rightHRIR, azimuth, elevation);\n\n\t\t\t\treturn newHRIR;\n\t\t\t}\n\t\t}\n\t\t//Run time interpolation OFF\n\t\telse\n\t\t{\n\t\t\t//1. Calculate the nearest orientation__________________________________________________________________________\n\t\t\tint nearestAzimuth = static_cast <int> (round(azimuth / resampleStep) * resampleStep);\n\t\t\tint nearestElevation = static_cast <int> (round(elevation / resampleStep) * resampleStep);\n\t\t\t// FIX ME\n\t\t\tif (nearestAzimuth == 360) { nearestAzimuth = 0; }\n\t\t\tif (nearestElevation == 360) { nearestElevation = 0; }\n\t\t\t// END FIX ME\n\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod.find(orientation(nearestAzimuth, nearestElevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod.end())\n\t\t\t{\n\t\t\t\t//Left Ear\n\t\t\t\ts_leftHRIR.delay = it->second.leftDelay;\n\t\t\t\ts_leftHRIR.HRIR = it->second.leftHRIR;\n\t\t\t\tnewHRIR.first = AddDelayToHRIR(LEFT, s_leftHRIR, azimuth, elevation);\n\t\t\t\t//Right Ear\n\t\t\t\ts_rightHRIR.delay = it->second.rightDelay;\n\t\t\t\ts_rightHRIR.HRIR = it->second.rightHRIR;\n\t\t\t\tnewHRIR.second = AddDelayToHRIR(RIGHT, s_rightHRIR, azimuth, elevation);\n\n\t\t\t\treturn newHRIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSET_RESULT(RESULT_WARNING, \"Get_HRIR: HRIR not found. Return empty\");\n\t\t\t\treturn emptyHRIRbothEars;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"Get_HRIR: HRTF Set up in progress\");\n\t\treturn emptyHRIRbothEars;\n\t}\n\n\tSET_RESULT(RESULT_WARNING, \"Get_HRIR: Table t_HRTF_ResampleInterpolationMethod does not contain the requested HRIR. Get_HRIR return empty\");\n\treturn emptyHRIRbothEars;\n}\nconst CMonoBuffer<float> CHRTF::GetHRIR_left(float _azimuth, float _elevation, bool runTimeInterpolation) const\n{\n\toneEarHRIR_struct s_leftHRIR;\n\tCMonoBuffer<float> newLeftHRIR;\n\n\tif (!setupInProgress) {\n\t\t// TODO: STUDY the orientation round\n\t\tint iazimuth = static_cast<int>(round(_azimuth));\n\t\tint ielevation = static_cast<int>(round(_elevation));\n\t\t//FIXME\n\t\tif (iazimuth == 360) { iazimuth = 0; }\n\t\tif (ielevation == 360) { ielevation = 0; }\n\t\tif (ielevation == 90.0f || ielevation == 270.0f) { iazimuth = 0; } // The HRIR with elevation 90 or 270 degrees is the same for every azimuth (north pole point)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //END TODO AND FIXME\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //Run time interpolation ON\n\t\tif (runTimeInterpolation)\n\t\t{\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod.find(orientation(iazimuth, ielevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod.end())\n\t\t\t{\n\t\t\t\ts_leftHRIR.delay = it->second.leftDelay;\n\t\t\t\ts_leftHRIR.HRIR = it->second.leftHRIR;\n\t\t\t\tnewLeftHRIR = AddDelayToHRIR(LEFT, s_leftHRIR, _azimuth, _elevation);\n\t\t\t\treturn newLeftHRIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts_leftHRIR = CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(LEFT, iazimuth, ielevation);\n\t\t\t\tnewLeftHRIR = AddDelayToHRIR(LEFT, s_leftHRIR, _azimuth, _elevation);\n\t\t\t\treturn newLeftHRIR;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//1. Calculate the nearest orientation\n\t\t\tint nearestAzimuth = (int)round(_azimuth / resampleStep) * resampleStep;\n\t\t\tint nearestElevation = (int)round(_elevation / resampleStep) * resampleStep;\n\t\t\tif (nearestAzimuth == 360) { nearestAzimuth = 0; }\n\t\t\tif (nearestElevation == 360) { nearestElevation = 0; }\n\n\t\t\t//2. Search the orientation in the Interpolation table\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod.find(orientation(nearestAzimuth, nearestElevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod.end())\n\t\t\t{\n\t\t\t\ts_leftHRIR.delay = it->second.leftDelay;\n\t\t\t\ts_leftHRIR.HRIR = it->second.leftHRIR;\n\t\t\t\tnewLeftHRIR = AddDelayToHRIR(LEFT, s_leftHRIR, _azimuth, _elevation);\n\t\t\t\treturn newLeftHRIR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetHRIR_left: HRIR not found\");\n\t\t\t\treturn emptyMonoBuffer;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetHRIR_left: HRTF Set up in progress\");\n\t\treturn emptyMonoBuffer;\n\t}\n\tSET_RESULT(RESULT_WARNING, \"GetHRIR_left return empty\");\n\treturn emptyMonoBuffer;\n}\nconst CMonoBuffer<float> CHRTF::GetHRIR_right(float _azimuth, float _elevation, bool runTimeInterpolation) const\n{\n\toneEarHRIR_struct s_rightHRIR;\n\tCMonoBuffer<float> newRightHRIR;\n\tif (!setupInProgress)\n\t{\n\t\t//Run time interpolation ON\n\t\tif (runTimeInterpolation)\n\t\t{\n\t\t\t// TODO: STUDY the orientation round\n\t\t\tint iazimuth = static_cast<int>(round(_azimuth));\n\t\t\tint ielevation = static_cast<int>(round(_elevation));\n\t\t\t//FIXME\n\t\t\tif (iazimuth == 360) { iazimuth = 0; }\n\t\t\tif (ielevation == 360) { ielevation = 0; }\n\t\t\tif (ielevation == 90.0f || ielevation == 270.0f) { iazimuth = 0; } // The HRIR with elevation 90 or 270 degrees is the same for every azimuth (north pole point)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //END TODO & FIXME\n\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod.find(orientation(iazimuth, ielevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod.end())\n\t\t\t{\n\t\t\t\ts_rightHRIR.delay = it->second.rightDelay;\n\t\t\t\ts_rightHRIR.HRIR = it->second.rightHRIR;\n\t\t\t\tnewRightHRIR = AddDelayToHRIR(RIGHT, s_rightHRIR, _azimuth, _elevation);\n\t\t\t\treturn newRightHRIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts_rightHRIR = CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(RIGHT, iazimuth, ielevation);\n\t\t\t\tnewRightHRIR = AddDelayToHRIR(RIGHT, s_rightHRIR, _azimuth, _elevation);\n\n\t\t\t\treturn newRightHRIR;\n\t\t\t\t/*//Without delay\n\t\t\t\treturn s_rightHRIR.HRIR;*/\n\t\t\t}\n\t\t}\n\t\t//Run time interpolation OFF\n\t\telse\n\t\t{\n\t\t\t//Calculate the nearest orientation\n\t\t\tint nearestAzimuth = (int)round(_azimuth / resampleStep) * resampleStep;\n\t\t\tint nearestElevation = (int)round(_elevation / resampleStep) * resampleStep;\n\n\t\t\t// FIX ME\n\t\t\tif (nearestAzimuth == 360) { nearestAzimuth = 0; }\n\t\t\tif (nearestElevation == 360) { nearestElevation = 0; }\n\t\t\t// END FIX ME\n\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod.find(orientation(nearestAzimuth, nearestElevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod.end())\n\t\t\t{\n\t\t\t\ts_rightHRIR.delay = it->second.rightDelay;\n\t\t\t\ts_rightHRIR.HRIR = it->second.rightHRIR;\n\t\t\t\tnewRightHRIR = AddDelayToHRIR(RIGHT, s_rightHRIR, _azimuth, _elevation);\n\n\t\t\t\treturn newRightHRIR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetHRIR_right: HRIR not found\");\n\t\t\t\treturn emptyMonoBuffer;\n\t\t\t}\n\t\t}\n\t}\n\n\telse\n\t{\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetHRIR_right: HRTF Set up in progress\");\n\t\treturn emptyMonoBuffer;\n\t}\n\tSET_RESULT(RESULT_WARNING, \"GetHRIR_right return empty\");\n\treturn emptyMonoBuffer;\n}\n\nconst oneEarHRIR_struct CHRTF::GetHRIR_left_frequency(float azimuth, float elevation, bool interpolate) const\n{\n\toneEarHRIR_struct s_leftHRIR;\n\tCMonoBuffer<float> newLeftHRIR;\n\n\tif (!setupInProgress) {\n\t\t// TODO: STUDY the orientation round\n\t\tint iazimuth = static_cast<int>(round(azimuth));\n\t\tint ielevation = static_cast<int>(round(elevation));\n\n\t\t//FIXME!!\n\t\tif (iazimuth == 360) { iazimuth = 0; }\n\t\tif (ielevation == 360) { ielevation = 0; }\n\t\tif (ielevation == 90.0f) { iazimuth = 0; } // The HRIR with elevation 90 degrees is the same for every azimuth (north pole point)\n\t\tif (ielevation == 270.0f) { iazimuth = 0; } // The HRIR with elevation 270 degrees is the same for every azimuth (south pole point)\n\t\t//END TODO & FIXME\n\n\t\t\tif (interpolate)\n\t\t\t{\n        printf(\"s_leftHRIR.delay = %i \\n\", s_leftHRIR.delay);\n        printf(\"s_leftHRIR.HRIR size = %i \\n\", s_leftHRIR.HRIR.size());\n        printf(\"iazimuth = %i \\n\", iazimuth);\n        printf(\"ielevation = %i \\n\", ielevation);\n\n        orientation(iazimuth, ielevation);\n\n\t\t\t\tauto it = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(iazimuth, ielevation));\n\n        printf(\"did find stuff = %i \\n\", it != t_HRTF_ResampleInterpolationMethod_frequency.end());\n\n\t\t\t\tif (it != t_HRTF_ResampleInterpolationMethod_frequency.end()) {\n          printf(\"found stuff \\n\");\n          // printf(\"it->second.leftDelay = %i \\n\", it->second.leftDelay);\n\t\t\t\t\t// s_leftHRIR.delay = it->second.leftDelay;\n\t\t\t\t\t// s_leftHRIR.HRIR = it->second.leftHRIR;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Run time interpolation ON\n          printf(\"Run time interpolation ON \\n\");\n\t\t\t\t\ts_leftHRIR = CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(LEFT, iazimuth, ielevation, true);\n\t\t\t\t}\n\n\t\t\t\t//Modify delay if customized delay is activate\n\t\t\t\tif (enableCustomizedITD) {\n\t\t\t\t\ts_leftHRIR.delay = GetCustomizedDelay(iazimuth, ielevation, LEFT);\n\t\t\t\t}\n\n\t\t\t\treturn s_leftHRIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Run time interpolation OFF\n\t\t\t\tint nearestAzimuth =\t(int)round(iazimuth / resampleStep) * resampleStep;\n\t\t\t\tint nearestElevation =\t(int)round(ielevation / resampleStep) * resampleStep;\n\t\t\t\t// FIX ME\n\t\t\t\t//if (iAzimuth == 360) { iAzimuth = 0; }\n\t\t\t\t//if (iElevation == 360) { iElevation = 0; }\n\t\t\t\t//if (iElevation == 90.0f) { iAzimuth = 0; } // The HRIR with elevation 90 degrees is the same for every azimuth (north pole point)\n\t\t\t\t//if (iElevation == 270.0f) { iAzimuth = 0; } // The HRIR with elevation 270 degrees is the same for every azimuth (south pole point)\n\t\t\t\t// END FIX ME\n\n\t\t\t\tauto it = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(nearestAzimuth, nearestElevation));\n\t\t\t\tif (it != t_HRTF_ResampleInterpolationMethod_frequency.end())\n\t\t\t\t{\n\t\t\t\t\ts_leftHRIR.delay = it->second.leftDelay;\n\t\t\t\t\ts_leftHRIR.HRIR = it->second.leftHRIR;\n\t\t\t\t\t//Modify delay if customized delay is activate\n\t\t\t\t\tif (enableCustomizedITD) {\n\t\t\t\t\t\ts_leftHRIR.delay = GetCustomizedDelay(nearestAzimuth, nearestElevation, LEFT);\n\t\t\t\t\t}\n\t\t\t\t\treturn s_leftHRIR;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetInterpolated_leftHRIR_frequency: HRIR not found\");\n\t\t\t\t\treturn emptyOneEarHRTF;\n\t\t\t\t}\n\t\t\t}\n\t}\n\telse\n\t{\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetInterpolated_leftHRIR_frequency: HRTF Set up in progress\");\n\t\treturn emptyOneEarHRTF;\n\t}\n\tSET_RESULT(RESULT_WARNING, \"GetInterpolated_leftHRIR_frequency return empty\");\n\treturn emptyOneEarHRTF;\n}\nconst oneEarHRIR_struct CHRTF::GetHRIR_right_frequency(float _azimuth, float _elevation, bool interpolate) const\n{\n\toneEarHRIR_struct s_rightHRIR;\n\tCMonoBuffer<float> newRightHRIR;\n\n\tif (!setupInProgress) {\n\t\t// TODO: STUDY the orientation round\n\t\tint iazimuth = static_cast<int>(round(_azimuth));\n\t\tint ielevation = static_cast<int>(round(_elevation));\n\n\t\t//FIXME!!\n\t\tif (iazimuth == 360) { iazimuth = 0; }\n\t\tif (ielevation == 360) { ielevation = 0; }\n\t\tif (ielevation == 90.0f) { iazimuth = 0; } // The HRIR with elevation 90 degrees is the same for every azimuth (north pole point)\n\t\tif (ielevation == 270.0f) { iazimuth = 0; } // The HRIR with elevation 270 degrees is the same for every azimuth (south pole point)\n\t\t//END FIXME\n\n\t\tif (interpolate)\n\t\t{\n\t\t\t//TODO get table Nearest instead of Interpolated\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(iazimuth, ielevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod_frequency.end())\n\t\t\t{\n\t\t\t\ts_rightHRIR.delay = it->second.rightDelay;\n\t\t\t\ts_rightHRIR.HRIR = it->second.rightHRIR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts_rightHRIR = CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(RIGHT, iazimuth, ielevation, true);\n\t\t\t}\n\n\t\t\t//Modify delay if customized delay is activate\n\t\t\tif (enableCustomizedITD) {\n\t\t\t\ts_rightHRIR.delay = GetCustomizedDelay(iazimuth, ielevation, RIGHT);\n\t\t\t}\n\n\t\t\treturn s_rightHRIR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Run time interpolation OFF\n\t\t\tint nearestAzimuth = (int)round(iazimuth / resampleStep) * resampleStep;\n\t\t\tint nearestElevation = (int)round(ielevation / resampleStep) * resampleStep;\n\t\t\t// FIX ME\n\t\t\t//if (iAzimuth == 360) { iAzimuth = 0; }\n\t\t\t//if (iElevation == 360) { iElevation = 0; }\n\t\t\t//if (iElevation == 90.0f) { iAzimuth = 0; } // The HRIR with elevation 90 degrees is the same for every azimuth (north pole point)\n\t\t\t//if (iElevation == 270.0f) { iAzimuth = 0; } // The HRIR with elevation 270 degrees is the same for every azimuth (south pole point)\n\t\t\t// END FIX ME\n\n\t\t\tauto it = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(nearestAzimuth, nearestElevation));\n\t\t\tif (it != t_HRTF_ResampleInterpolationMethod_frequency.end())\n\t\t\t{\n\t\t\t\ts_rightHRIR.delay = it->second.rightDelay;\n\t\t\t\ts_rightHRIR.HRIR = it->second.rightHRIR;\n\n\t\t\t\t//Modify delay if customized delay is activate\n\t\t\t\tif (enableCustomizedITD) {\n\t\t\t\t\ts_rightHRIR.delay = GetCustomizedDelay(nearestAzimuth, nearestElevation, RIGHT);\n\t\t\t\t}\n\n\t\t\t\treturn s_rightHRIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetInterpolated_rightHRIR_frequency: HRIR not found\");\n\t\t\t\treturn emptyOneEarHRTF;\n\t\t\t}\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"GetInterpolated_rightHRIR_frequency: HRTF Set up in progress\");\n\t\treturn emptyOneEarHRTF;\n\t}\n\tSET_RESULT(RESULT_WARNING, \"GetInterpolated_rightHRIR_frequency return empty\");\n\treturn emptyOneEarHRTF;\n}\n\n\n//Methods for testing\nconst CMonoBuffer<float> CHRTF::GetHRIR_fromDataBaseTableLEFT(float azimuth, float elevation, int interpolate) const\n{\n\tif (!setupInProgress) {\n\n\t\t//1. Calculate the nearest orientation__________________________________________________________________________\n\t\tint iAzimuth = (int)round(azimuth / 15) * 15;\n\t\tint iElevation = (int)round(elevation / 15) * 15;\n\t\t//fs << azimuth << \",\" << iAzimuth << \"\\t\" << elevation << \",\" << iElevation << \"\\t\"<<resampleStep<< std::endl;\n\n\t\t//int iAzimuth = static_cast<int> (round(azimuth));\n\t\t//int iElevation = static_cast<int> (round(elevation));\n\n\t\t// FIX ME\n\t\tif (iAzimuth == 360) { iAzimuth = 0; }\n\t\tif (iElevation == 360) { iElevation = 0; }\n\t\t// END FIX ME\n\n\n\t\tauto it = t_HRTF_DataBase.find(orientation(iAzimuth, iElevation));\n\t\tif (it != t_HRTF_DataBase.end())\n\t\t{\n\t\t//\tstd::cout << \"GetPrecomputed_leftHRIR: Sending a HRIR value\" << std::endl;\n\t\t\treturn it->second.leftHRIR;\n\n\t\t}\n\t\telse {\n\n\t\t\tSET_RESULT(RESULT_WARNING, \"GetHRIR_fromDataBaseTableLEFT return empty\");\n\t\t\treturn emptyMonoBuffer;\n\t\t}\n\n\t}\n    else {\n        SET_RESULT(RESULT_WARNING, \"Cannot return HRIR  in the middle of the set up process\");\n        return emptyMonoBuffer;\n    }\n\n}\nconst CMonoBuffer<float> CHRTF::GetHRIR_fromDataBaseTableRIGHT(float azimuth, float elevation, int interpolate) const\n{\n\n\tif (!setupInProgress) {\n\n\t\t//1. Calculate the nearest orientation__________________________________________________________________________\n\t\tint iAzimuth = (int)round(azimuth / 15) * 15;\n\t\tint iElevation = (int)round(elevation / 15) * 15;\n\n\n\t\t//int iAzimuth = static_cast<int> (round(azimuth));\n\t\t//int iElevation = static_cast<int> (round(elevation));\n\n\t\t//fs << azimuth << \",\" << iAzimuth << \"\\t\" << elevation << \",\" << iElevation << \"\\t\" << resampleStep << std::endl;\n\t\t// FIX ME\n\t\tif (iAzimuth == 360) { iAzimuth = 0; }\n\t\tif (iElevation == 360) { iElevation = 0; }\n\t\t// END FIX ME\n\n\n\t\tauto it = t_HRTF_DataBase.find(orientation(iAzimuth, iElevation));\n\t\tif (it != t_HRTF_DataBase.end())\n\t\t{\n\t\t\t//std::cout << \"GetPrecomputed_leftHRIR: Sending a HRIR value\" << std::endl;\n\t\t\treturn it->second.rightHRIR;\n\n\t\t}\n\t\telse {\n\t\t\tSET_RESULT(RESULT_WARNING, \"GetHRIR_fromDataBaseTableRIGHT return empty\");\n\t\t\treturn emptyMonoBuffer;\n\t\t}\n\n\t}\n    else {\n        SET_RESULT(RESULT_WARNING, \"Cannot return HRIR  in the middle of the set up process\");\n        return emptyMonoBuffer;\n    }\n}\n\n\n\n//******************************************************************************************************************************************\n//   Resample and Get HRIR methods methods     ********************************************************************************************\n//******************************************************************************************************************************************\n\n/* \\brief Fill out the HRTF for every azimuth and two specific elevations: 90 and 270 degrees for the LISTEN HRTF DataBase\n*/\nvoid CHRTF::FillOut_HRTFDatabaseTableInPoles() {\n\n\t// FIXME: This method is specific for the LISTEN DATA BASE\n\n\tHRIR_struct precalculatedHRIR_270, copiedHRIR_90;\t//temporal vrble to store HRIR\n\tbool firstTime270 = true;\n\t//int HRIRsize;\n\n\t//** 90 degrees elevation\n\tauto it90 = t_HRTF_DataBase.find(orientation(0, 90));\n\tif (it90 != t_HRTF_DataBase.end()) {\n\t\tcopiedHRIR_90 = it90->second;\n\t\t//SET_RESULT(RESULT_OK, \"\");\n\t}\n\telse {\n\t\t//std::cout << \"HRIR with orientation(0, 90) in table t_HRTF_DataBase not found\" << std::endl;\n\t\tSET_RESULT(RESULT_WARNING, \"HRIR with orientation(0, 90) in table t_HRTF_DataBase not found\");\n\t}\n\n\t//** 270 degrees elevation\n\tif (t_HRTF_DataBase.find(orientation(0, 270)) == t_HRTF_DataBase.end()) {//If HRIR with orientation (0,270) doesn't exist in t_HRTF_DataBase\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // Calculate the HRIR for elevation = 270 degrees as the weithed sum of all HRIRs with elevation 315 degrees\n\t\tfloat HRIR_cnt = 0.0f;\t// HRIR counter necesary to do the weithed sum\n\t\tfor (auto it = t_HRTF_DataBase.begin(); it != t_HRTF_DataBase.end(); ++it)\n\t\t{\n\t\t\t//HRIRsize = it->second.first.GetLength();\n\t\t\t//HRIRsize = HRIRlength;\n\t\t\tif (it->first.elevation == 315)\n\t\t\t{\n\t\t\t\tif (firstTime270) {\n\t\t\t\t\tprecalculatedHRIR_270.leftHRIR = it->second.leftHRIR;\t\t// leftHRIR\n\t\t\t\t\tprecalculatedHRIR_270.leftDelay = it->second.leftDelay;\t\t// leftDelay\n\t\t\t\t\tprecalculatedHRIR_270.rightHRIR = it->second.rightHRIR;\t\t// rightHRIR\n\t\t\t\t\tprecalculatedHRIR_270.rightDelay = it->second.rightDelay;\t// rightDelay\n\t\t\t\t\tHRIR_cnt++;\n\t\t\t\t\tfirstTime270 = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < HRIRlength; i++) {\n\t\t\t\t\t\tprecalculatedHRIR_270.leftHRIR[i] = precalculatedHRIR_270.leftHRIR[i] + it->second.leftHRIR[i];\t\t// leftHRIR\n\t\t\t\t\t\tprecalculatedHRIR_270.rightHRIR[i] = precalculatedHRIR_270.rightHRIR[i] + it->second.rightHRIR[i];\t// rightHRIR\n\t\t\t\t\t}\n\t\t\t\t\tprecalculatedHRIR_270.leftDelay = precalculatedHRIR_270.leftDelay + it->second.leftDelay;\t\t// leftDelay\n\t\t\t\t\tprecalculatedHRIR_270.rightDelay = precalculatedHRIR_270.rightDelay + it->second.rightDelay;\t// rightDelay\n\t\t\t\t\tHRIR_cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//else {\n\n\t\t\t//\tstd::cout << \"The HRTF DataBase table do not contain values for HRIR with elevation 315 degrees\" << std::endl;\n\t\t\t//}\n\t\t}\n\n\t\tfor (int i = 0; i < HRIRlength; i++) {\n\t\t\tprecalculatedHRIR_270.leftHRIR[i] = (1 / HRIR_cnt) * precalculatedHRIR_270.leftHRIR[i];\t\t// leftHRIR\n\t\t\tprecalculatedHRIR_270.rightHRIR[i] = (1 / HRIR_cnt) * precalculatedHRIR_270.rightHRIR[i];\t// rightHRIR\n\t\t}\n\t\t//TODO: Doing a round it's a good idea?\n\t\tprecalculatedHRIR_270.leftDelay = static_cast <unsigned long> (round((1 / HRIR_cnt) * precalculatedHRIR_270.leftDelay));\t\t// leftDelay\n\t\tprecalculatedHRIR_270.rightDelay = static_cast <unsigned long> (round((1 / HRIR_cnt) * precalculatedHRIR_270.rightDelay));\t// rightDelay\n\n\n\t}\n\telse //If HRIR with orientation (0,270) exist in t_HRTF_DataBase\n\t{\n\t\tauto it270 = t_HRTF_DataBase.find(orientation(0, 270));\n\t\tprecalculatedHRIR_270 = it270->second;\n\t}\n\n\t// Fill out the table\n\tfor (int i = 0; i < 360; i = i + 15) {\n\t\t//Elevation 270 degrees\n\t\tt_HRTF_DataBase.emplace(orientation(i, 270), precalculatedHRIR_270);\n\t\t//Elevation 90 degrees\n\t\tt_HRTF_DataBase.emplace(orientation(i, 90), copiedHRIR_90);\n\t\t//Azimuth 360 degrees\n\t\tauto it0 = t_HRTF_DataBase.find(orientation(0, i));\n\t\tif (it0 != t_HRTF_DataBase.end()) {\n\t\t\tt_HRTF_DataBase.emplace(orientation(360, i), it0->second);\n\t\t}\n\t}\n}\n\n\n/* \\brief Calculate the resample matrix using the Barycentric interpolation Method (copy the HRIR function of the nearest orientation)\n*\t\\param resampleStep HRTF resample matrix step for both azimuth and elevation\n*/\nvoid CHRTF::Resample_HRTFTable_InterpolationMethod(int resampleStep)\n{\n\tHRIR_struct interpolatedHRIR;\n\n\t//Resample Interpolation Algorithm\n\tfor (int newAzimuth = 0; newAzimuth < 360; newAzimuth = newAzimuth + resampleStep) {\n\t\tfor (int newElevation = 0; newElevation <= 90; newElevation = newElevation + resampleStep)\n\t\t{\n\t\t\tauto it = t_HRTF_DataBase.find(orientation(newAzimuth, newElevation));\n\t\t\tif (it != t_HRTF_DataBase.end()) {\n\t\t\t\t//Fill out interpolated table. IR in time domain\n\t\t\t\tauto returnValue = t_HRTF_ResampleInterpolationMethod.emplace(orientation(newAzimuth, newElevation), it->second);\n\t\t\t\tif (returnValue.second) {\n          // SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod scuccesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod scuccesfully\\n\");\n        }\n\t\t\t\telse {\n          // SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\\n\");\n        }\n\n\t\t\t\t//Fill out interpolated frequency table. IR in frequency domain\n\t\t\t\tHRIR_struct temp;\n\t\t\t\tCommon::CFconvolver::GetFFT(it->second.leftHRIR, temp.leftHRIR, bufferSize);\n\t\t\t\tCommon::CFconvolver::GetFFT(it->second.rightHRIR, temp.rightHRIR, bufferSize);\n\t\t\t\ttemp.leftDelay = it->second.leftDelay;\n\t\t\t\ttemp.rightDelay = it->second.rightDelay;\n\t\t\t\treturnValue = t_HRTF_ResampleInterpolationMethod_frequency.emplace(orientation(newAzimuth, newElevation), std::forward<HRIR_struct>(temp));\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\\n\");\n        }\n\t\t\t\telse {\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\\n\");\n        }\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t//Get the interpolated HRIR\n\t\t\t\tinterpolatedHRIR = CalculateHRIR_InterpolationMethod(newAzimuth, newElevation);\n\n\t\t\t\t//Fill out interpolated frequency table. IR in frequency domain\n\t\t\t\tHRIR_struct temp;\n\t\t\t\tCommon::CFconvolver::GetFFT(interpolatedHRIR.leftHRIR, temp.leftHRIR, bufferSize);\n\t\t\t\tCommon::CFconvolver::GetFFT(interpolatedHRIR.rightHRIR, temp.rightHRIR, bufferSize);\n\t\t\t\ttemp.leftDelay = interpolatedHRIR.leftDelay;\n\t\t\t\ttemp.rightDelay = interpolatedHRIR.rightDelay;\n\t\t\t\tauto returnValue = t_HRTF_ResampleInterpolationMethod_frequency.emplace(orientation(newAzimuth, newElevation), std::forward<HRIR_struct>(temp));\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\\n\");\n        }\n\t\t\t\telse {\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\\n\");\n        }\n\t\t\t\t//Fill out the resample table\n\t\t\t\treturnValue = t_HRTF_ResampleInterpolationMethod.emplace(orientation(newAzimuth, newElevation), std::forward<HRIR_struct>(interpolatedHRIR));\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod succesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod succesfully\\n\");\n        }\n\t\t\t\telse {\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\\n\");\n        }\n\t\t\t}\n\t\t}\n\n\t\tfor (int newElevation = 270; newElevation < 360; newElevation = newElevation + resampleStep)\n\t\t{\n\t\t\tauto it2 = t_HRTF_DataBase.find(orientation(newAzimuth, newElevation));\n\t\t\tif (it2 != t_HRTF_DataBase.end()) {\n\t\t\t\t//Fill out interpolated table. IR in time domain\n\t\t\t\tauto returnValue = t_HRTF_ResampleInterpolationMethod.emplace(orientation(newAzimuth, newElevation), it2->second);\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod succesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod succesfully\\n\");\n        }\n\t\t\t\telse\t\t\t\t\t{\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\\n\");\n        }\n\t\t\t\t//Fill out interpolated frequency table. IR in frequency domain\n\t\t\t\tHRIR_struct temp;\n\t\t\t\tCommon::CFconvolver::GetFFT(it2->second.leftHRIR, temp.leftHRIR, bufferSize);\n\t\t\t\tCommon::CFconvolver::GetFFT(it2->second.rightHRIR, temp.rightHRIR, bufferSize);\n\t\t\t\ttemp.leftDelay = it2->second.leftDelay;\n\t\t\t\ttemp.rightDelay = it2->second.rightDelay;\n\t\t\t\treturnValue = t_HRTF_ResampleInterpolationMethod_frequency.emplace(orientation(newAzimuth, newElevation), std::forward<HRIR_struct>(temp));\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\\n\");\n        }\n\t\t\t\telse {\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\\n\");\n        }\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//Get the interpolated HRIR\n\t\t\t\tinterpolatedHRIR = CalculateHRIR_InterpolationMethod(newAzimuth, newElevation);\n\t\t\t\t//Fill out interpolated frequency table. IR in frequency domain\n\t\t\t\tHRIR_struct temp;\n\t\t\t\tCommon::CFconvolver::GetFFT(interpolatedHRIR.leftHRIR, temp.leftHRIR, bufferSize);\n\t\t\t\tCommon::CFconvolver::GetFFT(interpolatedHRIR.rightHRIR, temp.rightHRIR, bufferSize);\n\t\t\t\ttemp.leftDelay = interpolatedHRIR.leftDelay;\n\t\t\t\ttemp.rightDelay = interpolatedHRIR.rightDelay;\n\t\t\t\tauto returnValue = t_HRTF_ResampleInterpolationMethod_frequency.emplace(orientation(newAzimuth, newElevation), std::forward<HRIR_struct>(temp));\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod_Frequency scuccesfully\\n\");\n        }\n\t\t\t\telse {\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod_Frequency map\\n\");\n        }\n\t\t\t\t//Fill out the resample table\n\t\t\t\treturnValue = t_HRTF_ResampleInterpolationMethod.emplace(orientation(newAzimuth, newElevation), std::forward<HRIR_struct>(interpolatedHRIR));\n\t\t\t\tif (returnValue.second) {\n          SET_RESULT(RESULT_OK, \"HRIR emplaced into Resample_HRTFTable_InterpolationMethod succesfully\");\n          // printf(\"HRIR emplaced into Resample_HRTFTable_InterpolationMethod succesfully\\n\");\n        }\n\t\t\t\telse\t\t\t\t\t{\n          SET_RESULT(RESULT_WARNING, \"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\");\n          // printf(\"Error emplacing HRIR into t_HRTF_ResampleInterpolationMethod map\\n\");\n        }\n\t\t\t}\n\t\t}\n\t}\n\tSET_RESULT(RESULT_OK, \"Resample_HRTFTable_InterpolationMethod has finished succesfully\");\n  printf(\"Resample_HRTFTable_InterpolationMethod has finished succesfully\\n\");\n  printf(\"Printing t_HRTF_ResampleInterpolationMethod contents:\\n\");\n  for (auto kv : t_HRTF_ResampleInterpolationMethod) {\n    // printf(\"(%i, %i) = (%llu [%u]), (%llu [%u])\\n\",\n    //   kv.first.azimuth, kv.first.elevation,\n    //   kv.second.leftDelay, kv.second.leftHRIR.size(),\n    //   kv.second.rightDelay, kv.second.rightHRIR.size());\n  }\n  printf(\"Printing t_HRTF_ResampleInterpolationMethod_frequency contents:\\n\");\n  bool hasPrinted = false;\n  for (auto kv : t_HRTF_ResampleInterpolationMethod_frequency) {\n    // printf(\"(%i, %i) = (%llu [%u]), (%llu [%u])\\n\",\n    //   kv.first.azimuth, kv.first.elevation,\n    //   kv.second.leftDelay, kv.second.leftHRIR.size(),\n    //   kv.second.rightDelay, kv.second.rightHRIR.size());\n\n    if (hasPrinted == false) {\n      printf(\"Printig leftHRIR samples:\\n\");\n      CMonoBuffer<float> buf = kv.second.leftHRIR;\n      for (int ok = 0; ok < buf.size(); ok++) {\n        printf(\"  %i = %f\\n\", ok, buf[ok]);\n      }\n      hasPrinted = true;\n    }\n  }\n}\n\n\n/* \\brief Calculate the HRIR of a specific orientation (newazimuth, newelevation) using the Barycentric interpolation Method\n*\t\\param newAzimuth azimuth of the orientation of interest (the one whose HRIR will be calculated)\n*\t\\param newElevation elevation of the orientation of interest (the one whose HRIR will be calculated)\n*/\nHRIR_struct CHRTF::CalculateHRIR_InterpolationMethod(int newAzimuth, int newElevation) {\n\n\tHRIR_struct newHRIR;\t// The interpolated HRIR\n\t// Get a list sorted by distances to the orientation of interest\n\tstd::list<Pair_DistanceOrientation_type> sortedList = GetSortedDistancesList(newAzimuth, newElevation);\n\n\tif (sortedList.size() != 0) {\n\t\t// Obtain  the valid Barycentric coordinates:\n\t\tbarycentricCoordinates_struct barycentricCoordinates;\n\t\tstd::vector<orientation> mygroup(sortedList.size());\n\t\tauto it = sortedList.begin();\n\t\tfor (int copy = 0; copy < sortedList.size(); copy++) {\n\t\t\tmygroup[copy] = it->second;\n\t\t\tit++;\n\t\t}\n\t\t//Algoritm to get a triangle around the orientation of interest\n\t\tfor (int groupSize = 3; groupSize < sortedList.size(); groupSize++)\n\t\t{\n\t\t\tfor (int i = 0; i < groupSize - 2; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < groupSize - 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = j + 1; k < groupSize; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Azimuth and elevation transformation in order to get the barientric coordinates (due to we are working with a spehere not a plane)\n\t\t\t\t\t\tfloat newAzimuthTransformed = TransformAzimuth(newAzimuth, newAzimuth);\n\t\t\t\t\t\tfloat iAzimuthTransformed = TransformAzimuth(newAzimuth, mygroup[i].azimuth);\n\t\t\t\t\t\tfloat jAzimuthTransformed = TransformAzimuth(newAzimuth, mygroup[j].azimuth);\n\t\t\t\t\t\tfloat kAzimuthTransformed = TransformAzimuth(newAzimuth, mygroup[k].azimuth);\n\t\t\t\t\t\tfloat newElevationTransformed = TransformElevation(newElevation, newElevation);\n\t\t\t\t\t\tfloat iElevationTransformed = TransformElevation(newElevation, mygroup[i].elevation);\n\t\t\t\t\t\tfloat jElevationTransformed = TransformElevation(newElevation, mygroup[j].elevation);\n\t\t\t\t\t\tfloat kElevationTransformed = TransformElevation(newElevation, mygroup[k].elevation);\n\n\t\t\t\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(newAzimuthTransformed, newElevationTransformed, iAzimuthTransformed, iElevationTransformed, jAzimuthTransformed, jElevationTransformed, kAzimuthTransformed, kElevationTransformed);\n\n\t\t\t\t\t\tif (barycentricCoordinates.alpha >= 0.0f && barycentricCoordinates.beta >= 0.0f && barycentricCoordinates.gamma >= 0.0f) {\n\t\t\t\t\t\t\t// Calculate the new HRIR with the barycentric coorfinates\n\t\t\t\t\t\t\tauto it0 = t_HRTF_DataBase.find(orientation(mygroup[i].azimuth, mygroup[i].elevation));\n\t\t\t\t\t\t\tauto it1 = t_HRTF_DataBase.find(orientation(mygroup[j].azimuth, mygroup[j].elevation));\n\t\t\t\t\t\t\tauto it2 = t_HRTF_DataBase.find(orientation(mygroup[k].azimuth, mygroup[k].elevation));\n\n\t\t\t\t\t\t\tif (it0 != t_HRTF_DataBase.end() && it1 != t_HRTF_DataBase.end() && it2 != t_HRTF_DataBase.end()) {\n\n\t\t\t\t\t\t\t\t//FIXME!!! another way to initialize?\n\t\t\t\t\t\t\t\tnewHRIR = it0->second;\n\t\t\t\t\t\t\t\t//END FIXME\n\n\t\t\t\t\t\t\t\tfor (int i = 0; i < HRIRlength; i++) {\n\t\t\t\t\t\t\t\t\tnewHRIR.leftHRIR[i] = barycentricCoordinates.alpha * it0->second.leftHRIR[i] + barycentricCoordinates.beta * it1->second.leftHRIR[i] + barycentricCoordinates.gamma * it2->second.leftHRIR[i];\n\t\t\t\t\t\t\t\t\tnewHRIR.rightHRIR[i] = barycentricCoordinates.alpha * it0->second.rightHRIR[i] + barycentricCoordinates.beta * it1->second.rightHRIR[i] + barycentricCoordinates.gamma * it2->second.rightHRIR[i];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Calculate delay\n\t\t\t\t\t\t\t\tnewHRIR.leftDelay = barycentricCoordinates.alpha * it0->second.leftDelay + barycentricCoordinates.beta * it1->second.leftDelay + barycentricCoordinates.gamma * it2->second.leftDelay;\n\t\t\t\t\t\t\t\tnewHRIR.rightDelay = barycentricCoordinates.alpha * it0->second.rightDelay + barycentricCoordinates.beta * it1->second.rightDelay + barycentricCoordinates.gamma * it2->second.rightDelay;\n\t\t\t\t\t\t\t\t//SET_RESULT(RESULT_OK, \"HRIR calculated with interpolation method succesfully\");\n\t\t\t\t\t\t\t\treturn newHRIR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tSET_RESULT(RESULT_WARNING, \"CalculateHRIR_InterpolationMethod return empty because HRIR with a specific orientation was not found\");\n\t\t\t\t\t\t\t\treturn emptyHRIR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSET_RESULT(RESULT_OK, \"\");\n\t}\n\telse {\n\t\tSET_RESULT(RESULT_ERROR_NOTSET, \"Orientation List sorted by distances in CalculateHRIR_InterpolationMethod is empty\");\n\t}\n\n\tSET_RESULT(RESULT_WARNING, \"CalculateHRIR_InterpolationMethod returns empty\");\n\treturn emptyHRIR;\n\n}\n\n/* \\brief Transform the orientation in order to move the orientation of interest to 180 degrees\n*   \\return transformed azimuth\n*/\nfloat CHRTF::TransformAzimuth(float azimuthOrientationOfInterest, float originalAzimuth) {\n\n\tfloat azimuth;\n\tazimuth = originalAzimuth + 180 - azimuthOrientationOfInterest;\n\n\t// Check limits (always return 0 instead of 360)\n\tif (azimuth >= 360)\n\t\tazimuth = fmod(azimuth, (float)360);\n\n\tif (azimuth < 0)\n\t\tazimuth = azimuth + 360;\n\n\treturn azimuth;\n}\n\n/* \\brief Transform the orientation in order to express the elevation in the interval [-90,90]\n*   \\return transformed elevation\n*/\nfloat CHRTF::TransformElevation(float elevationOrientationOfInterest, float originalElevation)\n{\n\tif (originalElevation >= 270) {\n\t\toriginalElevation = originalElevation - 360;\n\t}\n\treturn originalElevation;\n}\n\n\n/* \\brief Calculate the distance between the given orientation (newAzimuth, newElevation) and all other values of the databsde HRTF table. And store these values in a sorted list\n*   \\return the distances sorted list\n*/\nstd::list<Pair_DistanceOrientation_type> CHRTF::GetSortedDistancesList(int newAzimuth, int newElevation)\n{\n\tPair_DistanceOrientation_type temp;\n\tfloat distance;\n\tstd::list<Pair_DistanceOrientation_type> sortedList;\n\n\t// Algorithm to calculate the three shortest distances between the point (newAzimuth, newelevation) and all the points in the HRTF table (t)\n\tfor (auto it = t_HRTF_DataBase.begin(); it != t_HRTF_DataBase.end(); ++it)\n\t{\n\t\tdistance = HaversineFormula(newAzimuth, newElevation, it->first.azimuth, it->first.elevation);\n\n\t\ttemp.first = distance;\n\t\ttemp.second = it->first;\n\n\t\tsortedList.push_back(temp);\n\t}\n\n\tif (sortedList.size() != 0) {\n\t\tsortedList.sort([](const Pair_DistanceOrientation_type &a, const Pair_DistanceOrientation_type &b) { return a.first < b.first; });\n\t\t//SET_RESULT(RESULT_OK, \"Sorted distances list obtained succesfully\");\n\t}\n\telse {\n\t\tSET_RESULT(RESULT_WARNING, \"Orientation list sorted by distances is empty\");\n\t}\n\n\treturn sortedList;\n}\n\n\n/* \\brief Calculate the barycentric coordinates of three vertex [(x1,y1), (x2,y2), (x3,y3)] and the orientation of interest (x,y)\n*   \\return the distances sorted list\n*/\nconst barycentricCoordinates_struct CHRTF::GetBarycentricCoordinates(int x, int y, float x1, float y1, float x2, float y2, float x3, float y3)const\n{\n\t// Obtain Barycentric coordinates:\n\tbarycentricCoordinates_struct barycentricCoordinates;\n\n\tfloat denominator = (y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3);\n\n\tif (round(denominator) == 0) {\t//if denominator=0 -> no triangle -> barycentric coordinates NO VALID\n\t\t//SET_RESULT(RESULT_WARNING, \"Barycentric coordinates can be computed only on triangles\");\n\t\tbarycentricCoordinates.alpha = -1;\n\t\tbarycentricCoordinates.beta = -1;\n\t\tbarycentricCoordinates.gamma = -1;\n\t}\n\telse {\n\t\tbarycentricCoordinates.alpha = ((y2 - y3)*(x - x3) + (x3 - x2)*(y - y3)) / denominator;\n\t\tbarycentricCoordinates.alpha = trunc(1000 * barycentricCoordinates.alpha) / 1000;\n\t\tbarycentricCoordinates.beta = ((y3 - y1)*(x - x3) + (x1 - x3)*(y - y3)) / denominator;\n\t\tbarycentricCoordinates.beta = trunc(1000 * barycentricCoordinates.beta) / 1000;\n\t\tbarycentricCoordinates.gamma = 1.0f - barycentricCoordinates.alpha - barycentricCoordinates.beta;\n\t\tbarycentricCoordinates.gamma = trunc(1000 * barycentricCoordinates.gamma) / 1000;\n\t\t//SET_RESULT(RESULT_OK, \"Barycentric coordinates computed succesfully\");\n\t}\n\n\treturn barycentricCoordinates;\n}\n\n/* \\brief Calculate the distance between two points [(azimuth1, elevation1) and (azimuth2, elevation2)] using the Haversine formula\n*   \\return the distance value\n*/\nfloat CHRTF:: HaversineFormula(float azimuth1, float elevation1, float azimuth2, float elevation2 ) {\n\tfloat incremento_azimuth = azimuth1 - azimuth2;\n\tfloat incremento_elevacion = elevation1 - elevation2;\n\n\tfloat term1 = sin(incremento_elevacion / 2 * PI / 180.0);\n\tterm1 = term1 * term1;\n\tfloat term2 = cos(elevation1 * PI / 180.0);\n\tfloat term3 = cos(elevation2 * PI / 180.0);\n\tfloat term4 = sin(incremento_azimuth / 2 * PI / 180.0);\n\tterm4 = term4 * term4;\n\tfloat raiz = term1 + term2 * term3 * term4;\n\n\tASSERT(raiz > 0, RESULT_ERROR_OUTOFRANGE, \"Attempt to compute square root of a negative value using Haversine Formula to compute distance\", \"\");\n\tfloat sqrtDistance = sqrt(raiz);\n\n\t//ASSERT(sqrtDistance >= -1.0f && sqrtDistance <= 1.0f, RESULT_ERROR_OUTOFRANGE,\n\t//\t\t\"Attempt to compute arcsin of a value outside [-1..1] using Harvesine Formula to compute distnace\",\n\t//\t\t\"Distance computed succesfully with Haversine Formula\");\n\tASSERT(sqrtDistance >= -1.0f && sqrtDistance <= 1.0f, RESULT_ERROR_OUTOFRANGE,\n\t\t\"Attempt to compute arcsin of a value outside [-1..1] using Harvesine Formula to compute distnace\",\n\t\t\"\");\n\n\tfloat distance = asin(sqrt(raiz));\n\t//float distance = atan2(sqrt(raiz), sqrt(1 - raiz)); // The same result as the ASIN\n\n\treturn distance;\n}\n\nconst unsigned long CHRTF::GetCustomizedDelay(float _azimuth, float _elevation, T_ear ear)  const{\n\t//TODO: TEMP ********************\n\tfloat sampleRate = 44100;\n\t//***********************************\n\n\tfloat rAzimuth = _azimuth * PI / 180;\n\tfloat rElevation = _elevation * PI / 180;\n\n\t//Calculate the customized delay\n\tunsigned long customizedDelay = 0;\n\tfloat interauralAzimuth = asin(sin(rAzimuth) * cos(rElevation));\n\n\tfloat ITD = CalculateITDFromHeadRadius(listenerHeadRadius, interauralAzimuth);\n\n\tif ((ITD > 0 && ear == RIGHT) || (ITD < 0 && ear == LEFT)) {\n\t\tcustomizedDelay = static_cast <unsigned long> (round(abs(sampleRate * ITD)));\n\t}\n\treturn customizedDelay;\n}\n\n\n\n//***************************************************************************************************************************************************************************\n//   Method called from GET Interfaces to do the interpolation, in run time     ********************************************************************************************\n//***************************************************************************************************************************************************************************\n\n\nconst oneEarHRIR_struct CHRTF::CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(T_ear ear, int azimuth, int elevation) const\n{\n\toneEarHRIR_struct newHRIR;\n\tbarycentricCoordinates_struct barycentricCoordinates;\n\torientation orientation_ptoA, orientation_ptoB, orientation_ptoC, orientation_ptoD, orientation_ptoP;\n\n\t//Calculate the quadrant points A, B, C and D and the middle quadrant point P\n\torientation_ptoC.azimuth = trunc(azimuth / resampleStep) * resampleStep;\n\torientation_ptoC.elevation = trunc(elevation / resampleStep)*resampleStep;\n\torientation_ptoA.azimuth = orientation_ptoC.azimuth;\n\torientation_ptoA.elevation = orientation_ptoC.elevation + resampleStep;\n\torientation_ptoB.azimuth = orientation_ptoC.azimuth + resampleStep;\n\torientation_ptoB.elevation = orientation_ptoC.elevation + resampleStep;\n\torientation_ptoD.azimuth = orientation_ptoC.azimuth + resampleStep;\n\torientation_ptoD.elevation = orientation_ptoC.elevation;\n\torientation_ptoP.azimuth = orientation_ptoC.azimuth + (resampleStep * 0.5f);\n\tfloat azimuth_ptoP = orientation_ptoC.azimuth + (resampleStep * 0.5f);\n\tfloat elevation_ptoP = orientation_ptoC.elevation + (resampleStep * 0.5f);\n\n\t//Depend on the quadrant where the point of interest is situated obtain the Barycentric coordinates and the HRIR of the orientation of interest (azimuth, elevation)\n\tif (azimuth >= azimuth_ptoP)\n\t{\n\t\tif (elevation >= elevation_ptoP)\n\t\t{\n\t\t\t//Second quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoA.azimuth, orientation_ptoA.elevation, orientation_ptoB.azimuth, orientation_ptoB.elevation, orientation_ptoD.azimuth, orientation_ptoD.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoA, orientation_ptoB, orientation_ptoD);\n\t\t}\n\t\telse if (elevation < elevation_ptoP)\n\t\t{\n\t\t\t//Forth quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoB.azimuth, orientation_ptoB.elevation, orientation_ptoC.azimuth, orientation_ptoC.elevation, orientation_ptoD.azimuth, orientation_ptoD.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoB, orientation_ptoC, orientation_ptoD);\n\t\t}\n\t}\n\telse if (azimuth < azimuth_ptoP)\n\t{\n\t\tif (elevation >= elevation_ptoP)\n\t\t{\n\t\t\t//First quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoA.azimuth, orientation_ptoA.elevation, orientation_ptoB.azimuth, orientation_ptoB.elevation, orientation_ptoC.azimuth, orientation_ptoC.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoA, orientation_ptoB, orientation_ptoC);\n\t\t}\n\t\telse if (elevation < elevation_ptoP) {\n\t\t\t//Third quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoA.azimuth, orientation_ptoA.elevation, orientation_ptoC.azimuth, orientation_ptoC.elevation, orientation_ptoD.azimuth, orientation_ptoD.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoA, orientation_ptoC, orientation_ptoD);\n\t\t}\n\t}\n\n\t//SET_RESULT(RESULT_OK, \"CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable completed succesfully\");\n\treturn newHRIR;\n\n}\n\nconst oneEarHRIR_struct CHRTF::CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable(T_ear ear, int azimuth, int elevation, bool freq) const\n{\n\toneEarHRIR_struct newHRIR;\n\tbarycentricCoordinates_struct barycentricCoordinates;\n\torientation orientation_ptoA, orientation_ptoB, orientation_ptoC, orientation_ptoD, orientation_ptoP;\n\n\t//Calculate the quadrant points A, B, C and D and the middle quadrant point P\n\torientation_ptoC.azimuth = trunc(azimuth / resampleStep) * resampleStep;\n\torientation_ptoC.elevation = trunc(elevation / resampleStep)*resampleStep;\n\torientation_ptoA.azimuth = orientation_ptoC.azimuth;\n\torientation_ptoA.elevation = orientation_ptoC.elevation + resampleStep;\n\torientation_ptoB.azimuth = orientation_ptoC.azimuth + resampleStep;\n\torientation_ptoB.elevation = orientation_ptoC.elevation + resampleStep;\n\torientation_ptoD.azimuth = orientation_ptoC.azimuth + resampleStep;\n\torientation_ptoD.elevation = orientation_ptoC.elevation;\n\torientation_ptoP.azimuth = orientation_ptoC.azimuth + (resampleStep * 0.5f);\n\tfloat azimuth_ptoP = orientation_ptoC.azimuth + (resampleStep * 0.5f);\n\tfloat elevation_ptoP = orientation_ptoC.elevation + (resampleStep * 0.5f);\n\n\t//Depend on the quadrant where the point of interest is situated obtain the Barycentric coordinates and the HRIR of the orientation of interest (azimuth, elevation)\n\tif (azimuth >= azimuth_ptoP)\n\t{\n\t\tif (elevation >= elevation_ptoP)\n\t\t{\n\t\t\t//Second quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoA.azimuth, orientation_ptoA.elevation, orientation_ptoB.azimuth, orientation_ptoB.elevation, orientation_ptoD.azimuth, orientation_ptoD.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoA, orientation_ptoB, orientation_ptoD, freq);\n\t\t}\n\t\telse if (elevation < elevation_ptoP)\n\t\t{\n\t\t\t//Forth quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoB.azimuth, orientation_ptoB.elevation, orientation_ptoC.azimuth, orientation_ptoC.elevation, orientation_ptoD.azimuth, orientation_ptoD.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoB, orientation_ptoC, orientation_ptoD, freq);\n\t\t}\n\t}\n\telse if (azimuth < azimuth_ptoP)\n\t{\n\t\tif (elevation >= elevation_ptoP)\n\t\t{\n\t\t\t//First quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoA.azimuth, orientation_ptoA.elevation, orientation_ptoB.azimuth, orientation_ptoB.elevation, orientation_ptoC.azimuth, orientation_ptoC.elevation);\n      printf(\"barycentricCoordinates.alpha = %f\\n\", barycentricCoordinates.alpha);\n      printf(\"barycentricCoordinates.beta = %f\\n\", barycentricCoordinates.beta);\n      printf(\"barycentricCoordinates.gamma = %f\\n\", barycentricCoordinates.gamma);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoA, orientation_ptoB, orientation_ptoC, freq);\n\t\t}\n\t\telse if (elevation < elevation_ptoP) {\n\t\t\t//Third quadrant\n\t\t\tbarycentricCoordinates = GetBarycentricCoordinates(azimuth, elevation, orientation_ptoA.azimuth, orientation_ptoA.elevation, orientation_ptoC.azimuth, orientation_ptoC.elevation, orientation_ptoD.azimuth, orientation_ptoD.elevation);\n\t\t\tnewHRIR = CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(ear, barycentricCoordinates, orientation_ptoA, orientation_ptoC, orientation_ptoD, freq);\n\t\t}\n\t}\n\n\t//SET_RESULT(RESULT_OK, \"CalculateHRIR_QuadrantInterpolation_InterpolatedResampleTable completed succesfully\");\n\treturn newHRIR;\n\n}\n\nconst oneEarHRIR_struct CHRTF::CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(T_ear ear, barycentricCoordinates_struct barycentricCoordinates, orientation orientation_pto1, orientation orientation_pto2, orientation orientation_pto3)const\n{\n\toneEarHRIR_struct newHRIR;\n\tint size = HRIRlength;\n\n\tif (barycentricCoordinates.alpha >= 0.0f && barycentricCoordinates.beta >= 0.0f && barycentricCoordinates.gamma >= 0.0f) {\n\n\t\t// Get the table iterator of the triangle points\n\n\t\t//FIXME!!\n\t\tif (orientation_pto1.azimuth == 360) { orientation_pto1.azimuth = 0; }\n\t\tif (orientation_pto2.azimuth == 360) { orientation_pto2.azimuth = 0; }\n\t\tif (orientation_pto3.azimuth == 360) { orientation_pto3.azimuth = 0; }\n\t\tif (orientation_pto1.elevation == 360) { orientation_pto1.elevation = 0; }\n\t\tif (orientation_pto2.elevation == 360) { orientation_pto2.elevation = 0; }\n\t\tif (orientation_pto3.elevation == 360) { orientation_pto3.elevation = 0; }\n\t\t//END FIXME\n\n\t\t// Find the HRIR for the specific orientations\n\t\tauto it1 = t_HRTF_ResampleInterpolationMethod.find(orientation(orientation_pto1.azimuth, orientation_pto1.elevation));\n\t\tauto it2 = t_HRTF_ResampleInterpolationMethod.find(orientation(orientation_pto2.azimuth, orientation_pto2.elevation));\n\t\tauto it3 = t_HRTF_ResampleInterpolationMethod.find(orientation(orientation_pto3.azimuth, orientation_pto3.elevation));\n\n\t\tif (it1 != t_HRTF_ResampleInterpolationMethod.end() && it2 != t_HRTF_ResampleInterpolationMethod.end() && it3 != t_HRTF_ResampleInterpolationMethod.end()) {\n\n\t\t\tif (ear == LEFT) {\n\t\t\t\t//Calculate the left ear HRIR\n\t\t\t\tnewHRIR.HRIR = it1->second.leftHRIR; //Initialize variable //FIXME!!\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tnewHRIR.HRIR[i] = barycentricCoordinates.alpha * it1->second.leftHRIR[i] + barycentricCoordinates.beta * it2->second.leftHRIR[i] + barycentricCoordinates.gamma * it3->second.leftHRIR[i];\n\t\t\t\t}\n\t\t\t\t// Calculate left ear delay\n\t\t\t\tnewHRIR.delay = static_cast <unsigned long> (round(barycentricCoordinates.alpha * it1->second.leftDelay + barycentricCoordinates.beta * it2->second.leftDelay + barycentricCoordinates.gamma * it3->second.leftDelay));\n\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t}\n\n\t\t\telse if (ear == RIGHT) {\n\t\t\t\t//Calculate the right ear HRIR\n\t\t\t\tnewHRIR.HRIR = it1->second.rightHRIR; //Initialize variable\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tnewHRIR.HRIR[i] = barycentricCoordinates.alpha * it1->second.rightHRIR[i] + barycentricCoordinates.beta * it2->second.rightHRIR[i] + barycentricCoordinates.gamma * it3->second.rightHRIR[i];\n\t\t\t\t}\n\t\t\t\t// Calculate right ear delay\n\t\t\t\tnewHRIR.delay = static_cast <unsigned long> (round(barycentricCoordinates.alpha * it1->second.rightDelay + barycentricCoordinates.beta * it2->second.rightDelay + barycentricCoordinates.gamma * it3->second.rightDelay));\n\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tSET_RESULT(RESULT_WARNING, \"Ear Type for calculating HRIR from Barycentric Coordinates is not valid\");\n\t\t\t}\n\n\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t}\n\t\telse {\n\t\t\tSET_RESULT(RESULT_WARNING, \"Orientations in CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable not found\");\n\n\t\t}\n\n\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t}\n\telse {\n\t\tSET_RESULT(RESULT_WARNING, \"No Barycentric coordinates Triangle in CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable\");\n\t}\n\n\treturn newHRIR;\n}\n\nconst oneEarHRIR_struct CHRTF::CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable(T_ear ear, barycentricCoordinates_struct barycentricCoordinates, orientation orientation_pto1, orientation orientation_pto2, orientation orientation_pto3, bool freq)const\n{\n\toneEarHRIR_struct newHRIR;\n\tint size = HRIRlength;\n\n  printf(\"table size is %s \\n\", t_HRTF_ResampleInterpolationMethod_frequency.size());\n\n\tif (barycentricCoordinates.alpha >= 0.0f && barycentricCoordinates.beta >= 0.0f && barycentricCoordinates.gamma >= 0.0f) {\n\n\t\t// Get the table iterator of the triangle points\n\n\t\t//FIXME!!\n\t\tif (orientation_pto1.azimuth == 360) { orientation_pto1.azimuth = 0; }\n\t\tif (orientation_pto2.azimuth == 360) { orientation_pto2.azimuth = 0; }\n\t\tif (orientation_pto3.azimuth == 360) { orientation_pto3.azimuth = 0; }\n\t\tif (orientation_pto1.elevation == 360) { orientation_pto1.elevation = 0; }\n\t\tif (orientation_pto2.elevation == 360) { orientation_pto2.elevation = 0; }\n\t\tif (orientation_pto3.elevation == 360) { orientation_pto3.elevation = 0; }\n\t\t//END FIXME\n\n\t\tif (freq) {\n\t\t\t// Find the HRIR for the specific orientations\n\t\t\tauto it1 = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(orientation_pto1.azimuth, orientation_pto1.elevation));\n\t\t\tauto it2 = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(orientation_pto2.azimuth, orientation_pto2.elevation));\n\t\t\tauto it3 = t_HRTF_ResampleInterpolationMethod_frequency.find(orientation(orientation_pto3.azimuth, orientation_pto3.elevation));\n\n\t\t\tif (it1 != t_HRTF_ResampleInterpolationMethod_frequency.end() && it2 != t_HRTF_ResampleInterpolationMethod_frequency.end() && it3 != t_HRTF_ResampleInterpolationMethod_frequency.end())\n\t\t\t{\n\t\t\t\tif (ear == LEFT) {\n\t\t\t\t\t//Calculate the left ear HRIR\n\t\t\t\t\tnewHRIR.HRIR = it1->second.leftHRIR; //Initialize variable //FIXME!!\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tnewHRIR.HRIR[i] = barycentricCoordinates.alpha * it1->second.leftHRIR[i] + barycentricCoordinates.beta * it2->second.leftHRIR[i] + barycentricCoordinates.gamma * it3->second.leftHRIR[i];\n\t\t\t\t\t}\n\t\t\t\t\t// Calculate left ear delay\n\t\t\t\t\tnewHRIR.delay = static_cast <unsigned long> (round(barycentricCoordinates.alpha * it1->second.leftDelay + barycentricCoordinates.beta * it2->second.leftDelay + barycentricCoordinates.gamma * it3->second.leftDelay));\n\t\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t\t}\n\n\t\t\t\telse if (ear == RIGHT) {\n\t\t\t\t\t//Calculate the right ear HRIR\n\t\t\t\t\tnewHRIR.HRIR = it1->second.rightHRIR; //Initialize variable\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tnewHRIR.HRIR[i] = barycentricCoordinates.alpha * it1->second.rightHRIR[i] + barycentricCoordinates.beta * it2->second.rightHRIR[i] + barycentricCoordinates.gamma * it3->second.rightHRIR[i];\n\t\t\t\t\t}\n\t\t\t\t\t// Calculate right ear delay\n\t\t\t\t\tnewHRIR.delay = static_cast <unsigned long> (round(barycentricCoordinates.alpha * it1->second.rightDelay + barycentricCoordinates.beta * it2->second.rightDelay + barycentricCoordinates.gamma * it3->second.rightDelay));\n\t\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tSET_RESULT(RESULT_WARNING, \"Ear Type for calculating HRIR from Barycentric Coordinates is not valid\");\n\t\t\t\t}\n\n\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSET_RESULT(RESULT_WARNING, \"Orientations in CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable not found\");\n\n\t\t\t}\n\t\t}\n\t\t//NO Freq\n\t\telse {\n\t\t\t// Find the HRIR for the specific orientations\n\t\t\tauto it1 = t_HRTF_ResampleInterpolationMethod.find(orientation(orientation_pto1.azimuth, orientation_pto1.elevation));\n\t\t\tauto it2 = t_HRTF_ResampleInterpolationMethod.find(orientation(orientation_pto2.azimuth, orientation_pto2.elevation));\n\t\t\tauto it3 = t_HRTF_ResampleInterpolationMethod.find(orientation(orientation_pto3.azimuth, orientation_pto3.elevation));\n\n\t\t\tif (it1 != t_HRTF_ResampleInterpolationMethod.end() && it2 != t_HRTF_ResampleInterpolationMethod.end() && it3 != t_HRTF_ResampleInterpolationMethod.end())\n\t\t\t{\n\t\t\t\tif (ear == LEFT) {\n\t\t\t\t\t//Calculate the left ear HRIR\n\t\t\t\t\tnewHRIR.HRIR = it1->second.leftHRIR; //Initialize variable //FIXME!!\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tnewHRIR.HRIR[i] = barycentricCoordinates.alpha * it1->second.leftHRIR[i] + barycentricCoordinates.beta * it2->second.leftHRIR[i] + barycentricCoordinates.gamma * it3->second.leftHRIR[i];\n\t\t\t\t\t}\n\t\t\t\t\t// Calculate left ear delay\n\t\t\t\t\tnewHRIR.delay = static_cast <unsigned long> (round(barycentricCoordinates.alpha * it1->second.leftDelay + barycentricCoordinates.beta * it2->second.leftDelay + barycentricCoordinates.gamma * it3->second.leftDelay));\n\t\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t\t}\n\n\t\t\t\telse if (ear == RIGHT) {\n\t\t\t\t\t//Calculate the right ear HRIR\n\t\t\t\t\tnewHRIR.HRIR = it1->second.rightHRIR; //Initialize variable\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tnewHRIR.HRIR[i] = barycentricCoordinates.alpha * it1->second.rightHRIR[i] + barycentricCoordinates.beta * it2->second.rightHRIR[i] + barycentricCoordinates.gamma * it3->second.rightHRIR[i];\n\t\t\t\t\t}\n\t\t\t\t\t// Calculate right ear delay\n\t\t\t\t\tnewHRIR.delay = static_cast <unsigned long> (round(barycentricCoordinates.alpha * it1->second.rightDelay + barycentricCoordinates.beta * it2->second.rightDelay + barycentricCoordinates.gamma * it3->second.rightDelay));\n\t\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tSET_RESULT(RESULT_WARNING, \"Ear Type for calculating HRIR from Barycentric Coordinates is not valid\");\n\t\t\t\t}\n\n\t\t\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSET_RESULT(RESULT_WARNING, \"Orientations in CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable not found\");\n\n\t\t\t}\n\n\n\n\t\t}\n\n\t\t//SET_RESULT(RESULT_OK, \"CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable completed succesfully\");\n\t}\n\telse {\n\t\tSET_RESULT(RESULT_WARNING, \"No Barycentric coordinates Triangle in CalculateHRIRFromBarycentricCoordinates_InterpolatedResampleTable\");\n\t}\n\n\treturn newHRIR;\n}\n\n\n\n\n//***************************************************************************************************************************************************************************\n//   ITD Methods    ********************************************************************************************\n//***************************************************************************************************************************************************************************\n\n/* \\brief Add the delay to the HRIR function\n*\t\\param ear, enum that indicates the listener ear {LEFT, RIGHT}\n*\t\\param HRIR, HRIR function and delay separately\n*\t\\param _azimuth, source polar azimuth\n*\t\\param _elevation, source polar elevation\n*   \\return HRIR function with delay incorporated\n*/\nconst CMonoBuffer<float> CHRTF::AddDelayToHRIR(T_ear ear, oneEarHRIR_struct HRIR, float _azimuth, float _elevation)const {\n\n\t//TODO: TEMP ********************\n\tfloat sampleRate = 44100;\n\t//***********************************\n\n\tfloat rAzimuth = _azimuth * PI / 180;\n\tfloat rElevation = _elevation * PI / 180;\n\n\t//Copy the HRIR function\n\tCMonoBuffer<float> HRIR_withDelay = HRIR.HRIR;\n\n\tif (enableCustomizedITD)\n\t{\n\t\t//Calculate the customized delay\n\t\tunsigned long customizedDelay = 0;\n\t\tfloat interauralAzimuth = asin(sin(rAzimuth) * cos(rElevation));\n\t\tfloat ITD = CalculateITDFromHeadRadius(listenerHeadRadius, interauralAzimuth);\n\n\t\tif ((ITD > 0 && ear == RIGHT)  || (ITD < 0 && ear == LEFT)) {\n\t\t\tcustomizedDelay =  static_cast <unsigned long> (round(abs(sampleRate * ITD)));\n\t\t}\n\t\t//else { customizedDelay = 0; }\n\n\t\t// Calculate the delay samples vector (vector with zero values and 'delay' size)\n\t\tstd::vector<double> vectorDelay(customizedDelay, 0.0f);\n\t\t// Add the delay vector at the begin of the HRIR function\n\t\tHRIR_withDelay.insert(HRIR_withDelay.begin(), vectorDelay.begin(), vectorDelay.end());\n\t}\n\telse {\n\n\t\t// Calculate the delay samples vector (vector with zero values and 'delay' size)\n\t\tstd::vector<double> vectorDelay(HRIR.delay, 0.0f);\n\t\t// Add the delay vector at the begin of the HRIR function\n\t\tHRIR_withDelay.insert(HRIR_withDelay.begin(), vectorDelay.begin(), vectorDelay.end());\n\t}\n\n\t// Take only HRIRlenght samples\n\t//TODO: find an optimized way to split a vector\n\tCMonoBuffer<float> split_HRIR_withDelay(HRIR_withDelay.begin(), HRIR_withDelay.begin() + HRIRlength);\n\n\tSET_RESULT(RESULT_OK, \"Delay added to HRIR succesfully\");\n\n\treturn split_HRIR_withDelay;\n}\n\n\n/*  \\brief Calculate and Delete the common delay of every HRIR functions of the DataBase Table. Off line Method, called from EndSetUp()\n*   \\return the common delay for left and right ears\n*/\nvoid CHRTF::DeleteCommonDelay_HRTFDataBaseTable()\n{\n\t//1. Init the minumun value with the fist value of the table\n\tauto it0 = t_HRTF_DataBase.begin();\n\tunsigned long minimumDelayLeft = it0->second.leftDelay;\t\t//Vrbl to store the minumun delay value for left ear\n\tunsigned long minimumDelayRight = it0->second.rightDelay;\t//Vrbl to store the minumun delay value for right ear\n\n\t//2. Find the common delay\n\t//Scan the whole table looking for the minimum delay for left and right ears\n\tfor (auto it = t_HRTF_DataBase.begin(); it != t_HRTF_DataBase.end(); it++) {\n\t\t//Left ear\n\t\tif (it->second.leftDelay < minimumDelayLeft) {\n\t\t\tminimumDelayLeft = it->second.leftDelay;\n\t\t}\n\t\t//Right ear\n\t\tif (it->second.rightDelay < minimumDelayRight) {\n\t\t\tminimumDelayRight = it->second.rightDelay;\n\t\t}\n\t}\n\n\t//3. Delete the common delay\n\t//Scan the whole table substracting the common delay to every delays for both ears\n\tfor (auto it = t_HRTF_DataBase.begin(); it != t_HRTF_DataBase.end(); it++)\n\t{\n\t\tit->second.leftDelay = it->second.leftDelay - minimumDelayLeft;\t\t//Left ear\n\t\tit->second.rightDelay = it->second.rightDelay - minimumDelayRight;\t//Right ear\n\t}\n\n\tSET_RESULT(RESULT_OK, \"Common delay deleted from HRTF table succesfully\");\n}\n\n\n/* \\brief Set the radious of the listener head, which is configured in the App, read by the core and set by the core\n*\t\\param _listenerHeadRadious, radious of the listener head\n*/\nvoid CHRTF::SetListenerHeadRadius(float _listenerHeadRadius) {\n\tlistenerHeadRadius = _listenerHeadRadius;\n}\n\n/* \\brief Allow to calculate and add to the HRIR a customized delay\n*   IMPORTANT NOTE: The customized ITD can be enable if the HRIR function do not contain the delay.\n*\t\\param _enableCustomizeITD, true if the HRTF will use the customized delay\n*/\nvoid CHRTF::SetHRTFCustomizedITD(bool _enableCustomizeITD) {\n\tenableCustomizedITD = _enableCustomizeITD;\n}\n\n\n/*  \\brief Calculate the ITD using the Lord Rayleight formula which depend on the interaural azimuth and the listener head radious\n*\t\\param _headRadious, listener head radius, set by the App\n*   \\param  _interauralAzimuth, source interaural azimuth\n*   \\return customizated ITD\n*/\nconst float CHRTF::CalculateITDFromHeadRadius(float _headRadius, float _interauralAzimuth) const\n{\n\t//Calculate the ITD (from https://www.lpi.tel.uva.es/~nacho/docencia/ing_ond_1/trabajos_05_06/io5/public_html/ & http://interface.cipic.ucdavis.edu/sound/tutorial/psych.html)\n\tfloat ITD = _headRadius * (_interauralAzimuth + sin(_interauralAzimuth)) / 343.0f; //ownerCore->GetMagnitudes().GetSoundSpeed(); //_azimuth in radians!\n\treturn ITD;\n}\n\n\n","// -*- C++ -*-\n//===---------------------------- list ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIST\n#define _LIBCPP_LIST\n\n/*\n    list synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\npublic:\n\n    // types:\n    typedef T value_type;\n    typedef Alloc allocator_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef implementation-defined size_type;\n    typedef implementation-defined difference_type;\n    typedef reverse_iterator<iterator> reverse_iterator;\n    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n\n    list()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit list(const allocator_type& a);\n    explicit list(size_type n);\n    explicit list(size_type n, const allocator_type& a); // C++14\n    list(size_type n, const value_type& value);\n    list(size_type n, const value_type& value, const allocator_type& a);\n    template <class Iter>\n        list(Iter first, Iter last);\n    template <class Iter>\n        list(Iter first, Iter last, const allocator_type& a);\n    list(const list& x);\n    list(const list&, const allocator_type& a);\n    list(list&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    list(list&&, const allocator_type& a);\n    list(initializer_list<value_type>);\n    list(initializer_list<value_type>, const allocator_type& a);\n\n    ~list();\n\n    list& operator=(const list& x);\n    list& operator=(list&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    list& operator=(initializer_list<value_type>);\n    template <class Iter>\n        void assign(Iter first, Iter last);\n    void assign(size_type n, const value_type& t);\n    void assign(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    bool empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    template <class... Args>\n        void emplace_front(Args&&... args);\n    void pop_front();\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n    void push_front(const value_type& x);\n    void push_front(value_type&& x);\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class Iter>\n        iterator insert(const_iterator position, Iter first, Iter last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator position, const_iterator last);\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(list&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void clear() noexcept;\n\n    void splice(const_iterator position, list& x);\n    void splice(const_iterator position, list&& x);\n    void splice(const_iterator position, list& x, const_iterator i);\n    void splice(const_iterator position, list&& x, const_iterator i);\n    void splice(const_iterator position, list& x, const_iterator first,\n                                                  const_iterator last);\n    void splice(const_iterator position, list&& x, const_iterator first,\n                                                  const_iterator last);\n\n    void remove(const value_type& value);\n    template <class Pred> void remove_if(Pred pred);\n    void unique();\n    template <class BinaryPredicate>\n        void unique(BinaryPredicate binary_pred);\n    void merge(list& x);\n    void merge(list&& x);\n    template <class Compare>\n        void merge(list& x, Compare comp);\n    template <class Compare>\n        void merge(list&& x, Compare comp);\n    void sort();\n    template <class Compare>\n        void sort(Compare comp);\n    void reverse() noexcept;\n};\n\ntemplate <class T, class Alloc>\n    bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator< (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator!=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator> (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator>=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator<=(const list<T,Alloc>& x, const list<T,Alloc>& y);\n\ntemplate <class T, class Alloc>\n    void swap(list<T,Alloc>& x, list<T,Alloc>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n\n#include <memory>\n#include <limits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _VoidPtr> struct __list_node;\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node_base\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other pointer;\n#endif\n\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node_base> __base_pointer;\n#else\n        rebind<__list_node_base>::other __base_pointer;\n#endif\n\n    pointer __prev_;\n    pointer __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_node_base() : __prev_(__self()), __next_(__self()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __self()\n    {\n        return static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this));\n    }\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node\n    : public __list_node_base<_Tp, _VoidPtr>\n{\n    _Tp __value_;\n};\n\ntemplate <class _Tp, class _Alloc> class _LIBCPP_TYPE_VIS_ONLY list;\ntemplate <class _Tp, class _Alloc> class __list_imp;\ntemplate <class _Tp, class _VoidPtr> class _LIBCPP_TYPE_VIS_ONLY __list_const_iterator;\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\n    template<class, class> friend class __list_const_iterator;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef value_type&                      reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator(const __list_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator=(const __list_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_iterator& __x, const __list_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_const_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__p);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_const_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator=(const __list_const_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::const_iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _Alloc>\nclass __list_imp\n{\n    __list_imp(const __list_imp&);\n    __list_imp& operator=(const __list_imp&);\nprotected:\n    typedef _Tp                                                     value_type;\n    typedef _Alloc                                                  allocator_type;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n    typedef typename __alloc_traits::size_type                      size_type;\n    typedef typename __alloc_traits::void_pointer                   __void_pointer;\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\n    typedef __list_const_iterator<value_type, __void_pointer>       const_iterator;\n    typedef __list_node_base<value_type, __void_pointer>            __node_base;\n    typedef __list_node<value_type, __void_pointer>                 __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node>\n#else\n                rebind_alloc<__node>::other\n#endif\n                                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>                       __node_alloc_traits;\n    typedef typename __node_alloc_traits::pointer                    __node_pointer;\n    typedef typename __node_alloc_traits::pointer                    __node_const_pointer;\n    typedef typename __alloc_traits::pointer                         pointer;\n    typedef typename __alloc_traits::const_pointer                   const_pointer;\n    typedef typename __alloc_traits::difference_type                 difference_type;\n\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node_base>\n#else\n                rebind_alloc<__node_base>::other\n#endif\n                                                                     __node_base_allocator;\n    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;\n\n    __node_base __end_;\n    __compressed_pair<size_type, __node_allocator> __size_alloc_;\n\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& __sz() _NOEXCEPT {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __sz() const _NOEXCEPT\n        {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT\n          {return __size_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __size_alloc_.second();}\n\n    static void __unlink_nodes(__node_pointer __f, __node_pointer __l) _NOEXCEPT;\n\n    __list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value);\n    __list_imp(const allocator_type& __a);\n    ~__list_imp();\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __sz() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const  _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(__end_.__next_, this);\n#else\n        return const_iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__node_pointer>(\n                pointer_traits<__node_base_pointer>::pointer_to(__end_)), this);\n#else\n        return iterator(static_cast<__node_pointer>(\n                      pointer_traits<__node_base_pointer>::pointer_to(__end_)));\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))), this);\n#else\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))));\n#endif\n    }\n\n    void swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c)\n        _NOEXCEPT_(\n            !__node_alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, true_type)\n        {\n            if (__node_alloc() != __c.__node_alloc())\n                clear();\n            __node_alloc() = __c.__node_alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {\n            __node_alloc() = _VSTD::move(__c.__node_alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, false_type)\n        _NOEXCEPT\n        {}\n};\n\n// Unlink nodes [__f, __l]\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__list_imp<_Tp, _Alloc>::__unlink_nodes(__node_pointer __f, __node_pointer __l)\n    _NOEXCEPT\n{\n    __f->__prev_->__next_ = __l->__next_;\n    __l->__next_->__prev_ = __f->__prev_;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    : __size_alloc_(0)\n{\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)\n    : __size_alloc_(0, __node_allocator(__a))\n{\n}\n\ntemplate <class _Tp, class _Alloc>\n__list_imp<_Tp, _Alloc>::~__list_imp()\n{\n    clear();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::clear() _NOEXCEPT\n{\n    if (!empty())\n    {\n        __node_allocator& __na = __node_alloc();\n        __node_pointer __f = __end_.__next_;\n        __node_pointer __l = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n        __unlink_nodes(__f, __l->__prev_);\n        __sz() = 0;\n        while (__f != __l)\n        {\n            __node_pointer __n = __f;\n            __f = __f->__next_;\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != __l)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __c.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    using _VSTD::swap;\n    __swap_alloc(__node_alloc(), __c.__node_alloc());\n    swap(__sz(), __c.__sz());\n    swap(__end_, __c.__end_);\n    if (__sz() == 0)\n        __end_.__next_ = __end_.__prev_ = __end_.__self();\n    else\n        __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_.__self();\n    if (__c.__sz() == 0)\n        __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_.__self();\n    else\n        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_.__self();\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __libcpp_db* __db = __get_db();\n    __c_node* __cn1 = __db->__find_c_and_lock(this);\n    __c_node* __cn2 = __db->__find_c(&__c);\n    std::swap(__cn1->beg_, __cn2->beg_);\n    std::swap(__cn1->end_, __cn2->end_);\n    std::swap(__cn1->cap_, __cn2->cap_);\n    for (__i_node** __p = __cn1->end_; __p != __cn1->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n        {\n            __cn2->__add(*__p);\n            if (--__cn1->end_ != __p)\n                memmove(__p, __p+1, (__cn1->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn1;\n    }\n    for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_)))\n        {\n            __cn1->__add(*__p);\n            if (--__cn2->end_ != __p)\n                memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn2;\n    }\n    __db->unlock();\n#endif\n}\n\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY list\n    : private __list_imp<_Tp, _Alloc>\n{\n    typedef __list_imp<_Tp, _Alloc> base;\n    typedef typename base::__node              __node;\n    typedef typename base::__node_allocator    __node_allocator;\n    typedef typename base::__node_pointer      __node_pointer;\n    typedef typename base::__node_alloc_traits __node_alloc_traits;\n    typedef typename base::__node_base         __node_base;\n    typedef typename base::__node_base_pointer __node_base_pointer;\n\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Alloc                                   allocator_type;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename base::pointer                   pointer;\n    typedef typename base::const_pointer             const_pointer;\n    typedef typename base::size_type                 size_type;\n    typedef typename base::difference_type           difference_type;\n    typedef typename base::iterator                  iterator;\n    typedef typename base::const_iterator            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    list()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    explicit list(const allocator_type& __a) : base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit list(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit list(size_type __n, const allocator_type& __a);\n#endif\n    list(size_type __n, const value_type& __x);\n    list(size_type __n, const value_type& __x, const allocator_type& __a);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n\n    list(const list& __c);\n    list(const list& __c, const allocator_type& __a);\n    list& operator=(const list& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    list(initializer_list<value_type> __il);\n    list(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    list(list&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value);\n    list(list&& __c, const allocator_type& __a);\n    list& operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    list& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InpIter>\n        void assign(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT     {return base::__sz();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT         {return base::empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return numeric_limits<difference_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT        {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT          {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    reference back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n       void emplace_front(_Args&&... __args);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n    template <class... _Args>\n        iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    iterator insert(const_iterator __p, value_type&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void push_front(const value_type& __x);\n    void push_back(const value_type& __x);\n\n    iterator insert(const_iterator __p, const value_type& __x);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __x);\n    template <class _InpIter>\n        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(list& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {base::swap(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {base::clear();}\n\n    void pop_front();\n    void pop_back();\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __x);\n\n    void splice(const_iterator __p, list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}\n#endif\n    void splice(const_iterator __p, list& __c, const_iterator __i);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __i)\n        {splice(__p, __c, __i);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)\n        {splice(__p, __c, __f, __l);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void remove(const value_type& __x);\n    template <class _Pred> void remove_if(_Pred __pred);\n    void unique();\n    template <class _BinaryPred>\n        void unique(_BinaryPred __binary_pred);\n    void merge(list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(list&& __c) {merge(__c);}\n#endif\n    template <class _Comp>\n        void merge(list& __c, _Comp __comp);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Comp>\n    _LIBCPP_INLINE_VISIBILITY\n        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void sort();\n    template <class _Comp>\n        void sort(_Comp __comp);\n\n    void reverse() _NOEXCEPT;\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    static void __link_nodes  (__node_pointer __p, __node_pointer __f, __node_pointer __l);\n    void __link_nodes_at_front(__node_pointer __f, __node_pointer __l);\n    void __link_nodes_at_back (__node_pointer __f, __node_pointer __l);\n    iterator __iterator(size_type __n);\n    template <class _Comp>\n        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);\n\n    void __move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value);\n    void __move_assign(list& __c, false_type);\n};\n\n// Link in nodes [__f, __l] just prior to __p\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l)\n{\n    __p->__prev_->__next_ = __f;\n    __f->__prev_ = __p->__prev_;\n    __p->__prev_ = __l;\n    __l->__next_ = __p;\n}\n\n// Link in nodes [__f, __l] at the front of the list\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes_at_front(__node_pointer __f, __node_pointer __l)\n{\n    __f->__prev_ = base::__end_.__self();\n    __l->__next_ = base::__end_.__next_;\n    __l->__next_->__prev_ = __l;\n    base::__end_.__next_ = __f;\n}\n\n// Link in nodes [__f, __l] at the front of the list\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes_at_back(__node_pointer __f, __node_pointer __l)\n{\n    __l->__next_ = base::__end_.__self();\n    __f->__prev_ = base::__end_.__prev_;\n    __f->__prev_->__next_ = __f;\n    base::__end_.__prev_ = __l;\n}\n\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__iterator(size_type __n)\n{\n    return __n <= base::__sz() / 2 ? _VSTD::next(begin(), __n)\n                                   : _VSTD::prev(end(), base::__sz() - __n);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n#endif\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c)\n    : base(allocator_type(\n           __node_alloc_traits::select_on_container_copy_construction(\n                __c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(const list& __c)\n{\n    if (this != &__c)\n    {\n        base::__copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value)\n    : base(allocator_type(_VSTD::move(__c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    splice(end(), __c);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __c.get_allocator())\n        splice(end(), __c);\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __node_alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, false_type)\n{\n    if (base::__node_alloc() != __c.__node_alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n{\n    clear();\n    base::__move_assign_alloc(__c);\n    splice(end(), __c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nvoid\nlist<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,\n                          typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __f != __l && __i != __e; ++__f, ++__i)\n        *__i = *__f;\n    if (__i == __e)\n        insert(__e, __f, __l);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __n > 0 && __i != __e; --__n, ++__i)\n        *__i = __x;\n    if (__i == __e)\n        insert(__e, __n, __x);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n_Alloc\nlist<_Tp, _Alloc>::get_allocator() const _NOEXCEPT\n{\n    return allocator_type(base::__node_alloc());\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__n > 0)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, range) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__f != __l)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (++__f; __f != __l; ++__f, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_front(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_back(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::emplace(iterator, args...) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_front()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_front() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_back() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__prev_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __p)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::erase(iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    _LIBCPP_ASSERT(__p != end(),\n        \"list::erase(iterator) called with a non-dereferenceable iterator\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = __p.__ptr_;\n    __node_pointer __r = __n->__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__r, this);\n#else\n    return iterator(__r);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == this,\n        \"list::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (__f != __l)\n    {\n        __node_allocator& __na = base::__node_alloc();\n        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);\n        while (__f != __l)\n        {\n            __node_pointer __n = __f.__ptr_;\n            ++__f;\n            --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __c_node* __c = __get_db()->__find_c_and_lock(this);\n            for (__i_node** __p = __c->end_; __p != __c->beg_; )\n            {\n                --__p;\n                iterator* __i = static_cast<iterator*>((*__p)->__i_);\n                if (__i->__ptr_ == __n)\n                {\n                    (*__p)->__c_ = nullptr;\n                    if (--__c->end_ != __p)\n                        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n            __get_db()->unlock();\n#endif\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__l.__ptr_, this);\n#else\n    return iterator(__l.__ptr_);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes_at_back(__r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c)\n{\n    _LIBCPP_ASSERT(this != &__c,\n                   \"list::splice(iterator, list) called with this == &list\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (!__c.empty())\n    {\n        __node_pointer __f = __c.__end_.__next_;\n        __node_pointer __l = __c.__end_.__prev_;\n        base::__unlink_nodes(__f, __l);\n        __link_nodes(__p.__ptr_, __f, __l);\n        base::__sz() += __c.__sz();\n        __c.__sz() = 0;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__i) == &__c,\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(&__i),\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" derefereceable\");\n#endif\n    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)\n    {\n        __node_pointer __f = __i.__ptr_;\n        base::__unlink_nodes(__f, __f);\n        __link_nodes(__p.__ptr_, __f, __f);\n        --__c.__sz();\n        ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            if (__j->__ptr_ == __f)\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == &__c,\n        \"list::splice(iterator, list, iterator, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    if (this == &__c)\n    {\n        for (const_iterator __i = __f; __i != __l; ++__i)\n            _LIBCPP_ASSERT(__i != __p,\n                           \"list::splice(iterator, list, iterator, iterator)\"\n                           \" called with the first iterator within the range\"\n                           \" of the second and third iterators\");\n    }\n#endif\n    if (__f != __l)\n    {\n        if (this != &__c)\n        {\n            size_type __s = _VSTD::distance(__f, __l);\n            __c.__sz() -= __s;\n            base::__sz() += __s;\n        }\n        __node_pointer __first = __f.__ptr_;\n        --__l;\n        __node_pointer __last = __l.__ptr_;\n        base::__unlink_nodes(__first, __last);\n        __link_nodes(__p.__ptr_, __first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            for (__node_pointer __k = __f.__ptr_;\n                                          __k != __l.__ptr_; __k = __k->__next_)\n            {\n                if (__j->__ptr_ == __k)\n                {\n                    __cn1->__add(*__p);\n                    (*__p)->__c_ = __cn1;\n                    if (--__cn2->end_ != __p)\n                        memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::remove(const value_type& __x)\n{\n    list<_Tp, _Alloc> __deleted_nodes; // collect the nodes we're removing\n    for (const_iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (*__i == __x)\n        {\n            const_iterator __j = _VSTD::next(__i);\n            for (; __j != __e && *__j == __x; ++__j)\n                ;\n            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);\n            __i = __j;\n            if (__i != __e)\n                ++__i;\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Pred>\nvoid\nlist<_Tp, _Alloc>::remove_if(_Pred __pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (__pred(*__i))\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && __pred(*__j); ++__j)\n                ;\n            __i = erase(__i, __j);\n            if (__i != __e)\n                ++__i;\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::unique()\n{\n    unique(__equal_to<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _BinaryPred>\nvoid\nlist<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        iterator __j = _VSTD::next(__i);\n        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)\n            ;\n        if (++__i != __j)\n            __i = erase(__i, __j);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::merge(list& __c)\n{\n    merge(__c, __less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\nvoid\nlist<_Tp, _Alloc>::merge(list& __c, _Comp __comp)\n{\n    if (this != &__c)\n    {\n        iterator __f1 = begin();\n        iterator __e1 = end();\n        iterator __f2 = __c.begin();\n        iterator __e2 = __c.end();\n        while (__f1 != __e1 && __f2 != __e2)\n        {\n            if (__comp(*__f2, *__f1))\n            {\n                size_type __ds = 1;\n                iterator __m2 = _VSTD::next(__f2);\n                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)\n                    ;\n                base::__sz() += __ds;\n                __c.__sz() -= __ds;\n                __node_pointer __f = __f2.__ptr_;\n                __node_pointer __l = __m2.__ptr_->__prev_;\n                __f2 = __m2;\n                base::__unlink_nodes(__f, __l);\n                __m2 = _VSTD::next(__f1);\n                __link_nodes(__f1.__ptr_, __f, __l);\n                __f1 = __m2;\n            }\n            else\n                ++__f1;\n        }\n        splice(__e1, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort()\n{\n    sort(__less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort(_Comp __comp)\n{\n    __sort(begin(), end(), base::__sz(), __comp);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)\n{\n    switch (__n)\n    {\n    case 0:\n    case 1:\n        return __f1;\n    case 2:\n        if (__comp(*--__e2, *__f1))\n        {\n            __node_pointer __f = __e2.__ptr_;\n            base::__unlink_nodes(__f, __f);\n            __link_nodes(__f1.__ptr_, __f, __f);\n            return __e2;\n        }\n        return __f1;\n    }\n    size_type __n2 = __n / 2;\n    iterator __e1 = _VSTD::next(__f1, __n2);\n    iterator  __r = __f1 = __sort(__f1, __e1, __n2, __comp);\n    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);\n    if (__comp(*__f2, *__f1))\n    {\n        iterator __m2 = _VSTD::next(__f2);\n        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n            ;\n        __node_pointer __f = __f2.__ptr_;\n        __node_pointer __l = __m2.__ptr_->__prev_;\n        __r = __f2;\n        __e1 = __f2 = __m2;\n        base::__unlink_nodes(__f, __l);\n        __m2 = _VSTD::next(__f1);\n        __link_nodes(__f1.__ptr_, __f, __l);\n        __f1 = __m2;\n    }\n    else\n        ++__f1;\n    while (__f1 != __e1 && __f2 != __e2)\n    {\n        if (__comp(*__f2, *__f1))\n        {\n            iterator __m2 = _VSTD::next(__f2);\n            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n                ;\n            __node_pointer __f = __f2.__ptr_;\n            __node_pointer __l = __m2.__ptr_->__prev_;\n            if (__e1 == __f2)\n                __e1 = __m2;\n            __f2 = __m2;\n            base::__unlink_nodes(__f, __l);\n            __m2 = _VSTD::next(__f1);\n            __link_nodes(__f1.__ptr_, __f, __l);\n            __f1 = __m2;\n        }\n        else\n            ++__f1;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::reverse() _NOEXCEPT\n{\n    if (base::__sz() > 1)\n    {\n        iterator __e = end();\n        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)\n        {\n            _VSTD::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);\n            __i.__ptr_ = __i.__ptr_->__prev_;\n        }\n        _VSTD::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__invariants() const\n{\n    return size() == _VSTD::distance(begin(), end());\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(this->__end_)));\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__decrementable(const const_iterator* __i) const\n{\n    return !empty() &&  __i->__ptr_ != base::__end_.__next_;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIST\n","/*\n* \\class CILD\n*\n* \\brief Declaration of CILD class.\n*\n* Class to handle deal with sound sources located close to the listener (Interaural Level Difference)\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: February 2016\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n\n#include <BinauralSpatializer/ILD.h>\n#include <Common/Debugger.h>\n\nILD_HashTable CILD::ILD_Data;\nint CILD::Default_ILD_AzimuthStep = 5;\nint CILD::Default_ILD_DistanceStep = 10;\n\n//////////////////////////////////////////////\n\tCILD::CILD()\n\t{\n\t\tFiltersLeft .AddFilter();\n\t\tFiltersLeft .AddFilter();\n\n\t\tFiltersRight.AddFilter();\n\t\tFiltersRight.AddFilter();\n\t}\n\n//////////////////////////////////////////////\n\t// Aplies ILD to audio samples in buffer\n\tvoid CILD::Process( CStereoBuffer<float> & buffer, float distance_m, float azimuth )\n\t{\n\t\t//if (buffer.size() <= 0)\n\t\t//{\n\t\t//\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Buffer is empty\");\n\t\t//\treturn;\n\t\t//}\n\t\t//else if (distance_m <= 0 || azimuth < -90.0 || azimuth > 90)\n\t\t//{\n\t\t//\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"Distance must be greater than zero and azimuth range is [-90, 90]\");\n\t\t//\treturn;\n\t\t//}\n\t\t//else if (Def_ILD_AzimuthStep <= 0 || Def_ILD_DistanceStep <= 0 )\n\t\t//{\n\t\t//\tSET_RESULT( RESULT_ERROR_INVALID_PARAM, \"Step values of ILD hash table are not valid.\");\n\t\t//\treturn;\n\t\t//}\n\t\t//else if ( ILD_Data == NULL )\n\t\t//{\n\t\t//\tSET_RESULT(RESULT_ERROR_NOTINITIALIZED, \"A Hash Table should be provided through CILD::SetILD_HashTable()\");\n\t\t//\treturn;\n\t\t//}\n\t\t//else\n\t\t//\tSET_RESULT( RESULT_OK, \"\" );\n\t\tASSERT(buffer.size() > 0, RESULT_ERROR_BADSIZE, \"Input buffer is empty when processing ILD\", \"\");\n\t\tASSERT(distance_m > 0, RESULT_ERROR_OUTOFRANGE, \"Distance must be greater than zero when processing ILD\", \"\");\n\t\tASSERT(azimuth >= -90.0 && azimuth <= 90, RESULT_ERROR_OUTOFRANGE, \"Azimuth must be between -90 and 90 when processing ILD\", \"\");\n\t\tASSERT(Default_ILD_AzimuthStep > 0 && Default_ILD_DistanceStep > 0, RESULT_ERROR_INVALID_PARAM, \"Step values of ILD hash table are not valid\", \"\");\n\t\t//ASSERT(ILD_Data != nullptr, RESULT_ERROR_NOTINITIALIZED, \"A Hash Table should be provided through CILD::SetILD_HashTable()\", \"\");\t\t\n\n\t\tfloat distance_mm = distance_m * 1000.0f;\n\n\t\tfloat distSign = distance_mm > 0 ? 1 : -1;\n\t\tfloat azimSign = azimuth     > 0 ? 1 : -1;\n\n\t\tint q_distance_mm = Default_ILD_DistanceStep * (int)( (distance_mm + distSign * ((float)Default_ILD_DistanceStep) / 2) / Default_ILD_DistanceStep );\n\t\tint q_azimuth     = Default_ILD_AzimuthStep  * (int)( (    azimuth + azimSign * ((float)Default_ILD_AzimuthStep ) / 2) / Default_ILD_AzimuthStep  );\n\n\t\tauto itLeft  = ILD_Data.find( CILD_Key( q_distance_mm,  q_azimuth ) );\n\t\tauto itRight = ILD_Data.find( CILD_Key( q_distance_mm, -q_azimuth ) );\n\n\t\tif (itLeft != ILD_Data.end() ) \n\t\t{\n\t\t\tFiltersLeft.GetFilter(0)->SetCoefs(   itLeft->second.coefs      );\n\t\t\tFiltersLeft.GetFilter(1)->SetCoefs( &(itLeft->second.coefs[5] ) );\t\t\t\n\n\t\t\tFiltersLeft.Process(buffer, TARGET_SAMPLES_LEFT);\n\t\t}\n\t\telse\n\t\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"{Distance-Azimuth} key value for the left channel was not found in the ILD look up table\");\n\n\t\t\n\t\tif (itRight != ILD_Data.end())\n\t\t{\n\t\t\tFiltersRight.GetFilter(0)->SetCoefs(   itRight->second.coefs       );\n\t\t\tFiltersRight.GetFilter(1)->SetCoefs( &(itRight->second.coefs[5]  ) );\n\n\t\t\tFiltersRight.Process(buffer, TARGET_SAMPLES_RIGHT);\n\t\t}\n\t\telse\n\t\t\tSET_RESULT(RESULT_ERROR_INVALID_PARAM, \"{Distance-Azimuth} key value for the left channel was not found in the ILD look up table\");\n\n\t\t//SET_RESULT(RESULT_OK, \"\");\n\t}","/*\n* \\class CCore\n*\n* \\brief Definition of CCore class.\n*\n* \\version $Alpha 1.0$\n*\n* \\author 3DI-DIANA Research Group / University of Malaga / Spain\n*\n* Contact: areyes@uma.es\n*\n* Created on: November 2015\n*\n* Project: 3DTI (3D-games for TUNing and lEarnINg about hearing aids)\n*\n* Module: 3DTI Toolkit/Core\n*/\n\n#include <BinauralSpatializer/Listener.h>\n#include <BinauralSpatializer/Core.h>\n\n\nnamespace Binaural {\n\n//////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\n\tCListener::CListener(CCore* _ownerCore, float _listenerHeadRadius)\n    :ownerCore{_ownerCore},\n     listenerHeadRadius{_listenerHeadRadius}\n    {}\n\n\n//////////////////////////////////////////////\n// LISTENER METHODS\n\n\t// Set listener position and orientation\n\tvoid CListener::SetListenerTransform(CTransform _listenerTransform)\n\t{\n\t\tlistenerTransform = _listenerTransform;\n\t}\n\n//////////////////////////////////////////////\n\n\t// Get listener position and orientation\n\tconst CTransform CListener::GetListenerTransform() const\n\t{\n        return listenerTransform;\n\t}\n\n//////////////////////////////////////////////\n\n// Get position and orientation of listener left ear\n\tconst CTransform CListener::GetListenerLeftEarTransform() const\n\t{\n\t\tCVector3 earLocalPosition = CVector3::ZERO;\n\t\tearLocalPosition.SetAxis(RIGHT_AXIS, -listenerHeadRadius);\n\t\treturn listenerTransform.GetLocalTranslation(earLocalPosition);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Get position and orientation of listener right ear\n\tconst CTransform CListener::GetListenerRightEarTransform() const\n\t{\n\t\tCVector3 earLocalPosition = CVector3::ZERO;\n\t\tearLocalPosition.SetAxis(RIGHT_AXIS, listenerHeadRadius);\n\t\treturn listenerTransform.GetLocalTranslation(earLocalPosition);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Set HRTF for listener\n\tvoid CListener::LoadHRTF(CHRTF && _listenerHRTF)\n\t{\n        // TODO: Check validity of _listenerHRTF?\n        listenerHRTF = _listenerHRTF;\n    }\n\n\t// Get HRTF for listener\t\n\tconst CHRTF& CListener::GetHRTF() const\n\t{\n\t\treturn listenerHRTF;\n\t}\n//////////////////////////////////////////////\n\n\t// Set head radius for listener (m)\n\tvoid CListener::SetHeadRadius(float _listenerHeadRadius)\n\t{\n        listenerHeadRadius = _listenerHeadRadius;\n        listenerHRTF.SetListenerHeadRadius(_listenerHeadRadius);\n\t}\n\n\t//Get listener head radious\n\tfloat CListener::GetHeadRadius() const{\n        return listenerHeadRadius;\n    }\n\n\tvoid CListener::SetCustomizedITD(bool enable) {\n\t\tlistenerHRTF.SetHRTFCustomizedITD(enable);\n    }\n}\n","/**\n* \\class CSingleSourceDSP\n*\n* \\brief Definition of CSingleSource class.\n* \\details This class manages the spatialization of a single source\n* \\version\n* \\date\tNovember 2015\n*\n* \\authors 3DI-DIANA Research Group { M. Cuevas-Rodriguez, E.J. de la Rubia-Cuestas, C. Garre, D. Gonzalez-Toledo, L. Molina-Tanco, A. Reyes-Lecuona } ||\n* \\b Contact: areyes@uma.es\n*\n* \\b Contributions: (additional authors/contributors can be added here)\n*\n* \\b Project: 3D-Tune-In (3D-games for TUNing and lEarnINg about hearing aids) ||\n* \\b Website: http://3d-tune-in.eu/\n*\n* \\b Acknowledgement: This project has received funding from the European Unions Horizon 2020 research and innovation programme under grant agreement No 644051\n*\n* \\b License: (insert agreed license terms here)\n*\n*/\n\n#include <BinauralSpatializer/SingleSourceDSP.h>\n#include <Common/Debugger.h>\n\n//#define USE_PROFILER_SingleSourceDSP\n#ifdef USE_PROFILER_SingleSourceDSP\n#include <Common/Profiler.h>\nCProfilerDataSet dsSSDSPTransform;\nCProfilerDataSet dsSSDSPGetHRIRInterpolated;\nCProfilerDataSet dsSSDSPGetHRIRNoInterpolated;\nCProfilerDataSet dsSSDSPFreqConvolver;\nCProfilerDataSet dsSSDSPTimeConvolver;\n#endif\n\n//////////////////////////////////////////////\n// CONSTRUCTOR/DESTRUCTOR\n\n//CSingleSourceDSP::CSingleSourceDSP()\n//{\n//\t// Set defaults\n//\tsourceTransform = CTransform();\n//\tocclusionAmount = 0.0f;\n//\townerCore = NULL;\n//\tleftConvolution = CConvolver();\n//\trightConvolution = CConvolver();\n//\tinterpolate = true;\n//}\n\n//////////////////////////////////////////////\n\nnamespace Binaural {\n\n//Constructor called from CCore class\nCSingleSourceDSP::CSingleSourceDSP(CCore* owner)\n{\n\t// TO THINK: our initial idea was not to use debugger in constructors. Should this this an exception to the rule?\n\t//if (owner == NULL)\n\t//\tSET_RESULT(RESULT_ERROR_NULLPOINTER, \"3DTI Toolkit Core not created\");\n\t//else\n\t//\tSET_RESULT(RESULT_OK, \"\");\n\tASSERT(owner != NULL, RESULT_ERROR_NULLPOINTER, \"3DTI Toolkit Core not created\", \"Single Source DSP succesfully created\");\n\n\t//volume = 1;\n\townerCore = owner;\n\n\t//Init vrbles\n\tbInterpolate = true;\n\tbFreqConvolution = true;\n\tfirstTime = true;\n\n\tif( owner != NULL )\n\t\tdistAttenuator.Setup(  owner->GetAudioState().sampleRate );\n\n#ifdef USE_PROFILER_SingleSourceDSP\n\tPROFILER3DTI.SetAutomaticWrite(dsSSDSPTransform, \"PROF_SSDSP_Transform.txt\");\n\tPROFILER3DTI.SetAutomaticWrite(dsSSDSPGetHRIRNoInterpolated, \"PROF_SSDSP_GetHRIR_NOInt.txt\");\n\tPROFILER3DTI.SetAutomaticWrite(dsSSDSPGetHRIRInterpolated, \"PROF_SSDSP_GetHRIR_INTERPOLATED.txt\");\n\tPROFILER3DTI.SetAutomaticWrite(dsSSDSPFreqConvolver, \"PROF_SSDSP_FrequencyConvolver.txt\");\n\tPROFILER3DTI.SetAutomaticWrite(dsSSDSPTimeConvolver, \"PROF_SSDSP_TimeConvolver.txt\");\n\tPROFILER3DTI.StartRelativeSampling(dsSSDSPTransform);\n\tPROFILER3DTI.StartRelativeSampling(dsSSDSPGetHRIRNoInterpolated);\n\tPROFILER3DTI.StartRelativeSampling(dsSSDSPGetHRIRInterpolated);\n\tPROFILER3DTI.StartRelativeSampling(dsSSDSPFreqConvolver);\n\tPROFILER3DTI.StartRelativeSampling(dsSSDSPTimeConvolver);\n#endif\n}\n\n//Default constructor, called from Loudspeaker Core\nCSingleSourceDSP::CSingleSourceDSP( ) {}\n\n//////////////////////////////////////////////\n// BASIC IN/OUT METHODS\n\n\tvoid CSingleSourceDSP::UpdateBuffer(CMonoBuffer<float> & buffer)\n\t{\n\t\tinternalBuffer = buffer;\n\t}\n\n//////////////////////////////////////////////\n\n\tconst CMonoBuffer<float> CSingleSourceDSP::GetBuffer() const\n\t{\n\t\tASSERT(internalBuffer.size() > 0, RESULT_ERROR_NOTSET, \"Getting empty buffer from single source DSP\", \"\");\n\t\treturn internalBuffer;\n\t}\n\n//////////////////////////////////////////////\n\n\t// Process data from input buffer to generate anechoic spatialization (direct path). Overloaded: using internal buffer\n\tvoid CSingleSourceDSP::ProcessAnechoic(const CListener& listener, CStereoBuffer<float> & outBuffer)\n\t{\n\t\tProcessAnechoic(listener, internalBuffer, outBuffer);\n\t}\n\n//////////////////////////////////////////////\n\n\t// Process data from input buffer to generate anechoic spatialization (direct path)\n\tvoid CSingleSourceDSP::ProcessAnechoic(const CListener& listener, const CMonoBuffer<float> & inBuffer/* FIXME: can be const ref */ , CStereoBuffer<float> & outBuffer)\n\t{\n    for (int i = 0; i < inBuffer.size(); i++) {\n      printf(\"%i = %f \\n\", i, inBuffer[i]);\n    }\n\t\tASSERT(inBuffer.size() == ownerCore->GetAudioState().bufferSize, RESULT_ERROR_BADSIZE, \"InBuffer size has to equal to the input size indicated by the Core::SetAudioState method\", \"\");\n\n\t\t#ifdef USE_PROFILER_SingleSourceDSP\n\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPTransform);\n\t\t#endif\n\n\t\t//Get HRIR from azimuth and elevation between listener and source\n\t\tCVector3 leftVectorTo  = listener.GetListenerLeftEarTransform ().GetVectorTo(sourceTransform);\n\t\tCVector3 rightVectorTo = listener.GetListenerRightEarTransform().GetVectorTo(sourceTransform);\n\n\t\tfloat leftAzimuth   = leftVectorTo.GetAzimuthDegrees();\n\t\tfloat leftElevation = leftVectorTo.GetElevationDegrees();\n\n\t\tfloat rightAzimuth   = rightVectorTo.GetAzimuthDegrees();\n\t\tfloat rightElevation = rightVectorTo.GetElevationDegrees();\n\n    printf(\"left azimuth = %f \\n\", leftAzimuth);\n    printf(\"left elevation = %f \\n\", leftElevation);\n    printf(\"right azimuth = %f \\n\", rightAzimuth);\n    printf(\"right elevation = %f \\n\", rightElevation);\n\n\t\t// WATCHER TEST\n\t\tWATCH(TWatcherVariable::WV_ANECHOIC_AZIMUTH_LEFT, leftAzimuth, float);\n\t\tWATCH(TWatcherVariable::WV_ANECHOIC_AZIMUTH_RIGHT, rightAzimuth, float);\n\t\t// END WATCHER TEST\n\n\t\t#ifdef USE_PROFILER_SingleSourceDSP\n\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPTransform);\n\t\t#endif\n\n\n\n\t\t//bool frequConvolution = true;\n\n\t\tif (modEnabler.doHRTF)\n\t\t{\n\t\t\tif (bFreqConvolution)\n\t\t\t{\n\t\t\t\t////////////////////////////\n\t\t\t\t//\tFREQUENCY CONVOLUTION\n\t\t\t\t///////////////////////////\n\t\t\t\t//Get HRIRs\n#ifdef USE_PROFILER_SingleSourceDSP\n\t\t\t\tif (bInterpolate)\n\t\t\t\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPGetHRIRInterpolated);\n\t\t\t\telse\n\t\t\t\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPGetHRIRNoInterpolated);\n#endif\n\n        CHRTF listenerHRTF = listener.GetHRTF();\n        // printf(\"listener hrtf = %p\", listenerHRTF);\n\n        printf(\"listener hrtf.GetAzimuthStep() = %i \\n\", listenerHRTF.GetAzimuthStep());\n        printf(\"listener hrtf.GetElevationStep() = %i \\n\", listenerHRTF.GetElevationStep());\n        printf(\"listener hrtf.GetHRIRLength() = %i \\n\", listenerHRTF.GetHRIRLength());\n\n        // oneEarHRIR_struct leftHRIR_Frequency = listenerHRTF.GetHRIR_left_frequency(leftAzimuth, leftElevation, bInterpolate);\n\n\t\t\t\t//Get the HRIR, with different orientation for both ears\n\t\t\t\toneEarHRIR_struct leftHRIR_Frequency = listener.GetHRTF().GetHRIR_left_frequency(leftAzimuth, leftElevation, bInterpolate);\n\t\t\t\toneEarHRIR_struct rightHRIR_Frequency = listener.GetHRTF().GetHRIR_right_frequency(rightAzimuth, rightElevation, bInterpolate);\n        printf(\"leftHRIR_Frequency = { delay: %llu, hrirs: [%u] } \\n\", leftHRIR_Frequency.delay, leftHRIR_Frequency.HRIR.size());\n// #ifdef USE_PROFILER_SingleSourceDSP\n// \t\t\t\tif (bInterpolate)\n// \t\t\t\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPGetHRIRInterpolated);\n// \t\t\t\telse\n// \t\t\t\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPGetHRIRNoInterpolated);\n// #endif\n\n\n// #ifdef USE_PROFILER_SingleSourceDSP\n// \t\t\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPFreqConvolver);\n// #endif\n\t\t\t\t// Make the FFT of input signal\n\t\t\t\tCMonoBuffer<float> inBuffer_Frequency;\n\t\t\t\tCommon::CFconvolver::GetFFT(inBuffer, inBuffer_Frequency, listener.GetHRTF().GetHRIRLength());\n        printf(\"Did get FFT from inBuffer to inBuffer_Frequency\\n\");\n\n\t\t\t\t//Multiplication of HRIR and input signal\n\t\t\t\tCMonoBuffer<float> leftChannel_Frequency;\n\t\t\t\tCMonoBuffer<float> rightChannel_Frequency;\n\n        // for (int l = 0; l < inBuffer_Frequency.size(); l++) {\n        //   printf(\"in buffer freq at %d = %f \\n\", l, inBuffer_Frequency[l]);\n        // }\n\n        // for (int l = 0; l < leftChannel_Frequency.size(); l++) {\n        //   printf(\"left channel at %d = %f \\n\", l, leftChannel_Frequency[l]);\n        // }\n\n        // for (int h = 0; h < leftHRIR_Frequency.HRIR.size(); h++) {\n        //   printf(\"left channel at %d = %f \\n\", h, leftHRIR_Frequency.HRIR[h]);\n        // }\n\n\t\t\t\tCommon::CFconvolver::ComplexMultiplication(inBuffer_Frequency, leftHRIR_Frequency.HRIR, leftChannel_Frequency);\n\t\t\t\tCommon::CFconvolver::ComplexMultiplication(inBuffer_Frequency, rightHRIR_Frequency.HRIR, rightChannel_Frequency);\n\n\t\t\t\t//Make FFT-1 of the output (two channels)\n\t\t\t\tCMonoBuffer<float> leftChannel;\n\t\t\t\tCMonoBuffer<float> rightChannel;\n\t\t\t\t//FIXME delete this firstTime\n\t\t\t\tif (firstTime)\n\t\t\t\t{\n\t\t\t\t\t//TODO move this to other place, i don't know where yet\n\t\t\t\t\tfirstTime = false;\n\t\t\t\t\toutputLeft.Setup(inBuffer.size(), listener.GetHRTF().GetHRIRLength());\n\t\t\t\t\toutputRight.Setup(inBuffer.size(), listener.GetHRTF().GetHRIRLength());\n\t\t\t\t}\n\t\t\t\toutputLeft.GetIFFT_Output(leftChannel_Frequency, leftChannel, leftHRIR_Frequency.delay);\n\t\t\t\toutputRight.GetIFFT_Output(rightChannel_Frequency, rightChannel, rightHRIR_Frequency.delay);\n\n\t\t\t\t////Adding Delay\n\t\t\t\t//CMonoBuffer<float> leftChannel_withDelay;\n\t\t\t\t//CMonoBuffer<float> rightChannel_withDelay;\n\t\t\t\t//AddDelay(leftChannel, leftHRIR_Frequency.delay, leftDelay, leftChannel_withDelay);\n\t\t\t\t//AddDelay(rightChannel, rightHRIR_Frequency.delay, rightDelay, rightChannel_withDelay);\n\t\t\t\t//leftChannel_withDelay = leftChannel;\n\t\t\t\t//rightChannel_withDelay = rightChannel;\n\n\t\t\t\t//Interlace\t\t//TODO Use a method in bufferClass\n\t\t\t\tint j = 0;\n\t\t\t\tfor (int i = 0; i < leftChannel.size(); i++) {\n          printf(\"interlacing %i = ( %f, %f ) \\n\", i, leftChannel[i], rightChannel[i]);\n\t\t\t\t\toutBuffer[j++] = leftChannel[i];\n\t\t\t\t\toutBuffer[j++] = rightChannel[i];\n\t\t\t\t}\n\n        printf(\"... done interlacing.\");\n\n#ifdef USE_PROFILER_SingleSourceDSP\n\t\t\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPFreqConvolver);\n#endif\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//TIME CONVOLUTION\n\t\t\t\t#ifdef USE_PROFILER_SingleSourceDSP\n\t\t\t\tif (bInterpolate)\n\t\t\t\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPGetHRIRInterpolated);\n\t\t\t\telse\n\t\t\t\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPGetHRIRNoInterpolated);\n\t\t\t\t#endif\n\t\t\t\t//Get the HRIR, with different orientation for both ears\n\t\t\t\tCMonoBuffer<float> leftHRIR = listener.GetHRTF().GetHRIR_left(leftAzimuth, leftElevation, bInterpolate);\n\t\t\t\tCMonoBuffer<float> rightHRIR = listener.GetHRTF().GetHRIR_right(rightAzimuth, rightElevation, bInterpolate);\n\t\t\t\t// Save the HRIR of the left channel into the convolver class\n\t\t\t\tleftConvolution.SetHRIR(leftHRIR, inBuffer.size());\n\t\t\t\t// Save the HRIR of the right channel into the convolver class\n\t\t\t\trightConvolution.SetHRIR(rightHRIR, inBuffer.size());\n\n\t\t\t\t#ifdef USE_PROFILER_SingleSourceDSP\n\t\t\t\tif (bInterpolate)\n\t\t\t\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPGetHRIRInterpolated);\n\t\t\t\telse\n\t\t\t\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPGetHRIRNoInterpolated);\n\t\t\t\t#endif\n\n\n\t\t\t\t//Code for testing\n\t\t\t\t/* //Get the HRIR, with different orientation for both ears\n\t\t\t\tCMonoBuffer<float> leftHRIR = ownerCore->GetHRTF().GetHRIR_fromDataBaseTableLEFT(leftAzimuth, leftElevation, interpolate);\n\t\t\t\tCMonoBuffer<float> rightHRIR = ownerCore->GetHRTF().GetHRIR_fromDataBaseTableRIGHT(rightAzimuth, rightElevation, interpolate);\n\t\t\t\t Save the HRIR of the left channel into the convolver\n\t\t\t\tleftConvolution.SetHRIR(leftHRIR);\n\t\t\t\t Save the HRIR of the right channel into the convolver\n\t\t\t\trightConvolution.SetHRIR(rightHRIR);*/\n\n\t\t\t\t//Convolution of both channels\n\t\t\t\t#ifdef USE_PROFILER_SingleSourceDSP\n\t\t\t\tPROFILER3DTI.RelativeSampleStart(dsSSDSPTimeConvolver);\n\t\t\t\t#endif\n\n\t\t\t\tleftConvolution .Process( inBuffer, outBuffer, 1 );\t  // Convolution of left channel\n\t\t\t\trightConvolution.Process( inBuffer, outBuffer, 2 );\t  // Convolution of right channel\n\n\t\t\t\t#ifdef USE_PROFILER_SingleSourceDSP\n\t\t\t\tPROFILER3DTI.RelativeSampleEnd(dsSSDSPTimeConvolver);\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutBuffer = inBuffer.FromMonoToStereo();\n\t\t}\n\t\tPropagateSound(listener, outBuffer, ownerCore->GetAudioState().bufferSize, ownerCore->GetAudioState().sampleRate);\n\t}\n\n//////////////////////////////////////////////\n// SET METHODS\n\n// Move source (position and orientation)\nvoid CSingleSourceDSP::SetSourceTransform(CTransform newTransform)\n{\n\tsourceTransform = newTransform;\n}\n\n//////////////////////////////////////////////\n\n// Get source transform (position and orientation)\nconst CTransform & CSingleSourceDSP::GetSourceTransform() const\n{\n\treturn sourceTransform;\n}\n\n\n//////////////////////////////////////////////\nvoid CSingleSourceDSP::SetInterpolation(bool _bInterpolate)\n{\n\tbInterpolate = _bInterpolate;\n}\n\nvoid CSingleSourceDSP::SetFrequencyConvolution(bool _bFreqConvolution) {\n\tbFreqConvolution = _bFreqConvolution;\n}\n\n// Apply sound propagation effects over a stereo buffer (private use)\nvoid CSingleSourceDSP::PropagateSound(const CListener& listener, CStereoBuffer<float> & buffer, int bufferSize, int sampleRate)\n{\n\t//SET_RESULT(RESULT_OK, \"Sound propagation was succesfull for single source\");\n\n\t// Get distance to the listener\n\tCVector3 vectorTo = listener.GetListenerTransform().GetVectorTo(sourceTransform);\n\tfloat distance = vectorTo.GetDistance();\n\n\tfloat distAttConstant = ownerCore->GetMagnitudes().GetAnechoicDistanceAttenuation();\n\n\tfloat interauralAzimuth = vectorTo.GetInterauralAzimuthDegrees();\n\n\tdistAttenuator.ApplyDistanceEffects( buffer, distance, distAttConstant, interauralAzimuth, bufferSize, sampleRate,\n\t\t\t\t\t\t\t\t\t\t modEnabler.doDistanceAttenuation,\n\t\t                                 modEnabler.doFarDistanceLPF,\n\t\t                                 modEnabler.doILD );\n}\n\n//////////////////////////////////////////////\nfloat CSingleSourceDSP::GetCutOffFreqForFarDistances(float distance)\n{\n\treturn distAttenuator.GetCutOffFreqForFarDistances(distance);\n}\n\n//////////////////////////////////////////////\n\n// Returns the attenuation gain of the anechoic process due to distance\nfloat CSingleSourceDSP::GetAnechoicDistanceAttenuation(float distance) const\n{\n\tfloat distAttConstant = ownerCore->GetMagnitudes().GetAnechoicDistanceAttenuation();\n\treturn distAttenuator.GetDistanceAttenuation(modEnabler.doDistanceAttenuation, distAttConstant, distance);\n}\n\n//////////////////////////////////////////////\n\n// Returns the attenuation gain of the reverb process due to distance\nfloat CSingleSourceDSP::GetReverbDistanceAttenuation(float distance) const\n{\n\tfloat distAttConstant = ownerCore->GetMagnitudes().GetReverbDistanceAttenuation();\n\treturn distAttenuator.GetDistanceAttenuation( modEnabler.doDistanceAttenuation, distAttConstant, distance);\n}\n\n//////////////////////////////////////////////\nvoid CSingleSourceDSP::SetupAnechoicConvolvers(int bufferSize)\n{\n\tSET_RESULT(RESULT_OK, \"Anechoic convolvers succesfully set for single source\");\n\t//leftConvolution.SetBuffer(bufferSize);\n\t//rightConvolution.SetBuffer(bufferSize);\n}\n\n//////////////////////////////////////////////\n\n//void CSingleSourceDSP::AddDelay(const CMonoBuffer<float> & input, int delaySize, delay_struct & signalDelay, CMonoBuffer<float> & output)\n//{\n//\t/*int a = delaySize - signalDelay.delaySize;\n//\tif (a != 0) cout << a << \" \";*/\n//\toutput.reserve(input.size());\n//\tif (delaySize == 0)\n//\t{\n//\t\tif (signalDelay.delaySize != 0) {\n//\t\t\t//Throw the samples\n//\t\t\tsignalDelay.delaySize = 0;\n//\t\t\tsignalDelay.samplesBuffer.clear();\n//\t\t}\n//\t\t//Copy the input to the oputput\n//\t\tfor (int i = 0; i < input.size(); i++)\n//\t\t{\n//\t\t\toutput.push_back(input[i]);\n//\t\t}\n//\t}\n//\telse if (delaySize == signalDelay.delaySize)\n//\t{\n//\t\t//First samples came from the buffer\n//\t\tfor (int i = 0; i < delaySize; i++)\n//\t\t{\n//\t\t\toutput.push_back(signalDelay.samplesBuffer[i]);\n//\t\t}\n//\t\t//Copy rest of the samples from the input signal\n//\t\tfor (int i = 0; i < input.size() - delaySize; i++)\n//\t\t{\n//\t\t\toutput.push_back(input[i]);\n//\t\t}\n//\t\t//Update Buffer with the last samples of the buffer\n//\t\tsignalDelay.samplesBuffer.clear();\n//\t\tfor (int i = input.size() - delaySize; i < input.size(); i++)\n//\t\t{\n//\t\t\tsignalDelay.samplesBuffer.push_back(input[i]);\n//\t\t}\n//\t}\n//\telse if (delaySize > signalDelay.delaySize)\n//\t{\n//\t\t//First samples came from the buffer\n//\t\tfor (int i = 0; i < signalDelay.delaySize; i++)\n//\t\t{\n//\t\t\toutput.push_back(signalDelay.samplesBuffer[i]);\n//\t\t}\n//\t\t//Interpolate N samples\n//\t\tfloat sampleInterpolate;\n//\t\tif (signalDelay.samplesBuffer.size()>0)\n//\t\t{\n//\t\t\tsampleInterpolate = 0.5f * (signalDelay.samplesBuffer[signalDelay.samplesBuffer.size() - 1] + input[0]);\n//\t\t}\n//\t\telse\n//\t\t{\n//\t\t\tsampleInterpolate = 0.5f * input[0];\n//\t\t}\n//\t\tfor (int i = signalDelay.delaySize; i < delaySize; i++)\n//\t\t{\n//\t\t\t//TODO more inteligent interpolation\n//\t\t\toutput.push_back(sampleInterpolate);\n//\t\t}\n//\t\t//Copy rest of the samples from the input signal\n//\t\tfor (int i = 0; i < input.size() - delaySize; i++)\n//\t\t{\n//\t\t\toutput.push_back(input[i]);\n//\t\t}\n//\t\t//Update Buffer with the last samples of the buffer\n//\t\tsignalDelay.samplesBuffer.clear();\n//\t\tsignalDelay.delaySize = delaySize;\n//\t\tfor (int i = input.size() - delaySize; i < input.size(); i++)\n//\t\t{\n//\t\t\tsignalDelay.samplesBuffer.push_back(input[i]);\n//\t\t}\n//\t}\n//\telse if (delaySize < signalDelay.delaySize)\n//\t{\n//\t\tint samplesRubish = signalDelay.delaySize - delaySize + 1;\n//\n//\t\t//First samples came from the buffer\n//\t\tfor (int i = 0; i <signalDelay.delaySize - samplesRubish; i++)\n//\t\t{\n//\t\t\toutput.push_back(signalDelay.samplesBuffer[i]);\n//\t\t}\n//\t\t//Interpolate\n//\t\tfloat sampleInterpolate = 0.0f;\n//\t\tfor (int i = signalDelay.delaySize - samplesRubish; i <signalDelay.delaySize; i++)\n//\t\t{\n//\t\t\tsampleInterpolate += signalDelay.samplesBuffer[i];\n//\t\t}\n//\t\tsampleInterpolate = sampleInterpolate / samplesRubish;\n//\t\toutput.push_back(sampleInterpolate);\n//\n//\t\t//Copy rest of the samples from the input signal\n//\t\tfor (int i = 0; i < input.size() - delaySize; i++)\n//\t\t{\n//\t\t\toutput.push_back(input[i]);\n//\t\t}\n//\t\t//Update Buffer with the last samples of the buffer\n//\t\tsignalDelay.samplesBuffer.clear();\n//\t\tsignalDelay.delaySize = delaySize;\n//\t\tfor (int i = input.size() - delaySize; i < input.size(); i++)\n//\t\t{\n//\t\t\tsignalDelay.samplesBuffer.push_back(input[i]);\n//\t\t}\n//\t}\n//}\n}\n","#include <emscripten/bind.h>\r\n#ifdef USE_CXA_DEMANGLE\r\n#include <../lib/libcxxabi/include/cxxabi.h>\r\n#endif\r\n#include <list>\r\n#include <vector>\r\n#include <typeinfo>\r\n#include <algorithm>\r\n#include <emscripten/emscripten.h>\r\n#include <climits>\r\n#include <limits>\r\n\r\nusing namespace emscripten;\r\n\r\nextern \"C\" {\r\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\r\n        if (has_unbound_type_names) {\r\n#ifdef USE_CXA_DEMANGLE\r\n            int stat;\r\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\r\n            if (stat == 0 && demangled) {\r\n                return demangled;\r\n            }\r\n\r\n            switch (stat) {\r\n                case -1:\r\n                    return strdup(\"<allocation failure>\");\r\n                case -2:\r\n                    return strdup(\"<invalid C++ symbol>\");\r\n                case -3:\r\n                    return strdup(\"<invalid argument>\");\r\n                default:\r\n                    return strdup(\"<unknown error>\");\r\n            }\r\n#else\r\n            return strdup(ti->name());\r\n#endif\r\n        } else {\r\n            char str[80];\r\n            sprintf(str, \"%p\", ti);\r\n            return strdup(str);\r\n        }\r\n    }\r\n}\r\n\r\nnamespace {\r\n    template<typename T>\r\n    static void register_integer(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\r\n    }\r\n\r\n    template<typename T>\r\n    static void register_float(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\r\n    }\r\n\r\n\r\n    // matches typeMapping in embind.js\r\n    enum TypedArrayIndex {\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n    };\r\n\r\n    template<typename T>\r\n    constexpr TypedArrayIndex getTypedArrayIndex() {\r\n        static_assert(\r\n            (std::is_floating_point<T>::value && (sizeof(T) == 4 || sizeof(T) == 8)) ||\r\n            (std::is_integral<T>::value && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4)),\r\n            \"type does not map to a typed array\");\r\n        return std::is_floating_point<T>::value\r\n            ? (sizeof(T) == 4\r\n               ? Float32Array\r\n               : Float64Array)\r\n            : (sizeof(T) == 1\r\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\r\n               : (sizeof(T) == 2\r\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\r\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\r\n    }\r\n\r\n    template<typename T>\r\n    static void register_memory_view(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\r\n    }\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\r\n    using namespace emscripten::internal;\r\n\r\n    _embind_register_void(TypeID<void>::get(), \"void\");\r\n    \r\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\r\n\r\n    register_integer<char>(\"char\");\r\n    register_integer<signed char>(\"signed char\");\r\n    register_integer<unsigned char>(\"unsigned char\");\r\n    register_integer<signed short>(\"short\");\r\n    register_integer<unsigned short>(\"unsigned short\");\r\n    register_integer<signed int>(\"int\");\r\n    register_integer<unsigned int>(\"unsigned int\");\r\n    register_integer<signed long>(\"long\");\r\n    register_integer<unsigned long>(\"unsigned long\");\r\n    \r\n    register_float<float>(\"float\");\r\n    register_float<double>(\"double\");\r\n    \r\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\r\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\r\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\r\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\r\n\r\n    // Some of these types are aliases for each other. Luckily,\r\n    // embind.js's _embind_register_memory_view ignores duplicate\r\n    // registrations rather than asserting, so the first\r\n    // register_memory_view call for a particular type will take\r\n    // precedence.\r\n\r\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\r\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\r\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\r\n\r\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\r\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\r\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\r\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\r\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\r\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\r\n\r\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\r\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\r\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\r\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\r\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\r\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\r\n\r\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\r\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\r\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\r\n}\r\n"]}